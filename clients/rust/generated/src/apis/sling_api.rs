/*
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `delete_agent`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAgentError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_node`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNodeError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_agent`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAgentError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_agents`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAgentsError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_authorizable_keystore`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuthorizableKeystoreError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_keystore`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetKeystoreError {
    DefaultResponse(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_node`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNodeError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_package`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPackageError {
    DefaultResponse(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_package_filter`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPackageFilterError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetQueryError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_truststore`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTruststoreError {
    DefaultResponse(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_truststore_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTruststoreInfoError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_agent`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAgentError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_authorizable_keystore`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthorizableKeystoreError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_authorizables`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAuthorizablesError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_adobe_granite_saml_authentication_handler`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigAdobeGraniteSamlAuthenticationHandlerError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_apache_felix_jetty_based_http_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigApacheFelixJettyBasedHttpServiceError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_apache_http_components_proxy_configuration`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigApacheHttpComponentsProxyConfigurationError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_apache_sling_dav_ex_servlet`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigApacheSlingDavExServletError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_apache_sling_get_servlet`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigApacheSlingGetServletError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_apache_sling_referrer_filter`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigApacheSlingReferrerFilterError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_config_property`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostConfigPropertyError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_node`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostNodeError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_node_rw`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostNodeRwError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_path`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostPathError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostQueryError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_tree_activation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostTreeActivationError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_truststore`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostTruststoreError {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_truststore_pkcs12`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostTruststorePkcs12Error {
    DefaultResponse(String),
    UnknownValue(serde_json::Value),
}


pub async fn delete_agent(configuration: &configuration::Configuration, runmode: &str, name: &str) -> Result<(), Error<DeleteAgentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/replication/agents.{runmode}/{name}", configuration.base_path, runmode=crate::apis::urlencode(runmode), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteAgentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_node(configuration: &configuration::Configuration, path: &str, name: &str) -> Result<(), Error<DeleteNodeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{path}/{name}", configuration.base_path, path=crate::apis::urlencode(path), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteNodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_agent(configuration: &configuration::Configuration, runmode: &str, name: &str) -> Result<(), Error<GetAgentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/replication/agents.{runmode}/{name}", configuration.base_path, runmode=crate::apis::urlencode(runmode), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAgentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_agents(configuration: &configuration::Configuration, runmode: &str) -> Result<String, Error<GetAgentsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/replication/agents.{runmode}.-1.json", configuration.base_path, runmode=crate::apis::urlencode(runmode));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAgentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_authorizable_keystore(configuration: &configuration::Configuration, intermediate_path: &str, authorizable_id: &str) -> Result<crate::models::KeystoreInfo, Error<GetAuthorizableKeystoreError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{intermediatePath}/{authorizableId}.ks.json", configuration.base_path, intermediatePath=crate::apis::urlencode(intermediate_path), authorizableId=crate::apis::urlencode(authorizable_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAuthorizableKeystoreError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_keystore(configuration: &configuration::Configuration, intermediate_path: &str, authorizable_id: &str) -> Result<std::path::PathBuf, Error<GetKeystoreError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{intermediatePath}/{authorizableId}/keystore/store.p12", configuration.base_path, intermediatePath=crate::apis::urlencode(intermediate_path), authorizableId=crate::apis::urlencode(authorizable_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetKeystoreError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_node(configuration: &configuration::Configuration, path: &str, name: &str) -> Result<(), Error<GetNodeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{path}/{name}", configuration.base_path, path=crate::apis::urlencode(path), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetNodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_package(configuration: &configuration::Configuration, group: &str, name: &str, version: &str) -> Result<std::path::PathBuf, Error<GetPackageError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/packages/{group}/{name}-{version}.zip", configuration.base_path, group=crate::apis::urlencode(group), name=crate::apis::urlencode(name), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetPackageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_package_filter(configuration: &configuration::Configuration, group: &str, name: &str, version: &str) -> Result<String, Error<GetPackageFilterError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json", configuration.base_path, group=crate::apis::urlencode(group), name=crate::apis::urlencode(name), version=crate::apis::urlencode(version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetPackageFilterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_query(configuration: &configuration::Configuration, path: &str, p_limit: f32, var_1_property: &str, var_1_property_value: &str) -> Result<String, Error<GetQueryError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/bin/querybuilder.json", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("path", &path.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("p.limit", &p_limit.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("1_property", &var_1_property.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("1_property.value", &var_1_property_value.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_truststore(configuration: &configuration::Configuration, ) -> Result<std::path::PathBuf, Error<GetTruststoreError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/truststore/truststore.p12", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTruststoreError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_truststore_info(configuration: &configuration::Configuration, ) -> Result<crate::models::TruststoreInfo, Error<GetTruststoreInfoError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/libs/granite/security/truststore.json", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTruststoreInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_agent(configuration: &configuration::Configuration, runmode: &str, name: &str, jcrcontent_cqdistribute: Option<bool>, jcrcontent_cqdistribute_type_hint: Option<&str>, jcrcontent_cqname: Option<&str>, jcrcontent_cqtemplate: Option<&str>, jcrcontent_enabled: Option<bool>, jcrcontent_jcrdescription: Option<&str>, jcrcontent_jcrlast_modified: Option<&str>, jcrcontent_jcrlast_modified_by: Option<&str>, jcrcontent_jcrmixin_types: Option<&str>, jcrcontent_jcrtitle: Option<&str>, jcrcontent_log_level: Option<&str>, jcrcontent_no_status_update: Option<bool>, jcrcontent_no_versioning: Option<bool>, jcrcontent_protocol_connect_timeout: Option<f32>, jcrcontent_protocol_http_connection_closed: Option<bool>, jcrcontent_protocol_http_expired: Option<&str>, jcrcontent_protocol_http_headers: Option<Vec<String>>, jcrcontent_protocol_http_headers_type_hint: Option<&str>, jcrcontent_protocol_http_method: Option<&str>, jcrcontent_protocol_https_relaxed: Option<bool>, jcrcontent_protocol_interface: Option<&str>, jcrcontent_protocol_socket_timeout: Option<f32>, jcrcontent_protocol_version: Option<&str>, jcrcontent_proxy_ntlm_domain: Option<&str>, jcrcontent_proxy_ntlm_host: Option<&str>, jcrcontent_proxy_host: Option<&str>, jcrcontent_proxy_password: Option<&str>, jcrcontent_proxy_port: Option<f32>, jcrcontent_proxy_user: Option<&str>, jcrcontent_queue_batch_max_size: Option<f32>, jcrcontent_queue_batch_mode: Option<&str>, jcrcontent_queue_batch_wait_time: Option<f32>, jcrcontent_retry_delay: Option<&str>, jcrcontent_reverse_replication: Option<bool>, jcrcontent_serialization_type: Option<&str>, jcrcontent_slingresource_type: Option<&str>, jcrcontent_ssl: Option<&str>, jcrcontent_transport_ntlm_domain: Option<&str>, jcrcontent_transport_ntlm_host: Option<&str>, jcrcontent_transport_password: Option<&str>, jcrcontent_transport_uri: Option<&str>, jcrcontent_transport_user: Option<&str>, jcrcontent_trigger_distribute: Option<bool>, jcrcontent_trigger_modified: Option<bool>, jcrcontent_trigger_on_off_time: Option<bool>, jcrcontent_trigger_receive: Option<bool>, jcrcontent_trigger_specific: Option<bool>, jcrcontent_user_id: Option<&str>, jcrprimary_type: Option<&str>, operation: Option<&str>) -> Result<(), Error<PostAgentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/replication/agents.{runmode}/{name}", configuration.base_path, runmode=crate::apis::urlencode(runmode), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = jcrcontent_cqdistribute {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/cq:distribute", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_cqdistribute_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/cq:distribute@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_cqname {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/cq:name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_cqtemplate {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/cq:template", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_jcrdescription {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/jcr:description", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_jcrlast_modified {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/jcr:lastModified", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_jcrlast_modified_by {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/jcr:lastModifiedBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_jcrmixin_types {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/jcr:mixinTypes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_jcrtitle {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/jcr:title", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_log_level {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/logLevel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_no_status_update {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/noStatusUpdate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_no_versioning {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/noVersioning", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_connect_timeout {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolConnectTimeout", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_http_connection_closed {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolHTTPConnectionClosed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_http_expired {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolHTTPExpired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_http_headers {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolHTTPHeaders", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_http_headers_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolHTTPHeaders@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_http_method {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolHTTPMethod", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_https_relaxed {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolHTTPSRelaxed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_interface {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolInterface", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_socket_timeout {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolSocketTimeout", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_protocol_version {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/protocolVersion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_proxy_ntlm_domain {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/proxyNTLMDomain", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_proxy_ntlm_host {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/proxyNTLMHost", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_proxy_host {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/proxyHost", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_proxy_password {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/proxyPassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_proxy_port {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/proxyPort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_proxy_user {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/proxyUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_queue_batch_max_size {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/queueBatchMaxSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_queue_batch_mode {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/queueBatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_queue_batch_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/queueBatchWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_retry_delay {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/retryDelay", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_reverse_replication {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/reverseReplication", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_serialization_type {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/serializationType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_slingresource_type {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/sling:resourceType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_ssl {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/ssl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_transport_ntlm_domain {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/transportNTLMDomain", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_transport_ntlm_host {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/transportNTLMHost", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_transport_password {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/transportPassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_transport_uri {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/transportUri", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_transport_user {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/transportUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_trigger_distribute {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/triggerDistribute", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_trigger_modified {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/triggerModified", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_trigger_on_off_time {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/triggerOnOffTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_trigger_receive {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/triggerReceive", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_trigger_specific {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/triggerSpecific", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrcontent_user_id {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:content/userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = jcrprimary_type {
        local_var_req_builder = local_var_req_builder.query(&[("jcr:primaryType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = operation {
        local_var_req_builder = local_var_req_builder.query(&[(":operation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostAgentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_authorizable_keystore(configuration: &configuration::Configuration, intermediate_path: &str, authorizable_id: &str, operation: Option<&str>, current_password: Option<&str>, new_password: Option<&str>, re_password: Option<&str>, key_password: Option<&str>, key_store_pass: Option<&str>, alias: Option<&str>, new_alias: Option<&str>, remove_alias: Option<&str>, cert_chain: Option<std::path::PathBuf>, pk: Option<std::path::PathBuf>, key_store: Option<std::path::PathBuf>) -> Result<crate::models::KeystoreInfo, Error<PostAuthorizableKeystoreError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{intermediatePath}/{authorizableId}.ks.html", configuration.base_path, intermediatePath=crate::apis::urlencode(intermediate_path), authorizableId=crate::apis::urlencode(authorizable_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = operation {
        local_var_req_builder = local_var_req_builder.query(&[(":operation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = current_password {
        local_var_req_builder = local_var_req_builder.query(&[("currentPassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_password {
        local_var_req_builder = local_var_req_builder.query(&[("newPassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = re_password {
        local_var_req_builder = local_var_req_builder.query(&[("rePassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key_password {
        local_var_req_builder = local_var_req_builder.query(&[("keyPassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key_store_pass {
        local_var_req_builder = local_var_req_builder.query(&[("keyStorePass", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = alias {
        local_var_req_builder = local_var_req_builder.query(&[("alias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_alias {
        local_var_req_builder = local_var_req_builder.query(&[("newAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = remove_alias {
        local_var_req_builder = local_var_req_builder.query(&[("removeAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'cert-chain' parameter
    // TODO: support file upload for 'pk' parameter
    // TODO: support file upload for 'keyStore' parameter
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostAuthorizableKeystoreError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_authorizables(configuration: &configuration::Configuration, authorizable_id: &str, intermediate_path: &str, create_user: Option<&str>, create_group: Option<&str>, reppassword: Option<&str>, profile_given_name: Option<&str>) -> Result<String, Error<PostAuthorizablesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/libs/granite/security/post/authorizables", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("authorizableId", &authorizable_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("intermediatePath", &intermediate_path.to_string())]);
    if let Some(ref local_var_str) = create_user {
        local_var_req_builder = local_var_req_builder.query(&[("createUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = create_group {
        local_var_req_builder = local_var_req_builder.query(&[("createGroup", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = reppassword {
        local_var_req_builder = local_var_req_builder.query(&[("rep:password", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profile_given_name {
        local_var_req_builder = local_var_req_builder.query(&[("profile/givenName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostAuthorizablesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_adobe_granite_saml_authentication_handler(configuration: &configuration::Configuration, key_store_password: Option<&str>, key_store_password_type_hint: Option<&str>, service_ranking: Option<i32>, service_ranking_type_hint: Option<&str>, idp_http_redirect: Option<bool>, idp_http_redirect_type_hint: Option<&str>, create_user: Option<bool>, create_user_type_hint: Option<&str>, default_redirect_url: Option<&str>, default_redirect_url_type_hint: Option<&str>, user_id_attribute: Option<&str>, user_id_attribute_type_hint: Option<&str>, default_groups: Option<Vec<String>>, default_groups_type_hint: Option<&str>, idp_cert_alias: Option<&str>, idp_cert_alias_type_hint: Option<&str>, add_group_memberships: Option<bool>, add_group_memberships_type_hint: Option<&str>, path: Option<Vec<String>>, path_type_hint: Option<&str>, synchronize_attributes: Option<Vec<String>>, synchronize_attributes_type_hint: Option<&str>, clock_tolerance: Option<i32>, clock_tolerance_type_hint: Option<&str>, group_membership_attribute: Option<&str>, group_membership_attribute_type_hint: Option<&str>, idp_url: Option<&str>, idp_url_type_hint: Option<&str>, logout_url: Option<&str>, logout_url_type_hint: Option<&str>, service_provider_entity_id: Option<&str>, service_provider_entity_id_type_hint: Option<&str>, assertion_consumer_service_url: Option<&str>, assertion_consumer_service_url_type_hint: Option<&str>, handle_logout: Option<bool>, handle_logout_type_hint: Option<&str>, sp_private_key_alias: Option<&str>, sp_private_key_alias_type_hint: Option<&str>, use_encryption: Option<bool>, use_encryption_type_hint: Option<&str>, name_id_format: Option<&str>, name_id_format_type_hint: Option<&str>, digest_method: Option<&str>, digest_method_type_hint: Option<&str>, signature_method: Option<&str>, signature_method_type_hint: Option<&str>, user_intermediate_path: Option<&str>, user_intermediate_path_type_hint: Option<&str>) -> Result<(), Error<PostConfigAdobeGraniteSamlAuthenticationHandlerError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = key_store_password {
        local_var_req_builder = local_var_req_builder.query(&[("keyStorePassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key_store_password_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("keyStorePassword@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = service_ranking {
        local_var_req_builder = local_var_req_builder.query(&[("service.ranking", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = service_ranking_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("service.ranking@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_http_redirect {
        local_var_req_builder = local_var_req_builder.query(&[("idpHttpRedirect", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_http_redirect_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("idpHttpRedirect@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = create_user {
        local_var_req_builder = local_var_req_builder.query(&[("createUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = create_user_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("createUser@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = default_redirect_url {
        local_var_req_builder = local_var_req_builder.query(&[("defaultRedirectUrl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = default_redirect_url_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("defaultRedirectUrl@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_id_attribute {
        local_var_req_builder = local_var_req_builder.query(&[("userIDAttribute", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_id_attribute_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("userIDAttribute@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = default_groups {
        local_var_req_builder = local_var_req_builder.query(&[("defaultGroups", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = default_groups_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("defaultGroups@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_cert_alias {
        local_var_req_builder = local_var_req_builder.query(&[("idpCertAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_cert_alias_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("idpCertAlias@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = add_group_memberships {
        local_var_req_builder = local_var_req_builder.query(&[("addGroupMemberships", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = add_group_memberships_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("addGroupMemberships@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = path {
        local_var_req_builder = local_var_req_builder.query(&[("path", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = path_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("path@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = synchronize_attributes {
        local_var_req_builder = local_var_req_builder.query(&[("synchronizeAttributes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = synchronize_attributes_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("synchronizeAttributes@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clock_tolerance {
        local_var_req_builder = local_var_req_builder.query(&[("clockTolerance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = clock_tolerance_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("clockTolerance@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group_membership_attribute {
        local_var_req_builder = local_var_req_builder.query(&[("groupMembershipAttribute", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group_membership_attribute_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("groupMembershipAttribute@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_url {
        local_var_req_builder = local_var_req_builder.query(&[("idpUrl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_url_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("idpUrl@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = logout_url {
        local_var_req_builder = local_var_req_builder.query(&[("logoutUrl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = logout_url_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("logoutUrl@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = service_provider_entity_id {
        local_var_req_builder = local_var_req_builder.query(&[("serviceProviderEntityId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = service_provider_entity_id_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("serviceProviderEntityId@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = assertion_consumer_service_url {
        local_var_req_builder = local_var_req_builder.query(&[("assertionConsumerServiceURL", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = assertion_consumer_service_url_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("assertionConsumerServiceURL@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = handle_logout {
        local_var_req_builder = local_var_req_builder.query(&[("handleLogout", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = handle_logout_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("handleLogout@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sp_private_key_alias {
        local_var_req_builder = local_var_req_builder.query(&[("spPrivateKeyAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sp_private_key_alias_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("spPrivateKeyAlias@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = use_encryption {
        local_var_req_builder = local_var_req_builder.query(&[("useEncryption", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = use_encryption_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("useEncryption@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name_id_format {
        local_var_req_builder = local_var_req_builder.query(&[("nameIdFormat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name_id_format_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("nameIdFormat@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = digest_method {
        local_var_req_builder = local_var_req_builder.query(&[("digestMethod", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = digest_method_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("digestMethod@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = signature_method {
        local_var_req_builder = local_var_req_builder.query(&[("signatureMethod", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = signature_method_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("signatureMethod@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_intermediate_path {
        local_var_req_builder = local_var_req_builder.query(&[("userIntermediatePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_intermediate_path_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("userIntermediatePath@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigAdobeGraniteSamlAuthenticationHandlerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_apache_felix_jetty_based_http_service(configuration: &configuration::Configuration, org_apache_felix_https_nio: Option<bool>, org_apache_felix_https_nio_type_hint: Option<&str>, org_apache_felix_https_keystore: Option<&str>, org_apache_felix_https_keystore_type_hint: Option<&str>, org_apache_felix_https_keystore_password: Option<&str>, org_apache_felix_https_keystore_password_type_hint: Option<&str>, org_apache_felix_https_keystore_key: Option<&str>, org_apache_felix_https_keystore_key_type_hint: Option<&str>, org_apache_felix_https_keystore_key_password: Option<&str>, org_apache_felix_https_keystore_key_password_type_hint: Option<&str>, org_apache_felix_https_truststore: Option<&str>, org_apache_felix_https_truststore_type_hint: Option<&str>, org_apache_felix_https_truststore_password: Option<&str>, org_apache_felix_https_truststore_password_type_hint: Option<&str>, org_apache_felix_https_clientcertificate: Option<&str>, org_apache_felix_https_clientcertificate_type_hint: Option<&str>, org_apache_felix_https_enable: Option<bool>, org_apache_felix_https_enable_type_hint: Option<&str>, org_osgi_service_http_port_secure: Option<&str>, org_osgi_service_http_port_secure_type_hint: Option<&str>) -> Result<(), Error<PostConfigApacheFelixJettyBasedHttpServiceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/org.apache.felix.http", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = org_apache_felix_https_nio {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.nio", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_nio_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.nio@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_password {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore.password", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_password_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore.password@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_key {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore.key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_key_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore.key@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_key_password {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore.key.password", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_keystore_key_password_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.keystore.key.password@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_truststore {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.truststore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_truststore_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.truststore@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_truststore_password {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.truststore.password", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_truststore_password_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.truststore.password@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_clientcertificate {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.clientcertificate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_clientcertificate_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.clientcertificate@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_enable {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.enable", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_apache_felix_https_enable_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.apache.felix.https.enable@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_osgi_service_http_port_secure {
        local_var_req_builder = local_var_req_builder.query(&[("org.osgi.service.http.port.secure", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_osgi_service_http_port_secure_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("org.osgi.service.http.port.secure@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigApacheFelixJettyBasedHttpServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_apache_http_components_proxy_configuration(configuration: &configuration::Configuration, proxy_host: Option<&str>, proxy_host_type_hint: Option<&str>, proxy_port: Option<i32>, proxy_port_type_hint: Option<&str>, proxy_exceptions: Option<Vec<String>>, proxy_exceptions_type_hint: Option<&str>, proxy_enabled: Option<bool>, proxy_enabled_type_hint: Option<&str>, proxy_user: Option<&str>, proxy_user_type_hint: Option<&str>, proxy_password: Option<&str>, proxy_password_type_hint: Option<&str>) -> Result<(), Error<PostConfigApacheHttpComponentsProxyConfigurationError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/org.apache.http.proxyconfigurator.config", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = proxy_host {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.host", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_host_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.host@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_port {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.port", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_port_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.port@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_exceptions {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.exceptions", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = proxy_exceptions_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.exceptions@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_enabled_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.enabled@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_user {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.user", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_user_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.user@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_password {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.password", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = proxy_password_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("proxy.password@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigApacheHttpComponentsProxyConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_apache_sling_dav_ex_servlet(configuration: &configuration::Configuration, alias: Option<&str>, alias_type_hint: Option<&str>, dav_create_absolute_uri: Option<bool>, dav_create_absolute_uri_type_hint: Option<&str>) -> Result<(), Error<PostConfigApacheSlingDavExServletError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alias {
        local_var_req_builder = local_var_req_builder.query(&[("alias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = alias_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("alias@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dav_create_absolute_uri {
        local_var_req_builder = local_var_req_builder.query(&[("dav.create-absolute-uri", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dav_create_absolute_uri_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("dav.create-absolute-uri@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigApacheSlingDavExServletError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_apache_sling_get_servlet(configuration: &configuration::Configuration, json_maximumresults: Option<&str>, json_maximumresults_type_hint: Option<&str>, enable_html: Option<bool>, enable_html_type_hint: Option<&str>, enable_txt: Option<bool>, enable_txt_type_hint: Option<&str>, enable_xml: Option<bool>, enable_xml_type_hint: Option<&str>) -> Result<(), Error<PostConfigApacheSlingGetServletError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = json_maximumresults {
        local_var_req_builder = local_var_req_builder.query(&[("json.maximumresults", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = json_maximumresults_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("json.maximumresults@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_html {
        local_var_req_builder = local_var_req_builder.query(&[("enable.html", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_html_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("enable.html@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_txt {
        local_var_req_builder = local_var_req_builder.query(&[("enable.txt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_txt_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("enable.txt@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_xml {
        local_var_req_builder = local_var_req_builder.query(&[("enable.xml", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_xml_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("enable.xml@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigApacheSlingGetServletError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_apache_sling_referrer_filter(configuration: &configuration::Configuration, allow_empty: Option<bool>, allow_empty_type_hint: Option<&str>, allow_hosts: Option<&str>, allow_hosts_type_hint: Option<&str>, allow_hosts_regexp: Option<&str>, allow_hosts_regexp_type_hint: Option<&str>, filter_methods: Option<&str>, filter_methods_type_hint: Option<&str>) -> Result<(), Error<PostConfigApacheSlingReferrerFilterError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = allow_empty {
        local_var_req_builder = local_var_req_builder.query(&[("allow.empty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_empty_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("allow.empty@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_hosts {
        local_var_req_builder = local_var_req_builder.query(&[("allow.hosts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_hosts_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("allow.hosts@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_hosts_regexp {
        local_var_req_builder = local_var_req_builder.query(&[("allow.hosts.regexp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = allow_hosts_regexp_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("allow.hosts.regexp@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_methods {
        local_var_req_builder = local_var_req_builder.query(&[("filter.methods", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_methods_type_hint {
        local_var_req_builder = local_var_req_builder.query(&[("filter.methods@TypeHint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigApacheSlingReferrerFilterError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_config_property(configuration: &configuration::Configuration, config_node_name: &str) -> Result<(), Error<PostConfigPropertyError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/apps/system/config/{configNodeName}", configuration.base_path, configNodeName=crate::apis::urlencode(config_node_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostConfigPropertyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_node(configuration: &configuration::Configuration, path: &str, name: &str, operation: Option<&str>, delete_authorizable: Option<&str>, file: Option<std::path::PathBuf>) -> Result<(), Error<PostNodeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{path}/{name}", configuration.base_path, path=crate::apis::urlencode(path), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = operation {
        local_var_req_builder = local_var_req_builder.query(&[(":operation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = delete_authorizable {
        local_var_req_builder = local_var_req_builder.query(&[("deleteAuthorizable", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostNodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_node_rw(configuration: &configuration::Configuration, path: &str, name: &str, add_members: Option<&str>) -> Result<(), Error<PostNodeRwError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{path}/{name}.rw.html", configuration.base_path, path=crate::apis::urlencode(path), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = add_members {
        local_var_req_builder = local_var_req_builder.query(&[("addMembers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostNodeRwError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_path(configuration: &configuration::Configuration, path: &str, jcrprimary_type: &str, name: &str) -> Result<(), Error<PostPathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/{path}/", configuration.base_path, path=crate::apis::urlencode(path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("jcr:primaryType", &jcrprimary_type.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[(":name", &name.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostPathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_query(configuration: &configuration::Configuration, path: &str, p_limit: f32, var_1_property: &str, var_1_property_value: &str) -> Result<String, Error<PostQueryError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/bin/querybuilder.json", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("path", &path.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("p.limit", &p_limit.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("1_property", &var_1_property.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("1_property.value", &var_1_property_value.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_tree_activation(configuration: &configuration::Configuration, ignoredeactivated: bool, onlymodified: bool, path: &str) -> Result<(), Error<PostTreeActivationError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/replication/treeactivation.html", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ignoredeactivated", &ignoredeactivated.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("onlymodified", &onlymodified.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("path", &path.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PostTreeActivationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_truststore(configuration: &configuration::Configuration, operation: Option<&str>, new_password: Option<&str>, re_password: Option<&str>, key_store_type: Option<&str>, remove_alias: Option<&str>, certificate: Option<std::path::PathBuf>) -> Result<String, Error<PostTruststoreError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/libs/granite/security/post/truststore", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = operation {
        local_var_req_builder = local_var_req_builder.query(&[(":operation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_password {
        local_var_req_builder = local_var_req_builder.query(&[("newPassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = re_password {
        local_var_req_builder = local_var_req_builder.query(&[("rePassword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key_store_type {
        local_var_req_builder = local_var_req_builder.query(&[("keyStoreType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = remove_alias {
        local_var_req_builder = local_var_req_builder.query(&[("removeAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'certificate' parameter
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostTruststoreError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn post_truststore_pkcs12(configuration: &configuration::Configuration, truststore_p12: Option<std::path::PathBuf>) -> Result<String, Error<PostTruststorePkcs12Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/etc/truststore", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'truststore.p12' parameter
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostTruststorePkcs12Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

