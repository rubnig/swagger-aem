/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class SlingApi {
    protected basePath = 'http://localhost';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public deleteAgent(runmode: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     */
    public deleteNode(path: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public getAgent(runmode: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param runmode 
     */
    public getAgents(runmode: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}.-1.json'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.KeystoreInfo;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.json'.replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath))).replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.KeystoreInfo;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.KeystoreInfo, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public getKeystore(intermediatePath: string, authorizableId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}/keystore/store.p12'.replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath))).replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     */
    public getNode(path: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackage(group: string, name: string, version: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip'.replace('{' + 'group' + '}', encodeURIComponent(String(group))).replace('{' + 'name' + '}', encodeURIComponent(String(name))).replace('{' + 'version' + '}', encodeURIComponent(String(version)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public getPackageFilter(group: string, name: string, version: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json'.replace('{' + 'group' + '}', encodeURIComponent(String(group))).replace('{' + 'name' + '}', encodeURIComponent(String(name))).replace('{' + 'version' + '}', encodeURIComponent(String(version)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/bin/querybuilder.json';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        if (path !== null && path !== undefined) {
            queryParameters['path'] = <string><any>path;
        }
        if (pLimit !== null && pLimit !== undefined) {
            queryParameters['p.limit'] = <string><any>pLimit;
        }
        if (_1property !== null && _1property !== undefined) {
            queryParameters['1_property'] = <string><any>_1property;
        }
        if (_1propertyValue !== null && _1propertyValue !== undefined) {
            queryParameters['1_property.value'] = <string><any>_1propertyValue;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     */
    public getTruststore(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/truststore/truststore.p12';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     */
    public getTruststoreInfo(extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.TruststoreInfo;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/libs/granite/security/truststore.json';

        let queryParameters: any = {};
        let headerParams: any = {};

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.TruststoreInfo;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.TruststoreInfo, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param runmode 
     * @param name 
     * @param jcrcontentCqdistribute 
     * @param jcrcontentCqdistributeTypeHint 
     * @param jcrcontentCqname 
     * @param jcrcontentCqtemplate 
     * @param jcrcontentEnabled 
     * @param jcrcontentJcrdescription 
     * @param jcrcontentJcrlastModified 
     * @param jcrcontentJcrlastModifiedBy 
     * @param jcrcontentJcrmixinTypes 
     * @param jcrcontentJcrtitle 
     * @param jcrcontentLogLevel 
     * @param jcrcontentNoStatusUpdate 
     * @param jcrcontentNoVersioning 
     * @param jcrcontentProtocolConnectTimeout 
     * @param jcrcontentProtocolHTTPConnectionClosed 
     * @param jcrcontentProtocolHTTPExpired 
     * @param jcrcontentProtocolHTTPHeaders 
     * @param jcrcontentProtocolHTTPHeadersTypeHint 
     * @param jcrcontentProtocolHTTPMethod 
     * @param jcrcontentProtocolHTTPSRelaxed 
     * @param jcrcontentProtocolInterface 
     * @param jcrcontentProtocolSocketTimeout 
     * @param jcrcontentProtocolVersion 
     * @param jcrcontentProxyNTLMDomain 
     * @param jcrcontentProxyNTLMHost 
     * @param jcrcontentProxyHost 
     * @param jcrcontentProxyPassword 
     * @param jcrcontentProxyPort 
     * @param jcrcontentProxyUser 
     * @param jcrcontentQueueBatchMaxSize 
     * @param jcrcontentQueueBatchMode 
     * @param jcrcontentQueueBatchWaitTime 
     * @param jcrcontentRetryDelay 
     * @param jcrcontentReverseReplication 
     * @param jcrcontentSerializationType 
     * @param jcrcontentSlingresourceType 
     * @param jcrcontentSsl 
     * @param jcrcontentTransportNTLMDomain 
     * @param jcrcontentTransportNTLMHost 
     * @param jcrcontentTransportPassword 
     * @param jcrcontentTransportUri 
     * @param jcrcontentTransportUser 
     * @param jcrcontentTriggerDistribute 
     * @param jcrcontentTriggerModified 
     * @param jcrcontentTriggerOnOffTime 
     * @param jcrcontentTriggerReceive 
     * @param jcrcontentTriggerSpecific 
     * @param jcrcontentUserId 
     * @param jcrprimaryType 
     * @param operation 
     */
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'.replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        if (jcrcontentCqdistribute !== null && jcrcontentCqdistribute !== undefined) {
            queryParameters['jcr:content/cq:distribute'] = <string><any>jcrcontentCqdistribute;
        }
        if (jcrcontentCqdistributeTypeHint !== null && jcrcontentCqdistributeTypeHint !== undefined) {
            queryParameters['jcr:content/cq:distribute@TypeHint'] = <string><any>jcrcontentCqdistributeTypeHint;
        }
        if (jcrcontentCqname !== null && jcrcontentCqname !== undefined) {
            queryParameters['jcr:content/cq:name'] = <string><any>jcrcontentCqname;
        }
        if (jcrcontentCqtemplate !== null && jcrcontentCqtemplate !== undefined) {
            queryParameters['jcr:content/cq:template'] = <string><any>jcrcontentCqtemplate;
        }
        if (jcrcontentEnabled !== null && jcrcontentEnabled !== undefined) {
            queryParameters['jcr:content/enabled'] = <string><any>jcrcontentEnabled;
        }
        if (jcrcontentJcrdescription !== null && jcrcontentJcrdescription !== undefined) {
            queryParameters['jcr:content/jcr:description'] = <string><any>jcrcontentJcrdescription;
        }
        if (jcrcontentJcrlastModified !== null && jcrcontentJcrlastModified !== undefined) {
            queryParameters['jcr:content/jcr:lastModified'] = <string><any>jcrcontentJcrlastModified;
        }
        if (jcrcontentJcrlastModifiedBy !== null && jcrcontentJcrlastModifiedBy !== undefined) {
            queryParameters['jcr:content/jcr:lastModifiedBy'] = <string><any>jcrcontentJcrlastModifiedBy;
        }
        if (jcrcontentJcrmixinTypes !== null && jcrcontentJcrmixinTypes !== undefined) {
            queryParameters['jcr:content/jcr:mixinTypes'] = <string><any>jcrcontentJcrmixinTypes;
        }
        if (jcrcontentJcrtitle !== null && jcrcontentJcrtitle !== undefined) {
            queryParameters['jcr:content/jcr:title'] = <string><any>jcrcontentJcrtitle;
        }
        if (jcrcontentLogLevel !== null && jcrcontentLogLevel !== undefined) {
            queryParameters['jcr:content/logLevel'] = <string><any>jcrcontentLogLevel;
        }
        if (jcrcontentNoStatusUpdate !== null && jcrcontentNoStatusUpdate !== undefined) {
            queryParameters['jcr:content/noStatusUpdate'] = <string><any>jcrcontentNoStatusUpdate;
        }
        if (jcrcontentNoVersioning !== null && jcrcontentNoVersioning !== undefined) {
            queryParameters['jcr:content/noVersioning'] = <string><any>jcrcontentNoVersioning;
        }
        if (jcrcontentProtocolConnectTimeout !== null && jcrcontentProtocolConnectTimeout !== undefined) {
            queryParameters['jcr:content/protocolConnectTimeout'] = <string><any>jcrcontentProtocolConnectTimeout;
        }
        if (jcrcontentProtocolHTTPConnectionClosed !== null && jcrcontentProtocolHTTPConnectionClosed !== undefined) {
            queryParameters['jcr:content/protocolHTTPConnectionClosed'] = <string><any>jcrcontentProtocolHTTPConnectionClosed;
        }
        if (jcrcontentProtocolHTTPExpired !== null && jcrcontentProtocolHTTPExpired !== undefined) {
            queryParameters['jcr:content/protocolHTTPExpired'] = <string><any>jcrcontentProtocolHTTPExpired;
        }
        if (jcrcontentProtocolHTTPHeaders) {
            queryParameters['jcr:content/protocolHTTPHeaders'] = [];
            jcrcontentProtocolHTTPHeaders.forEach((element: any) => {
                queryParameters['jcr:content/protocolHTTPHeaders'].push(element);
            });
        }
        if (jcrcontentProtocolHTTPHeadersTypeHint !== null && jcrcontentProtocolHTTPHeadersTypeHint !== undefined) {
            queryParameters['jcr:content/protocolHTTPHeaders@TypeHint'] = <string><any>jcrcontentProtocolHTTPHeadersTypeHint;
        }
        if (jcrcontentProtocolHTTPMethod !== null && jcrcontentProtocolHTTPMethod !== undefined) {
            queryParameters['jcr:content/protocolHTTPMethod'] = <string><any>jcrcontentProtocolHTTPMethod;
        }
        if (jcrcontentProtocolHTTPSRelaxed !== null && jcrcontentProtocolHTTPSRelaxed !== undefined) {
            queryParameters['jcr:content/protocolHTTPSRelaxed'] = <string><any>jcrcontentProtocolHTTPSRelaxed;
        }
        if (jcrcontentProtocolInterface !== null && jcrcontentProtocolInterface !== undefined) {
            queryParameters['jcr:content/protocolInterface'] = <string><any>jcrcontentProtocolInterface;
        }
        if (jcrcontentProtocolSocketTimeout !== null && jcrcontentProtocolSocketTimeout !== undefined) {
            queryParameters['jcr:content/protocolSocketTimeout'] = <string><any>jcrcontentProtocolSocketTimeout;
        }
        if (jcrcontentProtocolVersion !== null && jcrcontentProtocolVersion !== undefined) {
            queryParameters['jcr:content/protocolVersion'] = <string><any>jcrcontentProtocolVersion;
        }
        if (jcrcontentProxyNTLMDomain !== null && jcrcontentProxyNTLMDomain !== undefined) {
            queryParameters['jcr:content/proxyNTLMDomain'] = <string><any>jcrcontentProxyNTLMDomain;
        }
        if (jcrcontentProxyNTLMHost !== null && jcrcontentProxyNTLMHost !== undefined) {
            queryParameters['jcr:content/proxyNTLMHost'] = <string><any>jcrcontentProxyNTLMHost;
        }
        if (jcrcontentProxyHost !== null && jcrcontentProxyHost !== undefined) {
            queryParameters['jcr:content/proxyHost'] = <string><any>jcrcontentProxyHost;
        }
        if (jcrcontentProxyPassword !== null && jcrcontentProxyPassword !== undefined) {
            queryParameters['jcr:content/proxyPassword'] = <string><any>jcrcontentProxyPassword;
        }
        if (jcrcontentProxyPort !== null && jcrcontentProxyPort !== undefined) {
            queryParameters['jcr:content/proxyPort'] = <string><any>jcrcontentProxyPort;
        }
        if (jcrcontentProxyUser !== null && jcrcontentProxyUser !== undefined) {
            queryParameters['jcr:content/proxyUser'] = <string><any>jcrcontentProxyUser;
        }
        if (jcrcontentQueueBatchMaxSize !== null && jcrcontentQueueBatchMaxSize !== undefined) {
            queryParameters['jcr:content/queueBatchMaxSize'] = <string><any>jcrcontentQueueBatchMaxSize;
        }
        if (jcrcontentQueueBatchMode !== null && jcrcontentQueueBatchMode !== undefined) {
            queryParameters['jcr:content/queueBatchMode'] = <string><any>jcrcontentQueueBatchMode;
        }
        if (jcrcontentQueueBatchWaitTime !== null && jcrcontentQueueBatchWaitTime !== undefined) {
            queryParameters['jcr:content/queueBatchWaitTime'] = <string><any>jcrcontentQueueBatchWaitTime;
        }
        if (jcrcontentRetryDelay !== null && jcrcontentRetryDelay !== undefined) {
            queryParameters['jcr:content/retryDelay'] = <string><any>jcrcontentRetryDelay;
        }
        if (jcrcontentReverseReplication !== null && jcrcontentReverseReplication !== undefined) {
            queryParameters['jcr:content/reverseReplication'] = <string><any>jcrcontentReverseReplication;
        }
        if (jcrcontentSerializationType !== null && jcrcontentSerializationType !== undefined) {
            queryParameters['jcr:content/serializationType'] = <string><any>jcrcontentSerializationType;
        }
        if (jcrcontentSlingresourceType !== null && jcrcontentSlingresourceType !== undefined) {
            queryParameters['jcr:content/sling:resourceType'] = <string><any>jcrcontentSlingresourceType;
        }
        if (jcrcontentSsl !== null && jcrcontentSsl !== undefined) {
            queryParameters['jcr:content/ssl'] = <string><any>jcrcontentSsl;
        }
        if (jcrcontentTransportNTLMDomain !== null && jcrcontentTransportNTLMDomain !== undefined) {
            queryParameters['jcr:content/transportNTLMDomain'] = <string><any>jcrcontentTransportNTLMDomain;
        }
        if (jcrcontentTransportNTLMHost !== null && jcrcontentTransportNTLMHost !== undefined) {
            queryParameters['jcr:content/transportNTLMHost'] = <string><any>jcrcontentTransportNTLMHost;
        }
        if (jcrcontentTransportPassword !== null && jcrcontentTransportPassword !== undefined) {
            queryParameters['jcr:content/transportPassword'] = <string><any>jcrcontentTransportPassword;
        }
        if (jcrcontentTransportUri !== null && jcrcontentTransportUri !== undefined) {
            queryParameters['jcr:content/transportUri'] = <string><any>jcrcontentTransportUri;
        }
        if (jcrcontentTransportUser !== null && jcrcontentTransportUser !== undefined) {
            queryParameters['jcr:content/transportUser'] = <string><any>jcrcontentTransportUser;
        }
        if (jcrcontentTriggerDistribute !== null && jcrcontentTriggerDistribute !== undefined) {
            queryParameters['jcr:content/triggerDistribute'] = <string><any>jcrcontentTriggerDistribute;
        }
        if (jcrcontentTriggerModified !== null && jcrcontentTriggerModified !== undefined) {
            queryParameters['jcr:content/triggerModified'] = <string><any>jcrcontentTriggerModified;
        }
        if (jcrcontentTriggerOnOffTime !== null && jcrcontentTriggerOnOffTime !== undefined) {
            queryParameters['jcr:content/triggerOnOffTime'] = <string><any>jcrcontentTriggerOnOffTime;
        }
        if (jcrcontentTriggerReceive !== null && jcrcontentTriggerReceive !== undefined) {
            queryParameters['jcr:content/triggerReceive'] = <string><any>jcrcontentTriggerReceive;
        }
        if (jcrcontentTriggerSpecific !== null && jcrcontentTriggerSpecific !== undefined) {
            queryParameters['jcr:content/triggerSpecific'] = <string><any>jcrcontentTriggerSpecific;
        }
        if (jcrcontentUserId !== null && jcrcontentUserId !== undefined) {
            queryParameters['jcr:content/userId'] = <string><any>jcrcontentUserId;
        }
        if (jcrprimaryType !== null && jcrprimaryType !== undefined) {
            queryParameters['jcr:primaryType'] = <string><any>jcrprimaryType;
        }
        if (operation !== null && operation !== undefined) {
            queryParameters[':operation'] = <string><any>operation;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.KeystoreInfo;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.html'.replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath))).replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        if (operation !== null && operation !== undefined) {
            queryParameters[':operation'] = <string><any>operation;
        }
        if (currentPassword !== null && currentPassword !== undefined) {
            queryParameters['currentPassword'] = <string><any>currentPassword;
        }
        if (newPassword !== null && newPassword !== undefined) {
            queryParameters['newPassword'] = <string><any>newPassword;
        }
        if (rePassword !== null && rePassword !== undefined) {
            queryParameters['rePassword'] = <string><any>rePassword;
        }
        if (keyPassword !== null && keyPassword !== undefined) {
            queryParameters['keyPassword'] = <string><any>keyPassword;
        }
        if (keyStorePass !== null && keyStorePass !== undefined) {
            queryParameters['keyStorePass'] = <string><any>keyStorePass;
        }
        if (alias !== null && alias !== undefined) {
            queryParameters['alias'] = <string><any>alias;
        }
        if (newAlias !== null && newAlias !== undefined) {
            queryParameters['newAlias'] = <string><any>newAlias;
        }
        if (removeAlias !== null && removeAlias !== undefined) {
            queryParameters['removeAlias'] = <string><any>removeAlias;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("cert-chain", certChain);
        reqHasFile = true;
        formParams.append("pk", pk);
        reqHasFile = true;
        formParams.append("keyStore", keyStore);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.KeystoreInfo;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.KeystoreInfo, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param reppassword 
     * @param profileGivenName 
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/libs/granite/security/post/authorizables';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        if (authorizableId !== null && authorizableId !== undefined) {
            queryParameters['authorizableId'] = <string><any>authorizableId;
        }
        if (intermediatePath !== null && intermediatePath !== undefined) {
            queryParameters['intermediatePath'] = <string><any>intermediatePath;
        }
        if (createUser !== null && createUser !== undefined) {
            queryParameters['createUser'] = <string><any>createUser;
        }
        if (createGroup !== null && createGroup !== undefined) {
            queryParameters['createGroup'] = <string><any>createGroup;
        }
        if (reppassword !== null && reppassword !== undefined) {
            queryParameters['rep:password'] = <string><any>reppassword;
        }
        if (profileGivenName !== null && profileGivenName !== undefined) {
            queryParameters['profile/givenName'] = <string><any>profileGivenName;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/html'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param keyStorePassword 
     * @param keyStorePasswordTypeHint 
     * @param serviceRanking 
     * @param serviceRankingTypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirectTypeHint 
     * @param createUser 
     * @param createUserTypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrlTypeHint 
     * @param userIDAttribute 
     * @param userIDAttributeTypeHint 
     * @param defaultGroups 
     * @param defaultGroupsTypeHint 
     * @param idpCertAlias 
     * @param idpCertAliasTypeHint 
     * @param addGroupMemberships 
     * @param addGroupMembershipsTypeHint 
     * @param path 
     * @param pathTypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributesTypeHint 
     * @param clockTolerance 
     * @param clockToleranceTypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttributeTypeHint 
     * @param idpUrl 
     * @param idpUrlTypeHint 
     * @param logoutUrl 
     * @param logoutUrlTypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityIdTypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURLTypeHint 
     * @param handleLogout 
     * @param handleLogoutTypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAliasTypeHint 
     * @param useEncryption 
     * @param useEncryptionTypeHint 
     * @param nameIdFormat 
     * @param nameIdFormatTypeHint 
     * @param digestMethod 
     * @param digestMethodTypeHint 
     * @param signatureMethod 
     * @param signatureMethodTypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePathTypeHint 
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (keyStorePassword !== null && keyStorePassword !== undefined) {
            queryParameters['keyStorePassword'] = <string><any>keyStorePassword;
        }
        if (keyStorePasswordTypeHint !== null && keyStorePasswordTypeHint !== undefined) {
            queryParameters['keyStorePassword@TypeHint'] = <string><any>keyStorePasswordTypeHint;
        }
        if (serviceRanking !== null && serviceRanking !== undefined) {
            queryParameters['service.ranking'] = <string><any>serviceRanking;
        }
        if (serviceRankingTypeHint !== null && serviceRankingTypeHint !== undefined) {
            queryParameters['service.ranking@TypeHint'] = <string><any>serviceRankingTypeHint;
        }
        if (idpHttpRedirect !== null && idpHttpRedirect !== undefined) {
            queryParameters['idpHttpRedirect'] = <string><any>idpHttpRedirect;
        }
        if (idpHttpRedirectTypeHint !== null && idpHttpRedirectTypeHint !== undefined) {
            queryParameters['idpHttpRedirect@TypeHint'] = <string><any>idpHttpRedirectTypeHint;
        }
        if (createUser !== null && createUser !== undefined) {
            queryParameters['createUser'] = <string><any>createUser;
        }
        if (createUserTypeHint !== null && createUserTypeHint !== undefined) {
            queryParameters['createUser@TypeHint'] = <string><any>createUserTypeHint;
        }
        if (defaultRedirectUrl !== null && defaultRedirectUrl !== undefined) {
            queryParameters['defaultRedirectUrl'] = <string><any>defaultRedirectUrl;
        }
        if (defaultRedirectUrlTypeHint !== null && defaultRedirectUrlTypeHint !== undefined) {
            queryParameters['defaultRedirectUrl@TypeHint'] = <string><any>defaultRedirectUrlTypeHint;
        }
        if (userIDAttribute !== null && userIDAttribute !== undefined) {
            queryParameters['userIDAttribute'] = <string><any>userIDAttribute;
        }
        if (userIDAttributeTypeHint !== null && userIDAttributeTypeHint !== undefined) {
            queryParameters['userIDAttribute@TypeHint'] = <string><any>userIDAttributeTypeHint;
        }
        if (defaultGroups) {
            queryParameters['defaultGroups'] = [];
            defaultGroups.forEach((element: any) => {
                queryParameters['defaultGroups'].push(element);
            });
        }
        if (defaultGroupsTypeHint !== null && defaultGroupsTypeHint !== undefined) {
            queryParameters['defaultGroups@TypeHint'] = <string><any>defaultGroupsTypeHint;
        }
        if (idpCertAlias !== null && idpCertAlias !== undefined) {
            queryParameters['idpCertAlias'] = <string><any>idpCertAlias;
        }
        if (idpCertAliasTypeHint !== null && idpCertAliasTypeHint !== undefined) {
            queryParameters['idpCertAlias@TypeHint'] = <string><any>idpCertAliasTypeHint;
        }
        if (addGroupMemberships !== null && addGroupMemberships !== undefined) {
            queryParameters['addGroupMemberships'] = <string><any>addGroupMemberships;
        }
        if (addGroupMembershipsTypeHint !== null && addGroupMembershipsTypeHint !== undefined) {
            queryParameters['addGroupMemberships@TypeHint'] = <string><any>addGroupMembershipsTypeHint;
        }
        if (path) {
            queryParameters['path'] = [];
            path.forEach((element: any) => {
                queryParameters['path'].push(element);
            });
        }
        if (pathTypeHint !== null && pathTypeHint !== undefined) {
            queryParameters['path@TypeHint'] = <string><any>pathTypeHint;
        }
        if (synchronizeAttributes) {
            queryParameters['synchronizeAttributes'] = [];
            synchronizeAttributes.forEach((element: any) => {
                queryParameters['synchronizeAttributes'].push(element);
            });
        }
        if (synchronizeAttributesTypeHint !== null && synchronizeAttributesTypeHint !== undefined) {
            queryParameters['synchronizeAttributes@TypeHint'] = <string><any>synchronizeAttributesTypeHint;
        }
        if (clockTolerance !== null && clockTolerance !== undefined) {
            queryParameters['clockTolerance'] = <string><any>clockTolerance;
        }
        if (clockToleranceTypeHint !== null && clockToleranceTypeHint !== undefined) {
            queryParameters['clockTolerance@TypeHint'] = <string><any>clockToleranceTypeHint;
        }
        if (groupMembershipAttribute !== null && groupMembershipAttribute !== undefined) {
            queryParameters['groupMembershipAttribute'] = <string><any>groupMembershipAttribute;
        }
        if (groupMembershipAttributeTypeHint !== null && groupMembershipAttributeTypeHint !== undefined) {
            queryParameters['groupMembershipAttribute@TypeHint'] = <string><any>groupMembershipAttributeTypeHint;
        }
        if (idpUrl !== null && idpUrl !== undefined) {
            queryParameters['idpUrl'] = <string><any>idpUrl;
        }
        if (idpUrlTypeHint !== null && idpUrlTypeHint !== undefined) {
            queryParameters['idpUrl@TypeHint'] = <string><any>idpUrlTypeHint;
        }
        if (logoutUrl !== null && logoutUrl !== undefined) {
            queryParameters['logoutUrl'] = <string><any>logoutUrl;
        }
        if (logoutUrlTypeHint !== null && logoutUrlTypeHint !== undefined) {
            queryParameters['logoutUrl@TypeHint'] = <string><any>logoutUrlTypeHint;
        }
        if (serviceProviderEntityId !== null && serviceProviderEntityId !== undefined) {
            queryParameters['serviceProviderEntityId'] = <string><any>serviceProviderEntityId;
        }
        if (serviceProviderEntityIdTypeHint !== null && serviceProviderEntityIdTypeHint !== undefined) {
            queryParameters['serviceProviderEntityId@TypeHint'] = <string><any>serviceProviderEntityIdTypeHint;
        }
        if (assertionConsumerServiceURL !== null && assertionConsumerServiceURL !== undefined) {
            queryParameters['assertionConsumerServiceURL'] = <string><any>assertionConsumerServiceURL;
        }
        if (assertionConsumerServiceURLTypeHint !== null && assertionConsumerServiceURLTypeHint !== undefined) {
            queryParameters['assertionConsumerServiceURL@TypeHint'] = <string><any>assertionConsumerServiceURLTypeHint;
        }
        if (handleLogout !== null && handleLogout !== undefined) {
            queryParameters['handleLogout'] = <string><any>handleLogout;
        }
        if (handleLogoutTypeHint !== null && handleLogoutTypeHint !== undefined) {
            queryParameters['handleLogout@TypeHint'] = <string><any>handleLogoutTypeHint;
        }
        if (spPrivateKeyAlias !== null && spPrivateKeyAlias !== undefined) {
            queryParameters['spPrivateKeyAlias'] = <string><any>spPrivateKeyAlias;
        }
        if (spPrivateKeyAliasTypeHint !== null && spPrivateKeyAliasTypeHint !== undefined) {
            queryParameters['spPrivateKeyAlias@TypeHint'] = <string><any>spPrivateKeyAliasTypeHint;
        }
        if (useEncryption !== null && useEncryption !== undefined) {
            queryParameters['useEncryption'] = <string><any>useEncryption;
        }
        if (useEncryptionTypeHint !== null && useEncryptionTypeHint !== undefined) {
            queryParameters['useEncryption@TypeHint'] = <string><any>useEncryptionTypeHint;
        }
        if (nameIdFormat !== null && nameIdFormat !== undefined) {
            queryParameters['nameIdFormat'] = <string><any>nameIdFormat;
        }
        if (nameIdFormatTypeHint !== null && nameIdFormatTypeHint !== undefined) {
            queryParameters['nameIdFormat@TypeHint'] = <string><any>nameIdFormatTypeHint;
        }
        if (digestMethod !== null && digestMethod !== undefined) {
            queryParameters['digestMethod'] = <string><any>digestMethod;
        }
        if (digestMethodTypeHint !== null && digestMethodTypeHint !== undefined) {
            queryParameters['digestMethod@TypeHint'] = <string><any>digestMethodTypeHint;
        }
        if (signatureMethod !== null && signatureMethod !== undefined) {
            queryParameters['signatureMethod'] = <string><any>signatureMethod;
        }
        if (signatureMethodTypeHint !== null && signatureMethodTypeHint !== undefined) {
            queryParameters['signatureMethod@TypeHint'] = <string><any>signatureMethodTypeHint;
        }
        if (userIntermediatePath !== null && userIntermediatePath !== undefined) {
            queryParameters['userIntermediatePath'] = <string><any>userIntermediatePath;
        }
        if (userIntermediatePathTypeHint !== null && userIntermediatePathTypeHint !== undefined) {
            queryParameters['userIntermediatePath@TypeHint'] = <string><any>userIntermediatePathTypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNioTypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystoreTypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePasswordTypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKeyTypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPasswordTypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststoreTypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePasswordTypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificateTypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnableTypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecureTypeHint 
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.felix.http';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (orgApacheFelixHttpsNio !== null && orgApacheFelixHttpsNio !== undefined) {
            queryParameters['org.apache.felix.https.nio'] = <string><any>orgApacheFelixHttpsNio;
        }
        if (orgApacheFelixHttpsNioTypeHint !== null && orgApacheFelixHttpsNioTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.nio@TypeHint'] = <string><any>orgApacheFelixHttpsNioTypeHint;
        }
        if (orgApacheFelixHttpsKeystore !== null && orgApacheFelixHttpsKeystore !== undefined) {
            queryParameters['org.apache.felix.https.keystore'] = <string><any>orgApacheFelixHttpsKeystore;
        }
        if (orgApacheFelixHttpsKeystoreTypeHint !== null && orgApacheFelixHttpsKeystoreTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore@TypeHint'] = <string><any>orgApacheFelixHttpsKeystoreTypeHint;
        }
        if (orgApacheFelixHttpsKeystorePassword !== null && orgApacheFelixHttpsKeystorePassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password'] = <string><any>orgApacheFelixHttpsKeystorePassword;
        }
        if (orgApacheFelixHttpsKeystorePasswordTypeHint !== null && orgApacheFelixHttpsKeystorePasswordTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password@TypeHint'] = <string><any>orgApacheFelixHttpsKeystorePasswordTypeHint;
        }
        if (orgApacheFelixHttpsKeystoreKey !== null && orgApacheFelixHttpsKeystoreKey !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key'] = <string><any>orgApacheFelixHttpsKeystoreKey;
        }
        if (orgApacheFelixHttpsKeystoreKeyTypeHint !== null && orgApacheFelixHttpsKeystoreKeyTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key@TypeHint'] = <string><any>orgApacheFelixHttpsKeystoreKeyTypeHint;
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword !== null && orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password'] = <string><any>orgApacheFelixHttpsKeystoreKeyPassword;
        }
        if (orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== null && orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password@TypeHint'] = <string><any>orgApacheFelixHttpsKeystoreKeyPasswordTypeHint;
        }
        if (orgApacheFelixHttpsTruststore !== null && orgApacheFelixHttpsTruststore !== undefined) {
            queryParameters['org.apache.felix.https.truststore'] = <string><any>orgApacheFelixHttpsTruststore;
        }
        if (orgApacheFelixHttpsTruststoreTypeHint !== null && orgApacheFelixHttpsTruststoreTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore@TypeHint'] = <string><any>orgApacheFelixHttpsTruststoreTypeHint;
        }
        if (orgApacheFelixHttpsTruststorePassword !== null && orgApacheFelixHttpsTruststorePassword !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password'] = <string><any>orgApacheFelixHttpsTruststorePassword;
        }
        if (orgApacheFelixHttpsTruststorePasswordTypeHint !== null && orgApacheFelixHttpsTruststorePasswordTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password@TypeHint'] = <string><any>orgApacheFelixHttpsTruststorePasswordTypeHint;
        }
        if (orgApacheFelixHttpsClientcertificate !== null && orgApacheFelixHttpsClientcertificate !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate'] = <string><any>orgApacheFelixHttpsClientcertificate;
        }
        if (orgApacheFelixHttpsClientcertificateTypeHint !== null && orgApacheFelixHttpsClientcertificateTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate@TypeHint'] = <string><any>orgApacheFelixHttpsClientcertificateTypeHint;
        }
        if (orgApacheFelixHttpsEnable !== null && orgApacheFelixHttpsEnable !== undefined) {
            queryParameters['org.apache.felix.https.enable'] = <string><any>orgApacheFelixHttpsEnable;
        }
        if (orgApacheFelixHttpsEnableTypeHint !== null && orgApacheFelixHttpsEnableTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.enable@TypeHint'] = <string><any>orgApacheFelixHttpsEnableTypeHint;
        }
        if (orgOsgiServiceHttpPortSecure !== null && orgOsgiServiceHttpPortSecure !== undefined) {
            queryParameters['org.osgi.service.http.port.secure'] = <string><any>orgOsgiServiceHttpPortSecure;
        }
        if (orgOsgiServiceHttpPortSecureTypeHint !== null && orgOsgiServiceHttpPortSecureTypeHint !== undefined) {
            queryParameters['org.osgi.service.http.port.secure@TypeHint'] = <string><any>orgOsgiServiceHttpPortSecureTypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param proxyHost 
     * @param proxyHostTypeHint 
     * @param proxyPort 
     * @param proxyPortTypeHint 
     * @param proxyExceptions 
     * @param proxyExceptionsTypeHint 
     * @param proxyEnabled 
     * @param proxyEnabledTypeHint 
     * @param proxyUser 
     * @param proxyUserTypeHint 
     * @param proxyPassword 
     * @param proxyPasswordTypeHint 
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.http.proxyconfigurator.config';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (proxyHost !== null && proxyHost !== undefined) {
            queryParameters['proxy.host'] = <string><any>proxyHost;
        }
        if (proxyHostTypeHint !== null && proxyHostTypeHint !== undefined) {
            queryParameters['proxy.host@TypeHint'] = <string><any>proxyHostTypeHint;
        }
        if (proxyPort !== null && proxyPort !== undefined) {
            queryParameters['proxy.port'] = <string><any>proxyPort;
        }
        if (proxyPortTypeHint !== null && proxyPortTypeHint !== undefined) {
            queryParameters['proxy.port@TypeHint'] = <string><any>proxyPortTypeHint;
        }
        if (proxyExceptions) {
            queryParameters['proxy.exceptions'] = [];
            proxyExceptions.forEach((element: any) => {
                queryParameters['proxy.exceptions'].push(element);
            });
        }
        if (proxyExceptionsTypeHint !== null && proxyExceptionsTypeHint !== undefined) {
            queryParameters['proxy.exceptions@TypeHint'] = <string><any>proxyExceptionsTypeHint;
        }
        if (proxyEnabled !== null && proxyEnabled !== undefined) {
            queryParameters['proxy.enabled'] = <string><any>proxyEnabled;
        }
        if (proxyEnabledTypeHint !== null && proxyEnabledTypeHint !== undefined) {
            queryParameters['proxy.enabled@TypeHint'] = <string><any>proxyEnabledTypeHint;
        }
        if (proxyUser !== null && proxyUser !== undefined) {
            queryParameters['proxy.user'] = <string><any>proxyUser;
        }
        if (proxyUserTypeHint !== null && proxyUserTypeHint !== undefined) {
            queryParameters['proxy.user@TypeHint'] = <string><any>proxyUserTypeHint;
        }
        if (proxyPassword !== null && proxyPassword !== undefined) {
            queryParameters['proxy.password'] = <string><any>proxyPassword;
        }
        if (proxyPasswordTypeHint !== null && proxyPasswordTypeHint !== undefined) {
            queryParameters['proxy.password@TypeHint'] = <string><any>proxyPasswordTypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param alias 
     * @param aliasTypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUriTypeHint 
     */
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (alias !== null && alias !== undefined) {
            queryParameters['alias'] = <string><any>alias;
        }
        if (aliasTypeHint !== null && aliasTypeHint !== undefined) {
            queryParameters['alias@TypeHint'] = <string><any>aliasTypeHint;
        }
        if (davCreateAbsoluteUri !== null && davCreateAbsoluteUri !== undefined) {
            queryParameters['dav.create-absolute-uri'] = <string><any>davCreateAbsoluteUri;
        }
        if (davCreateAbsoluteUriTypeHint !== null && davCreateAbsoluteUriTypeHint !== undefined) {
            queryParameters['dav.create-absolute-uri@TypeHint'] = <string><any>davCreateAbsoluteUriTypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresultsTypeHint 
     * @param enableHtml 
     * @param enableHtmlTypeHint 
     * @param enableTxt 
     * @param enableTxtTypeHint 
     * @param enableXml 
     * @param enableXmlTypeHint 
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (jsonMaximumresults !== null && jsonMaximumresults !== undefined) {
            queryParameters['json.maximumresults'] = <string><any>jsonMaximumresults;
        }
        if (jsonMaximumresultsTypeHint !== null && jsonMaximumresultsTypeHint !== undefined) {
            queryParameters['json.maximumresults@TypeHint'] = <string><any>jsonMaximumresultsTypeHint;
        }
        if (enableHtml !== null && enableHtml !== undefined) {
            queryParameters['enable.html'] = <string><any>enableHtml;
        }
        if (enableHtmlTypeHint !== null && enableHtmlTypeHint !== undefined) {
            queryParameters['enable.html@TypeHint'] = <string><any>enableHtmlTypeHint;
        }
        if (enableTxt !== null && enableTxt !== undefined) {
            queryParameters['enable.txt'] = <string><any>enableTxt;
        }
        if (enableTxtTypeHint !== null && enableTxtTypeHint !== undefined) {
            queryParameters['enable.txt@TypeHint'] = <string><any>enableTxtTypeHint;
        }
        if (enableXml !== null && enableXml !== undefined) {
            queryParameters['enable.xml'] = <string><any>enableXml;
        }
        if (enableXmlTypeHint !== null && enableXmlTypeHint !== undefined) {
            queryParameters['enable.xml@TypeHint'] = <string><any>enableXmlTypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param allowEmpty 
     * @param allowEmptyTypeHint 
     * @param allowHosts 
     * @param allowHostsTypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexpTypeHint 
     * @param filterMethods 
     * @param filterMethodsTypeHint 
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (allowEmpty !== null && allowEmpty !== undefined) {
            queryParameters['allow.empty'] = <string><any>allowEmpty;
        }
        if (allowEmptyTypeHint !== null && allowEmptyTypeHint !== undefined) {
            queryParameters['allow.empty@TypeHint'] = <string><any>allowEmptyTypeHint;
        }
        if (allowHosts !== null && allowHosts !== undefined) {
            queryParameters['allow.hosts'] = <string><any>allowHosts;
        }
        if (allowHostsTypeHint !== null && allowHostsTypeHint !== undefined) {
            queryParameters['allow.hosts@TypeHint'] = <string><any>allowHostsTypeHint;
        }
        if (allowHostsRegexp !== null && allowHostsRegexp !== undefined) {
            queryParameters['allow.hosts.regexp'] = <string><any>allowHostsRegexp;
        }
        if (allowHostsRegexpTypeHint !== null && allowHostsRegexpTypeHint !== undefined) {
            queryParameters['allow.hosts.regexp@TypeHint'] = <string><any>allowHostsRegexpTypeHint;
        }
        if (filterMethods !== null && filterMethods !== undefined) {
            queryParameters['filter.methods'] = <string><any>filterMethods;
        }
        if (filterMethodsTypeHint !== null && filterMethodsTypeHint !== undefined) {
            queryParameters['filter.methods@TypeHint'] = <string><any>filterMethodsTypeHint;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param configNodeName 
     */
    public postConfigProperty(configNodeName: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/apps/system/config/{configNodeName}'.replace('{' + 'configNodeName' + '}', encodeURIComponent(String(configNodeName)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'configNodeName' is not null or undefined
        if (configNodeName === null || configNodeName === undefined) {
            throw new Error('Required parameter configNodeName was null or undefined when calling postConfigProperty.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     * @param operation 
     * @param deleteAuthorizable 
     * @param file 
     */
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        if (operation !== null && operation !== undefined) {
            queryParameters[':operation'] = <string><any>operation;
        }
        if (deleteAuthorizable !== null && deleteAuthorizable !== undefined) {
            queryParameters['deleteAuthorizable'] = <string><any>deleteAuthorizable;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("file", file);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     */
    public postNodeRw(path: string, name: string, addMembers?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/{name}.rw.html'.replace('{' + 'path' + '}', encodeURIComponent(String(path))).replace('{' + 'name' + '}', encodeURIComponent(String(name)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        if (addMembers !== null && addMembers !== undefined) {
            queryParameters['addMembers'] = <string><any>addMembers;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param jcrprimaryType 
     * @param name 
     */
    public postPath(path: string, jcrprimaryType: string, name: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/{path}/'.replace('{' + 'path' + '}', encodeURIComponent(String(path)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        // verify required parameter 'jcrprimaryType' is not null or undefined
        if (jcrprimaryType === null || jcrprimaryType === undefined) {
            throw new Error('Required parameter jcrprimaryType was null or undefined when calling postPath.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postPath.');
        }

        if (jcrprimaryType !== null && jcrprimaryType !== undefined) {
            queryParameters['jcr:primaryType'] = <string><any>jcrprimaryType;
        }
        if (name !== null && name !== undefined) {
            queryParameters[':name'] = <string><any>name;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/bin/querybuilder.json';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        if (path !== null && path !== undefined) {
            queryParameters['path'] = <string><any>path;
        }
        if (pLimit !== null && pLimit !== undefined) {
            queryParameters['p.limit'] = <string><any>pLimit;
        }
        if (_1property !== null && _1property !== undefined) {
            queryParameters['1_property'] = <string><any>_1property;
        }
        if (_1propertyValue !== null && _1propertyValue !== undefined) {
            queryParameters['1_property.value'] = <string><any>_1propertyValue;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body?: any;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/replication/treeactivation.html';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'ignoredeactivated' is not null or undefined
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'onlymodified' is not null or undefined
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        if (ignoredeactivated !== null && ignoredeactivated !== undefined) {
            queryParameters['ignoredeactivated'] = <string><any>ignoredeactivated;
        }
        if (onlymodified !== null && onlymodified !== undefined) {
            queryParameters['onlymodified'] = <string><any>onlymodified;
        }
        if (path !== null && path !== undefined) {
            queryParameters['path'] = <string><any>path;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body?: any;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: any, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     */
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/libs/granite/security/post/truststore';

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;

        if (operation !== null && operation !== undefined) {
            queryParameters[':operation'] = <string><any>operation;
        }
        if (newPassword !== null && newPassword !== undefined) {
            queryParameters['newPassword'] = <string><any>newPassword;
        }
        if (rePassword !== null && rePassword !== undefined) {
            queryParameters['rePassword'] = <string><any>rePassword;
        }
        if (keyStoreType !== null && keyStoreType !== undefined) {
            queryParameters['keyStoreType'] = <string><any>keyStoreType;
        }
        if (removeAlias !== null && removeAlias !== undefined) {
            queryParameters['removeAlias'] = <string><any>removeAlias;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("certificate", certificate);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @param truststoreP12 
     */
    public postTruststorePKCS12(truststoreP12?: any, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: string;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/etc/truststore';

        let queryParameters: any = {};
        let headerParams: any = {};
        let formParams = new FormData();
        let reqHasFile = false;


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        reqHasFile = true;
        formParams.append("truststore.p12", truststoreP12);
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];

        // authentication (aemAuth) required
        // http basic authentication required
        if (this.configuration.username || this.configuration.password) {
            headerParams['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        if (!reqHasFile) {
            headerParams['Content-Type'] = 'application/x-www-form-urlencoded';
        }


        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }
        requestOptions.data = formParams;
        if (reqHasFile) {
            requestOptions.contentType = false;
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: string;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: string, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
