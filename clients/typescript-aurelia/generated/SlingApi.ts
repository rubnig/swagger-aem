/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { autoinject } from 'aurelia-framework';
import { HttpClient } from 'aurelia-http-client';
import { Api } from './Api';
import { AuthStorage } from './AuthStorage';
import {
  KeystoreInfo,
  TruststoreInfo,
} from './models';

/**
 * deleteAgent - parameters interface
 */
export interface IDeleteAgentParams {
  runmode: string;
  name: string;
}

/**
 * deleteNode - parameters interface
 */
export interface IDeleteNodeParams {
  path: string;
  name: string;
}

/**
 * getAgent - parameters interface
 */
export interface IGetAgentParams {
  runmode: string;
  name: string;
}

/**
 * getAgents - parameters interface
 */
export interface IGetAgentsParams {
  runmode: string;
}

/**
 * getAuthorizableKeystore - parameters interface
 */
export interface IGetAuthorizableKeystoreParams {
  intermediatePath: string;
  authorizableId: string;
}

/**
 * getKeystore - parameters interface
 */
export interface IGetKeystoreParams {
  intermediatePath: string;
  authorizableId: string;
}

/**
 * getNode - parameters interface
 */
export interface IGetNodeParams {
  path: string;
  name: string;
}

/**
 * getPackage - parameters interface
 */
export interface IGetPackageParams {
  group: string;
  name: string;
  version: string;
}

/**
 * getPackageFilter - parameters interface
 */
export interface IGetPackageFilterParams {
  group: string;
  name: string;
  version: string;
}

/**
 * getQuery - parameters interface
 */
export interface IGetQueryParams {
  path: string;
  pLimit: number;
  _1property: string;
  _1propertyValue: string;
}

/**
 * getTruststore - parameters interface
 */
export interface IGetTruststoreParams {
}

/**
 * getTruststoreInfo - parameters interface
 */
export interface IGetTruststoreInfoParams {
}

/**
 * postAgent - parameters interface
 */
export interface IPostAgentParams {
  runmode: string;
  name: string;
  jcrcontentCqdistribute?: boolean;
  jcrcontentCqdistributeTypeHint?: string;
  jcrcontentCqname?: string;
  jcrcontentCqtemplate?: string;
  jcrcontentEnabled?: boolean;
  jcrcontentJcrdescription?: string;
  jcrcontentJcrlastModified?: string;
  jcrcontentJcrlastModifiedBy?: string;
  jcrcontentJcrmixinTypes?: string;
  jcrcontentJcrtitle?: string;
  jcrcontentLogLevel?: string;
  jcrcontentNoStatusUpdate?: boolean;
  jcrcontentNoVersioning?: boolean;
  jcrcontentProtocolConnectTimeout?: number;
  jcrcontentProtocolHTTPConnectionClosed?: boolean;
  jcrcontentProtocolHTTPExpired?: string;
  jcrcontentProtocolHTTPHeaders?: Array<string>;
  jcrcontentProtocolHTTPHeadersTypeHint?: string;
  jcrcontentProtocolHTTPMethod?: string;
  jcrcontentProtocolHTTPSRelaxed?: boolean;
  jcrcontentProtocolInterface?: string;
  jcrcontentProtocolSocketTimeout?: number;
  jcrcontentProtocolVersion?: string;
  jcrcontentProxyNTLMDomain?: string;
  jcrcontentProxyNTLMHost?: string;
  jcrcontentProxyHost?: string;
  jcrcontentProxyPassword?: string;
  jcrcontentProxyPort?: number;
  jcrcontentProxyUser?: string;
  jcrcontentQueueBatchMaxSize?: number;
  jcrcontentQueueBatchMode?: string;
  jcrcontentQueueBatchWaitTime?: number;
  jcrcontentRetryDelay?: string;
  jcrcontentReverseReplication?: boolean;
  jcrcontentSerializationType?: string;
  jcrcontentSlingresourceType?: string;
  jcrcontentSsl?: string;
  jcrcontentTransportNTLMDomain?: string;
  jcrcontentTransportNTLMHost?: string;
  jcrcontentTransportPassword?: string;
  jcrcontentTransportUri?: string;
  jcrcontentTransportUser?: string;
  jcrcontentTriggerDistribute?: boolean;
  jcrcontentTriggerModified?: boolean;
  jcrcontentTriggerOnOffTime?: boolean;
  jcrcontentTriggerReceive?: boolean;
  jcrcontentTriggerSpecific?: boolean;
  jcrcontentUserId?: string;
  jcrprimaryType?: string;
  operation?: string;
}

/**
 * postAuthorizableKeystore - parameters interface
 */
export interface IPostAuthorizableKeystoreParams {
  intermediatePath: string;
  authorizableId: string;
  operation?: string;
  currentPassword?: string;
  newPassword?: string;
  rePassword?: string;
  keyPassword?: string;
  keyStorePass?: string;
  alias?: string;
  newAlias?: string;
  removeAlias?: string;
  certChain?: any;
  pk?: any;
  keyStore?: any;
}

/**
 * postAuthorizables - parameters interface
 */
export interface IPostAuthorizablesParams {
  authorizableId: string;
  intermediatePath: string;
  createUser?: string;
  createGroup?: string;
  reppassword?: string;
  profileGivenName?: string;
}

/**
 * postConfigAdobeGraniteSamlAuthenticationHandler - parameters interface
 */
export interface IPostConfigAdobeGraniteSamlAuthenticationHandlerParams {
  keyStorePassword?: string;
  keyStorePasswordTypeHint?: string;
  serviceRanking?: number;
  serviceRankingTypeHint?: string;
  idpHttpRedirect?: boolean;
  idpHttpRedirectTypeHint?: string;
  createUser?: boolean;
  createUserTypeHint?: string;
  defaultRedirectUrl?: string;
  defaultRedirectUrlTypeHint?: string;
  userIDAttribute?: string;
  userIDAttributeTypeHint?: string;
  defaultGroups?: Array<string>;
  defaultGroupsTypeHint?: string;
  idpCertAlias?: string;
  idpCertAliasTypeHint?: string;
  addGroupMemberships?: boolean;
  addGroupMembershipsTypeHint?: string;
  path?: Array<string>;
  pathTypeHint?: string;
  synchronizeAttributes?: Array<string>;
  synchronizeAttributesTypeHint?: string;
  clockTolerance?: number;
  clockToleranceTypeHint?: string;
  groupMembershipAttribute?: string;
  groupMembershipAttributeTypeHint?: string;
  idpUrl?: string;
  idpUrlTypeHint?: string;
  logoutUrl?: string;
  logoutUrlTypeHint?: string;
  serviceProviderEntityId?: string;
  serviceProviderEntityIdTypeHint?: string;
  assertionConsumerServiceURL?: string;
  assertionConsumerServiceURLTypeHint?: string;
  handleLogout?: boolean;
  handleLogoutTypeHint?: string;
  spPrivateKeyAlias?: string;
  spPrivateKeyAliasTypeHint?: string;
  useEncryption?: boolean;
  useEncryptionTypeHint?: string;
  nameIdFormat?: string;
  nameIdFormatTypeHint?: string;
  digestMethod?: string;
  digestMethodTypeHint?: string;
  signatureMethod?: string;
  signatureMethodTypeHint?: string;
  userIntermediatePath?: string;
  userIntermediatePathTypeHint?: string;
}

/**
 * postConfigApacheFelixJettyBasedHttpService - parameters interface
 */
export interface IPostConfigApacheFelixJettyBasedHttpServiceParams {
  orgApacheFelixHttpsNio?: boolean;
  orgApacheFelixHttpsNioTypeHint?: string;
  orgApacheFelixHttpsKeystore?: string;
  orgApacheFelixHttpsKeystoreTypeHint?: string;
  orgApacheFelixHttpsKeystorePassword?: string;
  orgApacheFelixHttpsKeystorePasswordTypeHint?: string;
  orgApacheFelixHttpsKeystoreKey?: string;
  orgApacheFelixHttpsKeystoreKeyTypeHint?: string;
  orgApacheFelixHttpsKeystoreKeyPassword?: string;
  orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string;
  orgApacheFelixHttpsTruststore?: string;
  orgApacheFelixHttpsTruststoreTypeHint?: string;
  orgApacheFelixHttpsTruststorePassword?: string;
  orgApacheFelixHttpsTruststorePasswordTypeHint?: string;
  orgApacheFelixHttpsClientcertificate?: string;
  orgApacheFelixHttpsClientcertificateTypeHint?: string;
  orgApacheFelixHttpsEnable?: boolean;
  orgApacheFelixHttpsEnableTypeHint?: string;
  orgOsgiServiceHttpPortSecure?: string;
  orgOsgiServiceHttpPortSecureTypeHint?: string;
}

/**
 * postConfigApacheHttpComponentsProxyConfiguration - parameters interface
 */
export interface IPostConfigApacheHttpComponentsProxyConfigurationParams {
  proxyHost?: string;
  proxyHostTypeHint?: string;
  proxyPort?: number;
  proxyPortTypeHint?: string;
  proxyExceptions?: Array<string>;
  proxyExceptionsTypeHint?: string;
  proxyEnabled?: boolean;
  proxyEnabledTypeHint?: string;
  proxyUser?: string;
  proxyUserTypeHint?: string;
  proxyPassword?: string;
  proxyPasswordTypeHint?: string;
}

/**
 * postConfigApacheSlingDavExServlet - parameters interface
 */
export interface IPostConfigApacheSlingDavExServletParams {
  alias?: string;
  aliasTypeHint?: string;
  davCreateAbsoluteUri?: boolean;
  davCreateAbsoluteUriTypeHint?: string;
}

/**
 * postConfigApacheSlingGetServlet - parameters interface
 */
export interface IPostConfigApacheSlingGetServletParams {
  jsonMaximumresults?: string;
  jsonMaximumresultsTypeHint?: string;
  enableHtml?: boolean;
  enableHtmlTypeHint?: string;
  enableTxt?: boolean;
  enableTxtTypeHint?: string;
  enableXml?: boolean;
  enableXmlTypeHint?: string;
}

/**
 * postConfigApacheSlingReferrerFilter - parameters interface
 */
export interface IPostConfigApacheSlingReferrerFilterParams {
  allowEmpty?: boolean;
  allowEmptyTypeHint?: string;
  allowHosts?: string;
  allowHostsTypeHint?: string;
  allowHostsRegexp?: string;
  allowHostsRegexpTypeHint?: string;
  filterMethods?: string;
  filterMethodsTypeHint?: string;
}

/**
 * postConfigProperty - parameters interface
 */
export interface IPostConfigPropertyParams {
  configNodeName: string;
}

/**
 * postNode - parameters interface
 */
export interface IPostNodeParams {
  path: string;
  name: string;
  operation?: string;
  deleteAuthorizable?: string;
  file?: any;
}

/**
 * postNodeRw - parameters interface
 */
export interface IPostNodeRwParams {
  path: string;
  name: string;
  addMembers?: string;
}

/**
 * postPath - parameters interface
 */
export interface IPostPathParams {
  path: string;
  jcrprimaryType: string;
  name: string;
}

/**
 * postQuery - parameters interface
 */
export interface IPostQueryParams {
  path: string;
  pLimit: number;
  _1property: string;
  _1propertyValue: string;
}

/**
 * postTreeActivation - parameters interface
 */
export interface IPostTreeActivationParams {
  ignoredeactivated: boolean;
  onlymodified: boolean;
  path: string;
}

/**
 * postTruststore - parameters interface
 */
export interface IPostTruststoreParams {
  operation?: string;
  newPassword?: string;
  rePassword?: string;
  keyStoreType?: string;
  removeAlias?: string;
  certificate?: any;
}

/**
 * postTruststorePKCS12 - parameters interface
 */
export interface IPostTruststorePKCS12Params {
  truststoreP12?: any;
}

/**
 * SlingApi - API class
 */
@autoinject()
export class SlingApi extends Api {

  /**
   * Creates a new SlingApi class.
   *
   * @param httpClient The Aurelia HTTP client to be injected.
   * @param authStorage A storage for authentication data.
   */
  constructor(httpClient: HttpClient, authStorage: AuthStorage) {
    super(httpClient, authStorage);
  }

  /**
   * @param params.runmode 
   * @param params.name 
   */
  async deleteAgent(params: IDeleteAgentParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('deleteAgent', params, 'runmode');
    this.ensureParamIsSet('deleteAgent', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}/{name}`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asDelete()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   */
  async deleteNode(params: IDeleteNodeParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('deleteNode', params, 'path');
    this.ensureParamIsSet('deleteNode', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asDelete()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.runmode 
   * @param params.name 
   */
  async getAgent(params: IGetAgentParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getAgent', params, 'runmode');
    this.ensureParamIsSet('getAgent', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}/{name}`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.runmode 
   */
  async getAgents(params: IGetAgentsParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('getAgents', params, 'runmode');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}.-1.json`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.intermediatePath 
   * @param params.authorizableId 
   */
  async getAuthorizableKeystore(params: IGetAuthorizableKeystoreParams): Promise<KeystoreInfo> {
    // Verify required parameters are set
    this.ensureParamIsSet('getAuthorizableKeystore', params, 'intermediatePath');
    this.ensureParamIsSet('getAuthorizableKeystore', params, 'authorizableId');

    // Create URL to call
    const url = `${this.basePath}/{intermediatePath}/{authorizableId}.ks.json`
      .replace(`{${'intermediatePath'}}`, encodeURIComponent(`${params['intermediatePath']}`))
      .replace(`{${'authorizableId'}}`, encodeURIComponent(`${params['authorizableId']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.intermediatePath 
   * @param params.authorizableId 
   */
  async getKeystore(params: IGetKeystoreParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getKeystore', params, 'intermediatePath');
    this.ensureParamIsSet('getKeystore', params, 'authorizableId');

    // Create URL to call
    const url = `${this.basePath}/{intermediatePath}/{authorizableId}/keystore/store.p12`
      .replace(`{${'intermediatePath'}}`, encodeURIComponent(`${params['intermediatePath']}`))
      .replace(`{${'authorizableId'}}`, encodeURIComponent(`${params['authorizableId']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   */
  async getNode(params: IGetNodeParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getNode', params, 'path');
    this.ensureParamIsSet('getNode', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.group 
   * @param params.name 
   * @param params.version 
   */
  async getPackage(params: IGetPackageParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('getPackage', params, 'group');
    this.ensureParamIsSet('getPackage', params, 'name');
    this.ensureParamIsSet('getPackage', params, 'version');

    // Create URL to call
    const url = `${this.basePath}/etc/packages/{group}/{name}-{version}.zip`
      .replace(`{${'group'}}`, encodeURIComponent(`${params['group']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`))
      .replace(`{${'version'}}`, encodeURIComponent(`${params['version']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.group 
   * @param params.name 
   * @param params.version 
   */
  async getPackageFilter(params: IGetPackageFilterParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('getPackageFilter', params, 'group');
    this.ensureParamIsSet('getPackageFilter', params, 'name');
    this.ensureParamIsSet('getPackageFilter', params, 'version');

    // Create URL to call
    const url = `${this.basePath}/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`
      .replace(`{${'group'}}`, encodeURIComponent(`${params['group']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`))
      .replace(`{${'version'}}`, encodeURIComponent(`${params['version']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.pLimit 
   * @param params._1property 
   * @param params._1propertyValue 
   */
  async getQuery(params: IGetQueryParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('getQuery', params, 'path');
    this.ensureParamIsSet('getQuery', params, 'pLimit');
    this.ensureParamIsSet('getQuery', params, '_1property');
    this.ensureParamIsSet('getQuery', params, '_1propertyValue');

    // Create URL to call
    const url = `${this.basePath}/bin/querybuilder.json`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'path': params['path'],
        'p.limit': params['pLimit'],
        '1_property': params['_1property'],
        '1_property.value': params['_1propertyValue'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   */
  async getTruststore(): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/etc/truststore/truststore.p12`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   */
  async getTruststoreInfo(): Promise<TruststoreInfo> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/libs/granite/security/truststore.json`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.runmode 
   * @param params.name 
   * @param params.jcrcontentCqdistribute 
   * @param params.jcrcontentCqdistributeTypeHint 
   * @param params.jcrcontentCqname 
   * @param params.jcrcontentCqtemplate 
   * @param params.jcrcontentEnabled 
   * @param params.jcrcontentJcrdescription 
   * @param params.jcrcontentJcrlastModified 
   * @param params.jcrcontentJcrlastModifiedBy 
   * @param params.jcrcontentJcrmixinTypes 
   * @param params.jcrcontentJcrtitle 
   * @param params.jcrcontentLogLevel 
   * @param params.jcrcontentNoStatusUpdate 
   * @param params.jcrcontentNoVersioning 
   * @param params.jcrcontentProtocolConnectTimeout 
   * @param params.jcrcontentProtocolHTTPConnectionClosed 
   * @param params.jcrcontentProtocolHTTPExpired 
   * @param params.jcrcontentProtocolHTTPHeaders 
   * @param params.jcrcontentProtocolHTTPHeadersTypeHint 
   * @param params.jcrcontentProtocolHTTPMethod 
   * @param params.jcrcontentProtocolHTTPSRelaxed 
   * @param params.jcrcontentProtocolInterface 
   * @param params.jcrcontentProtocolSocketTimeout 
   * @param params.jcrcontentProtocolVersion 
   * @param params.jcrcontentProxyNTLMDomain 
   * @param params.jcrcontentProxyNTLMHost 
   * @param params.jcrcontentProxyHost 
   * @param params.jcrcontentProxyPassword 
   * @param params.jcrcontentProxyPort 
   * @param params.jcrcontentProxyUser 
   * @param params.jcrcontentQueueBatchMaxSize 
   * @param params.jcrcontentQueueBatchMode 
   * @param params.jcrcontentQueueBatchWaitTime 
   * @param params.jcrcontentRetryDelay 
   * @param params.jcrcontentReverseReplication 
   * @param params.jcrcontentSerializationType 
   * @param params.jcrcontentSlingresourceType 
   * @param params.jcrcontentSsl 
   * @param params.jcrcontentTransportNTLMDomain 
   * @param params.jcrcontentTransportNTLMHost 
   * @param params.jcrcontentTransportPassword 
   * @param params.jcrcontentTransportUri 
   * @param params.jcrcontentTransportUser 
   * @param params.jcrcontentTriggerDistribute 
   * @param params.jcrcontentTriggerModified 
   * @param params.jcrcontentTriggerOnOffTime 
   * @param params.jcrcontentTriggerReceive 
   * @param params.jcrcontentTriggerSpecific 
   * @param params.jcrcontentUserId 
   * @param params.jcrprimaryType 
   * @param params.operation 
   */
  async postAgent(params: IPostAgentParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postAgent', params, 'runmode');
    this.ensureParamIsSet('postAgent', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/agents.{runmode}/{name}`
      .replace(`{${'runmode'}}`, encodeURIComponent(`${params['runmode']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'jcr:content/cq:distribute': params['jcrcontentCqdistribute'],
        'jcr:content/cq:distribute@TypeHint': params['jcrcontentCqdistributeTypeHint'],
        'jcr:content/cq:name': params['jcrcontentCqname'],
        'jcr:content/cq:template': params['jcrcontentCqtemplate'],
        'jcr:content/enabled': params['jcrcontentEnabled'],
        'jcr:content/jcr:description': params['jcrcontentJcrdescription'],
        'jcr:content/jcr:lastModified': params['jcrcontentJcrlastModified'],
        'jcr:content/jcr:lastModifiedBy': params['jcrcontentJcrlastModifiedBy'],
        'jcr:content/jcr:mixinTypes': params['jcrcontentJcrmixinTypes'],
        'jcr:content/jcr:title': params['jcrcontentJcrtitle'],
        'jcr:content/logLevel': params['jcrcontentLogLevel'],
        'jcr:content/noStatusUpdate': params['jcrcontentNoStatusUpdate'],
        'jcr:content/noVersioning': params['jcrcontentNoVersioning'],
        'jcr:content/protocolConnectTimeout': params['jcrcontentProtocolConnectTimeout'],
        'jcr:content/protocolHTTPConnectionClosed': params['jcrcontentProtocolHTTPConnectionClosed'],
        'jcr:content/protocolHTTPExpired': params['jcrcontentProtocolHTTPExpired'],
        'jcr:content/protocolHTTPHeaders': params['jcrcontentProtocolHTTPHeaders'],
        'jcr:content/protocolHTTPHeaders@TypeHint': params['jcrcontentProtocolHTTPHeadersTypeHint'],
        'jcr:content/protocolHTTPMethod': params['jcrcontentProtocolHTTPMethod'],
        'jcr:content/protocolHTTPSRelaxed': params['jcrcontentProtocolHTTPSRelaxed'],
        'jcr:content/protocolInterface': params['jcrcontentProtocolInterface'],
        'jcr:content/protocolSocketTimeout': params['jcrcontentProtocolSocketTimeout'],
        'jcr:content/protocolVersion': params['jcrcontentProtocolVersion'],
        'jcr:content/proxyNTLMDomain': params['jcrcontentProxyNTLMDomain'],
        'jcr:content/proxyNTLMHost': params['jcrcontentProxyNTLMHost'],
        'jcr:content/proxyHost': params['jcrcontentProxyHost'],
        'jcr:content/proxyPassword': params['jcrcontentProxyPassword'],
        'jcr:content/proxyPort': params['jcrcontentProxyPort'],
        'jcr:content/proxyUser': params['jcrcontentProxyUser'],
        'jcr:content/queueBatchMaxSize': params['jcrcontentQueueBatchMaxSize'],
        'jcr:content/queueBatchMode': params['jcrcontentQueueBatchMode'],
        'jcr:content/queueBatchWaitTime': params['jcrcontentQueueBatchWaitTime'],
        'jcr:content/retryDelay': params['jcrcontentRetryDelay'],
        'jcr:content/reverseReplication': params['jcrcontentReverseReplication'],
        'jcr:content/serializationType': params['jcrcontentSerializationType'],
        'jcr:content/sling:resourceType': params['jcrcontentSlingresourceType'],
        'jcr:content/ssl': params['jcrcontentSsl'],
        'jcr:content/transportNTLMDomain': params['jcrcontentTransportNTLMDomain'],
        'jcr:content/transportNTLMHost': params['jcrcontentTransportNTLMHost'],
        'jcr:content/transportPassword': params['jcrcontentTransportPassword'],
        'jcr:content/transportUri': params['jcrcontentTransportUri'],
        'jcr:content/transportUser': params['jcrcontentTransportUser'],
        'jcr:content/triggerDistribute': params['jcrcontentTriggerDistribute'],
        'jcr:content/triggerModified': params['jcrcontentTriggerModified'],
        'jcr:content/triggerOnOffTime': params['jcrcontentTriggerOnOffTime'],
        'jcr:content/triggerReceive': params['jcrcontentTriggerReceive'],
        'jcr:content/triggerSpecific': params['jcrcontentTriggerSpecific'],
        'jcr:content/userId': params['jcrcontentUserId'],
        'jcr:primaryType': params['jcrprimaryType'],
        ':operation': params['operation'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.intermediatePath 
   * @param params.authorizableId 
   * @param params.operation 
   * @param params.currentPassword 
   * @param params.newPassword 
   * @param params.rePassword 
   * @param params.keyPassword 
   * @param params.keyStorePass 
   * @param params.alias 
   * @param params.newAlias 
   * @param params.removeAlias 
   * @param params.certChain 
   * @param params.pk 
   * @param params.keyStore 
   */
  async postAuthorizableKeystore(params: IPostAuthorizableKeystoreParams): Promise<KeystoreInfo> {
    // Verify required parameters are set
    this.ensureParamIsSet('postAuthorizableKeystore', params, 'intermediatePath');
    this.ensureParamIsSet('postAuthorizableKeystore', params, 'authorizableId');

    // Create URL to call
    const url = `${this.basePath}/{intermediatePath}/{authorizableId}.ks.html`
      .replace(`{${'intermediatePath'}}`, encodeURIComponent(`${params['intermediatePath']}`))
      .replace(`{${'authorizableId'}}`, encodeURIComponent(`${params['authorizableId']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        ':operation': params['operation'],
        'currentPassword': params['currentPassword'],
        'newPassword': params['newPassword'],
        'rePassword': params['rePassword'],
        'keyPassword': params['keyPassword'],
        'keyStorePass': params['keyStorePass'],
        'alias': params['alias'],
        'newAlias': params['newAlias'],
        'removeAlias': params['removeAlias'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'cert-chain': params['certChain'],
        'pk': params['pk'],
        'keyStore': params['keyStore'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.authorizableId 
   * @param params.intermediatePath 
   * @param params.createUser 
   * @param params.createGroup 
   * @param params.reppassword 
   * @param params.profileGivenName 
   */
  async postAuthorizables(params: IPostAuthorizablesParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('postAuthorizables', params, 'authorizableId');
    this.ensureParamIsSet('postAuthorizables', params, 'intermediatePath');

    // Create URL to call
    const url = `${this.basePath}/libs/granite/security/post/authorizables`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'authorizableId': params['authorizableId'],
        'intermediatePath': params['intermediatePath'],
        'createUser': params['createUser'],
        'createGroup': params['createGroup'],
        'rep:password': params['reppassword'],
        'profile/givenName': params['profileGivenName'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.keyStorePassword 
   * @param params.keyStorePasswordTypeHint 
   * @param params.serviceRanking 
   * @param params.serviceRankingTypeHint 
   * @param params.idpHttpRedirect 
   * @param params.idpHttpRedirectTypeHint 
   * @param params.createUser 
   * @param params.createUserTypeHint 
   * @param params.defaultRedirectUrl 
   * @param params.defaultRedirectUrlTypeHint 
   * @param params.userIDAttribute 
   * @param params.userIDAttributeTypeHint 
   * @param params.defaultGroups 
   * @param params.defaultGroupsTypeHint 
   * @param params.idpCertAlias 
   * @param params.idpCertAliasTypeHint 
   * @param params.addGroupMemberships 
   * @param params.addGroupMembershipsTypeHint 
   * @param params.path 
   * @param params.pathTypeHint 
   * @param params.synchronizeAttributes 
   * @param params.synchronizeAttributesTypeHint 
   * @param params.clockTolerance 
   * @param params.clockToleranceTypeHint 
   * @param params.groupMembershipAttribute 
   * @param params.groupMembershipAttributeTypeHint 
   * @param params.idpUrl 
   * @param params.idpUrlTypeHint 
   * @param params.logoutUrl 
   * @param params.logoutUrlTypeHint 
   * @param params.serviceProviderEntityId 
   * @param params.serviceProviderEntityIdTypeHint 
   * @param params.assertionConsumerServiceURL 
   * @param params.assertionConsumerServiceURLTypeHint 
   * @param params.handleLogout 
   * @param params.handleLogoutTypeHint 
   * @param params.spPrivateKeyAlias 
   * @param params.spPrivateKeyAliasTypeHint 
   * @param params.useEncryption 
   * @param params.useEncryptionTypeHint 
   * @param params.nameIdFormat 
   * @param params.nameIdFormatTypeHint 
   * @param params.digestMethod 
   * @param params.digestMethodTypeHint 
   * @param params.signatureMethod 
   * @param params.signatureMethodTypeHint 
   * @param params.userIntermediatePath 
   * @param params.userIntermediatePathTypeHint 
   */
  async postConfigAdobeGraniteSamlAuthenticationHandler(params: IPostConfigAdobeGraniteSamlAuthenticationHandlerParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'keyStorePassword': params['keyStorePassword'],
        'keyStorePassword@TypeHint': params['keyStorePasswordTypeHint'],
        'service.ranking': params['serviceRanking'],
        'service.ranking@TypeHint': params['serviceRankingTypeHint'],
        'idpHttpRedirect': params['idpHttpRedirect'],
        'idpHttpRedirect@TypeHint': params['idpHttpRedirectTypeHint'],
        'createUser': params['createUser'],
        'createUser@TypeHint': params['createUserTypeHint'],
        'defaultRedirectUrl': params['defaultRedirectUrl'],
        'defaultRedirectUrl@TypeHint': params['defaultRedirectUrlTypeHint'],
        'userIDAttribute': params['userIDAttribute'],
        'userIDAttribute@TypeHint': params['userIDAttributeTypeHint'],
        'defaultGroups': params['defaultGroups'],
        'defaultGroups@TypeHint': params['defaultGroupsTypeHint'],
        'idpCertAlias': params['idpCertAlias'],
        'idpCertAlias@TypeHint': params['idpCertAliasTypeHint'],
        'addGroupMemberships': params['addGroupMemberships'],
        'addGroupMemberships@TypeHint': params['addGroupMembershipsTypeHint'],
        'path': params['path'],
        'path@TypeHint': params['pathTypeHint'],
        'synchronizeAttributes': params['synchronizeAttributes'],
        'synchronizeAttributes@TypeHint': params['synchronizeAttributesTypeHint'],
        'clockTolerance': params['clockTolerance'],
        'clockTolerance@TypeHint': params['clockToleranceTypeHint'],
        'groupMembershipAttribute': params['groupMembershipAttribute'],
        'groupMembershipAttribute@TypeHint': params['groupMembershipAttributeTypeHint'],
        'idpUrl': params['idpUrl'],
        'idpUrl@TypeHint': params['idpUrlTypeHint'],
        'logoutUrl': params['logoutUrl'],
        'logoutUrl@TypeHint': params['logoutUrlTypeHint'],
        'serviceProviderEntityId': params['serviceProviderEntityId'],
        'serviceProviderEntityId@TypeHint': params['serviceProviderEntityIdTypeHint'],
        'assertionConsumerServiceURL': params['assertionConsumerServiceURL'],
        'assertionConsumerServiceURL@TypeHint': params['assertionConsumerServiceURLTypeHint'],
        'handleLogout': params['handleLogout'],
        'handleLogout@TypeHint': params['handleLogoutTypeHint'],
        'spPrivateKeyAlias': params['spPrivateKeyAlias'],
        'spPrivateKeyAlias@TypeHint': params['spPrivateKeyAliasTypeHint'],
        'useEncryption': params['useEncryption'],
        'useEncryption@TypeHint': params['useEncryptionTypeHint'],
        'nameIdFormat': params['nameIdFormat'],
        'nameIdFormat@TypeHint': params['nameIdFormatTypeHint'],
        'digestMethod': params['digestMethod'],
        'digestMethod@TypeHint': params['digestMethodTypeHint'],
        'signatureMethod': params['signatureMethod'],
        'signatureMethod@TypeHint': params['signatureMethodTypeHint'],
        'userIntermediatePath': params['userIntermediatePath'],
        'userIntermediatePath@TypeHint': params['userIntermediatePathTypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.orgApacheFelixHttpsNio 
   * @param params.orgApacheFelixHttpsNioTypeHint 
   * @param params.orgApacheFelixHttpsKeystore 
   * @param params.orgApacheFelixHttpsKeystoreTypeHint 
   * @param params.orgApacheFelixHttpsKeystorePassword 
   * @param params.orgApacheFelixHttpsKeystorePasswordTypeHint 
   * @param params.orgApacheFelixHttpsKeystoreKey 
   * @param params.orgApacheFelixHttpsKeystoreKeyTypeHint 
   * @param params.orgApacheFelixHttpsKeystoreKeyPassword 
   * @param params.orgApacheFelixHttpsKeystoreKeyPasswordTypeHint 
   * @param params.orgApacheFelixHttpsTruststore 
   * @param params.orgApacheFelixHttpsTruststoreTypeHint 
   * @param params.orgApacheFelixHttpsTruststorePassword 
   * @param params.orgApacheFelixHttpsTruststorePasswordTypeHint 
   * @param params.orgApacheFelixHttpsClientcertificate 
   * @param params.orgApacheFelixHttpsClientcertificateTypeHint 
   * @param params.orgApacheFelixHttpsEnable 
   * @param params.orgApacheFelixHttpsEnableTypeHint 
   * @param params.orgOsgiServiceHttpPortSecure 
   * @param params.orgOsgiServiceHttpPortSecureTypeHint 
   */
  async postConfigApacheFelixJettyBasedHttpService(params: IPostConfigApacheFelixJettyBasedHttpServiceParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.felix.http`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'org.apache.felix.https.nio': params['orgApacheFelixHttpsNio'],
        'org.apache.felix.https.nio@TypeHint': params['orgApacheFelixHttpsNioTypeHint'],
        'org.apache.felix.https.keystore': params['orgApacheFelixHttpsKeystore'],
        'org.apache.felix.https.keystore@TypeHint': params['orgApacheFelixHttpsKeystoreTypeHint'],
        'org.apache.felix.https.keystore.password': params['orgApacheFelixHttpsKeystorePassword'],
        'org.apache.felix.https.keystore.password@TypeHint': params['orgApacheFelixHttpsKeystorePasswordTypeHint'],
        'org.apache.felix.https.keystore.key': params['orgApacheFelixHttpsKeystoreKey'],
        'org.apache.felix.https.keystore.key@TypeHint': params['orgApacheFelixHttpsKeystoreKeyTypeHint'],
        'org.apache.felix.https.keystore.key.password': params['orgApacheFelixHttpsKeystoreKeyPassword'],
        'org.apache.felix.https.keystore.key.password@TypeHint': params['orgApacheFelixHttpsKeystoreKeyPasswordTypeHint'],
        'org.apache.felix.https.truststore': params['orgApacheFelixHttpsTruststore'],
        'org.apache.felix.https.truststore@TypeHint': params['orgApacheFelixHttpsTruststoreTypeHint'],
        'org.apache.felix.https.truststore.password': params['orgApacheFelixHttpsTruststorePassword'],
        'org.apache.felix.https.truststore.password@TypeHint': params['orgApacheFelixHttpsTruststorePasswordTypeHint'],
        'org.apache.felix.https.clientcertificate': params['orgApacheFelixHttpsClientcertificate'],
        'org.apache.felix.https.clientcertificate@TypeHint': params['orgApacheFelixHttpsClientcertificateTypeHint'],
        'org.apache.felix.https.enable': params['orgApacheFelixHttpsEnable'],
        'org.apache.felix.https.enable@TypeHint': params['orgApacheFelixHttpsEnableTypeHint'],
        'org.osgi.service.http.port.secure': params['orgOsgiServiceHttpPortSecure'],
        'org.osgi.service.http.port.secure@TypeHint': params['orgOsgiServiceHttpPortSecureTypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.proxyHost 
   * @param params.proxyHostTypeHint 
   * @param params.proxyPort 
   * @param params.proxyPortTypeHint 
   * @param params.proxyExceptions 
   * @param params.proxyExceptionsTypeHint 
   * @param params.proxyEnabled 
   * @param params.proxyEnabledTypeHint 
   * @param params.proxyUser 
   * @param params.proxyUserTypeHint 
   * @param params.proxyPassword 
   * @param params.proxyPasswordTypeHint 
   */
  async postConfigApacheHttpComponentsProxyConfiguration(params: IPostConfigApacheHttpComponentsProxyConfigurationParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.http.proxyconfigurator.config`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'proxy.host': params['proxyHost'],
        'proxy.host@TypeHint': params['proxyHostTypeHint'],
        'proxy.port': params['proxyPort'],
        'proxy.port@TypeHint': params['proxyPortTypeHint'],
        'proxy.exceptions': params['proxyExceptions'],
        'proxy.exceptions@TypeHint': params['proxyExceptionsTypeHint'],
        'proxy.enabled': params['proxyEnabled'],
        'proxy.enabled@TypeHint': params['proxyEnabledTypeHint'],
        'proxy.user': params['proxyUser'],
        'proxy.user@TypeHint': params['proxyUserTypeHint'],
        'proxy.password': params['proxyPassword'],
        'proxy.password@TypeHint': params['proxyPasswordTypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.alias 
   * @param params.aliasTypeHint 
   * @param params.davCreateAbsoluteUri 
   * @param params.davCreateAbsoluteUriTypeHint 
   */
  async postConfigApacheSlingDavExServlet(params: IPostConfigApacheSlingDavExServletParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'alias': params['alias'],
        'alias@TypeHint': params['aliasTypeHint'],
        'dav.create-absolute-uri': params['davCreateAbsoluteUri'],
        'dav.create-absolute-uri@TypeHint': params['davCreateAbsoluteUriTypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.jsonMaximumresults 
   * @param params.jsonMaximumresultsTypeHint 
   * @param params.enableHtml 
   * @param params.enableHtmlTypeHint 
   * @param params.enableTxt 
   * @param params.enableTxtTypeHint 
   * @param params.enableXml 
   * @param params.enableXmlTypeHint 
   */
  async postConfigApacheSlingGetServlet(params: IPostConfigApacheSlingGetServletParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'json.maximumresults': params['jsonMaximumresults'],
        'json.maximumresults@TypeHint': params['jsonMaximumresultsTypeHint'],
        'enable.html': params['enableHtml'],
        'enable.html@TypeHint': params['enableHtmlTypeHint'],
        'enable.txt': params['enableTxt'],
        'enable.txt@TypeHint': params['enableTxtTypeHint'],
        'enable.xml': params['enableXml'],
        'enable.xml@TypeHint': params['enableXmlTypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.allowEmpty 
   * @param params.allowEmptyTypeHint 
   * @param params.allowHosts 
   * @param params.allowHostsTypeHint 
   * @param params.allowHostsRegexp 
   * @param params.allowHostsRegexpTypeHint 
   * @param params.filterMethods 
   * @param params.filterMethodsTypeHint 
   */
  async postConfigApacheSlingReferrerFilter(params: IPostConfigApacheSlingReferrerFilterParams): Promise<any> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'allow.empty': params['allowEmpty'],
        'allow.empty@TypeHint': params['allowEmptyTypeHint'],
        'allow.hosts': params['allowHosts'],
        'allow.hosts@TypeHint': params['allowHostsTypeHint'],
        'allow.hosts.regexp': params['allowHostsRegexp'],
        'allow.hosts.regexp@TypeHint': params['allowHostsRegexpTypeHint'],
        'filter.methods': params['filterMethods'],
        'filter.methods@TypeHint': params['filterMethodsTypeHint'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.configNodeName 
   */
  async postConfigProperty(params: IPostConfigPropertyParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postConfigProperty', params, 'configNodeName');

    // Create URL to call
    const url = `${this.basePath}/apps/system/config/{configNodeName}`
      .replace(`{${'configNodeName'}}`, encodeURIComponent(`${params['configNodeName']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   * @param params.operation 
   * @param params.deleteAuthorizable 
   * @param params.file 
   */
  async postNode(params: IPostNodeParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postNode', params, 'path');
    this.ensureParamIsSet('postNode', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        ':operation': params['operation'],
        'deleteAuthorizable': params['deleteAuthorizable'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'file': params['file'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.name 
   * @param params.addMembers 
   */
  async postNodeRw(params: IPostNodeRwParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postNodeRw', params, 'path');
    this.ensureParamIsSet('postNodeRw', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/{name}.rw.html`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`))
      .replace(`{${'name'}}`, encodeURIComponent(`${params['name']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'addMembers': params['addMembers'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.jcrprimaryType 
   * @param params.name 
   */
  async postPath(params: IPostPathParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postPath', params, 'path');
    this.ensureParamIsSet('postPath', params, 'jcrprimaryType');
    this.ensureParamIsSet('postPath', params, 'name');

    // Create URL to call
    const url = `${this.basePath}/{path}/`
      .replace(`{${'path'}}`, encodeURIComponent(`${params['path']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'jcr:primaryType': params['jcrprimaryType'],
        ':name': params['name'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.path 
   * @param params.pLimit 
   * @param params._1property 
   * @param params._1propertyValue 
   */
  async postQuery(params: IPostQueryParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('postQuery', params, 'path');
    this.ensureParamIsSet('postQuery', params, 'pLimit');
    this.ensureParamIsSet('postQuery', params, '_1property');
    this.ensureParamIsSet('postQuery', params, '_1propertyValue');

    // Create URL to call
    const url = `${this.basePath}/bin/querybuilder.json`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'path': params['path'],
        'p.limit': params['pLimit'],
        '1_property': params['_1property'],
        '1_property.value': params['_1propertyValue'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.ignoredeactivated 
   * @param params.onlymodified 
   * @param params.path 
   */
  async postTreeActivation(params: IPostTreeActivationParams): Promise<any> {
    // Verify required parameters are set
    this.ensureParamIsSet('postTreeActivation', params, 'ignoredeactivated');
    this.ensureParamIsSet('postTreeActivation', params, 'onlymodified');
    this.ensureParamIsSet('postTreeActivation', params, 'path');

    // Create URL to call
    const url = `${this.basePath}/etc/replication/treeactivation.html`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'ignoredeactivated': params['ignoredeactivated'],
        'onlymodified': params['onlymodified'],
        'path': params['path'],
      })

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.operation 
   * @param params.newPassword 
   * @param params.rePassword 
   * @param params.keyStoreType 
   * @param params.removeAlias 
   * @param params.certificate 
   */
  async postTruststore(params: IPostTruststoreParams): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/libs/granite/security/post/truststore`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        ':operation': params['operation'],
        'newPassword': params['newPassword'],
        'rePassword': params['rePassword'],
        'keyStoreType': params['keyStoreType'],
        'removeAlias': params['removeAlias'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'certificate': params['certificate'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.truststoreP12 
   */
  async postTruststorePKCS12(params: IPostTruststorePKCS12Params): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/etc/truststore`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'truststore.p12': params['truststoreP12'],
      }))

      // Authentication 'aemAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

}

