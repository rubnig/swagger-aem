--[[
  Adobe Experience Manager (AEM) API
 
  Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 
  The version of the OpenAPI document: 3.5.0-pre.0
  Contact: opensource@shinesolutions.com
  Generated by: https://openapi-generator.tech
]]

--package openapiclient

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local openapiclient_keystore_info = require "openapiclient.model.keystore_info"
local openapiclient_truststore_info = require "openapiclient.model.truststore_info"

local sling_api = {}
local sling_api_mt = {
	__name = "sling_api";
	__index = sling_api;
}

local function new_sling_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "http://localhost";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, sling_api_mt)
end

function sling_api:delete_agent(runmode, name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/replication/agents.{runmode}/%s",
			self.basePath, runmode, name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:delete_node(path, name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/%s",
			self.basePath, path, name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_agent(runmode, name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/replication/agents.{runmode}/%s",
			self.basePath, runmode, name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_agents(runmode)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/replication/agents.{runmode}.-1.json",
			self.basePath, runmode);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_authorizable_keystore(intermediate_path, authorizable_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/{authorizableId}.ks.json",
			self.basePath, intermediate_path, authorizable_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/plain" }
	req.headers:upsert("content-type", "text/plain")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_keystore_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_keystore(intermediate_path, authorizable_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/%s/keystore/store.p12",
			self.basePath, intermediate_path, authorizable_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/octet-stream" }
	req.headers:upsert("content-type", "application/octet-stream")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_node(path, name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/%s",
			self.basePath, path, name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_package(group, name, version)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/packages/%s/{name}-{version}.zip",
			self.basePath, group, name, version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/octet-stream" }
	req.headers:upsert("content-type", "application/octet-stream")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_package_filter(group, name, version)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/packages/%s/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json",
			self.basePath, group, name, version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_query(path, p_limit, Var1_property, Var1_property_value)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/bin/querybuilder.json?path=%s&p.limit=%s&1_property=%s&1_property.value=%s",
			self.basePath, http_util.encodeURIComponent(path), http_util.encodeURIComponent(p_limit), http_util.encodeURIComponent(Var1_property), http_util.encodeURIComponent(Var1_property_value));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_truststore()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/truststore/truststore.p12",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/octet-stream" }
	req.headers:upsert("content-type", "application/octet-stream")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:get_truststore_info()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/libs/granite/security/truststore.json",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_truststore_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_agent(runmode, name, jcrcontent_cqdistribute, jcrcontent_cqdistribute_type_hint, jcrcontent_cqname, jcrcontent_cqtemplate, jcrcontent_enabled, jcrcontent_jcrdescription, jcrcontent_jcrlast_modified, jcrcontent_jcrlast_modified_by, jcrcontent_jcrmixin_types, jcrcontent_jcrtitle, jcrcontent_log_level, jcrcontent_no_status_update, jcrcontent_no_versioning, jcrcontent_protocol_connect_timeout, jcrcontent_protocol_http_connection_closed, jcrcontent_protocol_http_expired, jcrcontent_protocol_http_headers, jcrcontent_protocol_http_headers_type_hint, jcrcontent_protocol_http_method, jcrcontent_protocol_https_relaxed, jcrcontent_protocol_interface, jcrcontent_protocol_socket_timeout, jcrcontent_protocol_version, jcrcontent_proxy_ntlm_domain, jcrcontent_proxy_ntlm_host, jcrcontent_proxy_host, jcrcontent_proxy_password, jcrcontent_proxy_port, jcrcontent_proxy_user, jcrcontent_queue_batch_max_size, jcrcontent_queue_batch_mode, jcrcontent_queue_batch_wait_time, jcrcontent_retry_delay, jcrcontent_reverse_replication, jcrcontent_serialization_type, jcrcontent_slingresource_type, jcrcontent_ssl, jcrcontent_transport_ntlm_domain, jcrcontent_transport_ntlm_host, jcrcontent_transport_password, jcrcontent_transport_uri, jcrcontent_transport_user, jcrcontent_trigger_distribute, jcrcontent_trigger_modified, jcrcontent_trigger_on_off_time, jcrcontent_trigger_receive, jcrcontent_trigger_specific, jcrcontent_user_id, jcrprimary_type, operation)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/replication/agents.{runmode}/%s?jcr:content/cq:distribute=%s&jcr:content/cq:distribute@TypeHint=%s&jcr:content/cq:name=%s&jcr:content/cq:template=%s&jcr:content/enabled=%s&jcr:content/jcr:description=%s&jcr:content/jcr:lastModified=%s&jcr:content/jcr:lastModifiedBy=%s&jcr:content/jcr:mixinTypes=%s&jcr:content/jcr:title=%s&jcr:content/logLevel=%s&jcr:content/noStatusUpdate=%s&jcr:content/noVersioning=%s&jcr:content/protocolConnectTimeout=%s&jcr:content/protocolHTTPConnectionClosed=%s&jcr:content/protocolHTTPExpired=%s&jcr:content/protocolHTTPHeaders=%s&jcr:content/protocolHTTPHeaders@TypeHint=%s&jcr:content/protocolHTTPMethod=%s&jcr:content/protocolHTTPSRelaxed=%s&jcr:content/protocolInterface=%s&jcr:content/protocolSocketTimeout=%s&jcr:content/protocolVersion=%s&jcr:content/proxyNTLMDomain=%s&jcr:content/proxyNTLMHost=%s&jcr:content/proxyHost=%s&jcr:content/proxyPassword=%s&jcr:content/proxyPort=%s&jcr:content/proxyUser=%s&jcr:content/queueBatchMaxSize=%s&jcr:content/queueBatchMode=%s&jcr:content/queueBatchWaitTime=%s&jcr:content/retryDelay=%s&jcr:content/reverseReplication=%s&jcr:content/serializationType=%s&jcr:content/sling:resourceType=%s&jcr:content/ssl=%s&jcr:content/transportNTLMDomain=%s&jcr:content/transportNTLMHost=%s&jcr:content/transportPassword=%s&jcr:content/transportUri=%s&jcr:content/transportUser=%s&jcr:content/triggerDistribute=%s&jcr:content/triggerModified=%s&jcr:content/triggerOnOffTime=%s&jcr:content/triggerReceive=%s&jcr:content/triggerSpecific=%s&jcr:content/userId=%s&jcr:primaryType=%s&:operation=%s",
			self.basePath, runmode, name, http_util.encodeURIComponent(jcrcontent_cqdistribute), http_util.encodeURIComponent(jcrcontent_cqdistribute_type_hint), http_util.encodeURIComponent(jcrcontent_cqname), http_util.encodeURIComponent(jcrcontent_cqtemplate), http_util.encodeURIComponent(jcrcontent_enabled), http_util.encodeURIComponent(jcrcontent_jcrdescription), http_util.encodeURIComponent(jcrcontent_jcrlast_modified), http_util.encodeURIComponent(jcrcontent_jcrlast_modified_by), http_util.encodeURIComponent(jcrcontent_jcrmixin_types), http_util.encodeURIComponent(jcrcontent_jcrtitle), http_util.encodeURIComponent(jcrcontent_log_level), http_util.encodeURIComponent(jcrcontent_no_status_update), http_util.encodeURIComponent(jcrcontent_no_versioning), http_util.encodeURIComponent(jcrcontent_protocol_connect_timeout), http_util.encodeURIComponent(jcrcontent_protocol_http_connection_closed), http_util.encodeURIComponent(jcrcontent_protocol_http_expired), http_util.encodeURIComponent(jcrcontent_protocol_http_headers), http_util.encodeURIComponent(jcrcontent_protocol_http_headers_type_hint), http_util.encodeURIComponent(jcrcontent_protocol_http_method), http_util.encodeURIComponent(jcrcontent_protocol_https_relaxed), http_util.encodeURIComponent(jcrcontent_protocol_interface), http_util.encodeURIComponent(jcrcontent_protocol_socket_timeout), http_util.encodeURIComponent(jcrcontent_protocol_version), http_util.encodeURIComponent(jcrcontent_proxy_ntlm_domain), http_util.encodeURIComponent(jcrcontent_proxy_ntlm_host), http_util.encodeURIComponent(jcrcontent_proxy_host), http_util.encodeURIComponent(jcrcontent_proxy_password), http_util.encodeURIComponent(jcrcontent_proxy_port), http_util.encodeURIComponent(jcrcontent_proxy_user), http_util.encodeURIComponent(jcrcontent_queue_batch_max_size), http_util.encodeURIComponent(jcrcontent_queue_batch_mode), http_util.encodeURIComponent(jcrcontent_queue_batch_wait_time), http_util.encodeURIComponent(jcrcontent_retry_delay), http_util.encodeURIComponent(jcrcontent_reverse_replication), http_util.encodeURIComponent(jcrcontent_serialization_type), http_util.encodeURIComponent(jcrcontent_slingresource_type), http_util.encodeURIComponent(jcrcontent_ssl), http_util.encodeURIComponent(jcrcontent_transport_ntlm_domain), http_util.encodeURIComponent(jcrcontent_transport_ntlm_host), http_util.encodeURIComponent(jcrcontent_transport_password), http_util.encodeURIComponent(jcrcontent_transport_uri), http_util.encodeURIComponent(jcrcontent_transport_user), http_util.encodeURIComponent(jcrcontent_trigger_distribute), http_util.encodeURIComponent(jcrcontent_trigger_modified), http_util.encodeURIComponent(jcrcontent_trigger_on_off_time), http_util.encodeURIComponent(jcrcontent_trigger_receive), http_util.encodeURIComponent(jcrcontent_trigger_specific), http_util.encodeURIComponent(jcrcontent_user_id), http_util.encodeURIComponent(jcrprimary_type), http_util.encodeURIComponent(operation));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_authorizable_keystore(intermediate_path, authorizable_id, operation, current_password, new_password, re_password, key_password, key_store_pass, alias, new_alias, remove_alias, cert_chain, pk, key_store)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/{authorizableId}.ks.html?:operation=%s&currentPassword=%s&newPassword=%s&rePassword=%s&keyPassword=%s&keyStorePass=%s&alias=%s&newAlias=%s&removeAlias=%s",
			self.basePath, intermediate_path, authorizable_id, http_util.encodeURIComponent(operation), http_util.encodeURIComponent(current_password), http_util.encodeURIComponent(new_password), http_util.encodeURIComponent(re_password), http_util.encodeURIComponent(key_password), http_util.encodeURIComponent(key_store_pass), http_util.encodeURIComponent(alias), http_util.encodeURIComponent(new_alias), http_util.encodeURIComponent(remove_alias));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/plain" }
	req.headers:upsert("content-type", "text/plain")

	req:set_body(http_util.dict_to_query({
		["cert-chain"] = cert_chain;
		["pk"] = pk;
		["keyStore"] = key_store;
	}))
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_keystore_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_authorizables(authorizable_id, intermediate_path, create_user, create_group, reppassword, profile_given_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/libs/granite/security/post/authorizables?authorizableId=%s&intermediatePath=%s&createUser=%s&createGroup=%s&rep:password=%s&profile/givenName=%s",
			self.basePath, http_util.encodeURIComponent(authorizable_id), http_util.encodeURIComponent(intermediate_path), http_util.encodeURIComponent(create_user), http_util.encodeURIComponent(create_group), http_util.encodeURIComponent(reppassword), http_util.encodeURIComponent(profile_given_name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_adobe_granite_saml_authentication_handler(key_store_password, key_store_password_type_hint, service_ranking, service_ranking_type_hint, idp_http_redirect, idp_http_redirect_type_hint, create_user, create_user_type_hint, default_redirect_url, default_redirect_url_type_hint, user_id_attribute, user_id_attribute_type_hint, default_groups, default_groups_type_hint, idp_cert_alias, idp_cert_alias_type_hint, add_group_memberships, add_group_memberships_type_hint, path, path_type_hint, synchronize_attributes, synchronize_attributes_type_hint, clock_tolerance, clock_tolerance_type_hint, group_membership_attribute, group_membership_attribute_type_hint, idp_url, idp_url_type_hint, logout_url, logout_url_type_hint, service_provider_entity_id, service_provider_entity_id_type_hint, assertion_consumer_service_url, assertion_consumer_service_url_type_hint, handle_logout, handle_logout_type_hint, sp_private_key_alias, sp_private_key_alias_type_hint, use_encryption, use_encryption_type_hint, name_id_format, name_id_format_type_hint, digest_method, digest_method_type_hint, signature_method, signature_method_type_hint, user_intermediate_path, user_intermediate_path_type_hint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config?keyStorePassword=%s&keyStorePassword@TypeHint=%s&service.ranking=%s&service.ranking@TypeHint=%s&idpHttpRedirect=%s&idpHttpRedirect@TypeHint=%s&createUser=%s&createUser@TypeHint=%s&defaultRedirectUrl=%s&defaultRedirectUrl@TypeHint=%s&userIDAttribute=%s&userIDAttribute@TypeHint=%s&defaultGroups=%s&defaultGroups@TypeHint=%s&idpCertAlias=%s&idpCertAlias@TypeHint=%s&addGroupMemberships=%s&addGroupMemberships@TypeHint=%s&path=%s&path@TypeHint=%s&synchronizeAttributes=%s&synchronizeAttributes@TypeHint=%s&clockTolerance=%s&clockTolerance@TypeHint=%s&groupMembershipAttribute=%s&groupMembershipAttribute@TypeHint=%s&idpUrl=%s&idpUrl@TypeHint=%s&logoutUrl=%s&logoutUrl@TypeHint=%s&serviceProviderEntityId=%s&serviceProviderEntityId@TypeHint=%s&assertionConsumerServiceURL=%s&assertionConsumerServiceURL@TypeHint=%s&handleLogout=%s&handleLogout@TypeHint=%s&spPrivateKeyAlias=%s&spPrivateKeyAlias@TypeHint=%s&useEncryption=%s&useEncryption@TypeHint=%s&nameIdFormat=%s&nameIdFormat@TypeHint=%s&digestMethod=%s&digestMethod@TypeHint=%s&signatureMethod=%s&signatureMethod@TypeHint=%s&userIntermediatePath=%s&userIntermediatePath@TypeHint=%s",
			self.basePath, http_util.encodeURIComponent(key_store_password), http_util.encodeURIComponent(key_store_password_type_hint), http_util.encodeURIComponent(service_ranking), http_util.encodeURIComponent(service_ranking_type_hint), http_util.encodeURIComponent(idp_http_redirect), http_util.encodeURIComponent(idp_http_redirect_type_hint), http_util.encodeURIComponent(create_user), http_util.encodeURIComponent(create_user_type_hint), http_util.encodeURIComponent(default_redirect_url), http_util.encodeURIComponent(default_redirect_url_type_hint), http_util.encodeURIComponent(user_id_attribute), http_util.encodeURIComponent(user_id_attribute_type_hint), http_util.encodeURIComponent(default_groups), http_util.encodeURIComponent(default_groups_type_hint), http_util.encodeURIComponent(idp_cert_alias), http_util.encodeURIComponent(idp_cert_alias_type_hint), http_util.encodeURIComponent(add_group_memberships), http_util.encodeURIComponent(add_group_memberships_type_hint), http_util.encodeURIComponent(path), http_util.encodeURIComponent(path_type_hint), http_util.encodeURIComponent(synchronize_attributes), http_util.encodeURIComponent(synchronize_attributes_type_hint), http_util.encodeURIComponent(clock_tolerance), http_util.encodeURIComponent(clock_tolerance_type_hint), http_util.encodeURIComponent(group_membership_attribute), http_util.encodeURIComponent(group_membership_attribute_type_hint), http_util.encodeURIComponent(idp_url), http_util.encodeURIComponent(idp_url_type_hint), http_util.encodeURIComponent(logout_url), http_util.encodeURIComponent(logout_url_type_hint), http_util.encodeURIComponent(service_provider_entity_id), http_util.encodeURIComponent(service_provider_entity_id_type_hint), http_util.encodeURIComponent(assertion_consumer_service_url), http_util.encodeURIComponent(assertion_consumer_service_url_type_hint), http_util.encodeURIComponent(handle_logout), http_util.encodeURIComponent(handle_logout_type_hint), http_util.encodeURIComponent(sp_private_key_alias), http_util.encodeURIComponent(sp_private_key_alias_type_hint), http_util.encodeURIComponent(use_encryption), http_util.encodeURIComponent(use_encryption_type_hint), http_util.encodeURIComponent(name_id_format), http_util.encodeURIComponent(name_id_format_type_hint), http_util.encodeURIComponent(digest_method), http_util.encodeURIComponent(digest_method_type_hint), http_util.encodeURIComponent(signature_method), http_util.encodeURIComponent(signature_method_type_hint), http_util.encodeURIComponent(user_intermediate_path), http_util.encodeURIComponent(user_intermediate_path_type_hint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_apache_felix_jetty_based_http_service(org_apache_felix_https_nio, org_apache_felix_https_nio_type_hint, org_apache_felix_https_keystore, org_apache_felix_https_keystore_type_hint, org_apache_felix_https_keystore_password, org_apache_felix_https_keystore_password_type_hint, org_apache_felix_https_keystore_key, org_apache_felix_https_keystore_key_type_hint, org_apache_felix_https_keystore_key_password, org_apache_felix_https_keystore_key_password_type_hint, org_apache_felix_https_truststore, org_apache_felix_https_truststore_type_hint, org_apache_felix_https_truststore_password, org_apache_felix_https_truststore_password_type_hint, org_apache_felix_https_clientcertificate, org_apache_felix_https_clientcertificate_type_hint, org_apache_felix_https_enable, org_apache_felix_https_enable_type_hint, org_osgi_service_http_port_secure, org_osgi_service_http_port_secure_type_hint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/org.apache.felix.http?org.apache.felix.https.nio=%s&org.apache.felix.https.nio@TypeHint=%s&org.apache.felix.https.keystore=%s&org.apache.felix.https.keystore@TypeHint=%s&org.apache.felix.https.keystore.password=%s&org.apache.felix.https.keystore.password@TypeHint=%s&org.apache.felix.https.keystore.key=%s&org.apache.felix.https.keystore.key@TypeHint=%s&org.apache.felix.https.keystore.key.password=%s&org.apache.felix.https.keystore.key.password@TypeHint=%s&org.apache.felix.https.truststore=%s&org.apache.felix.https.truststore@TypeHint=%s&org.apache.felix.https.truststore.password=%s&org.apache.felix.https.truststore.password@TypeHint=%s&org.apache.felix.https.clientcertificate=%s&org.apache.felix.https.clientcertificate@TypeHint=%s&org.apache.felix.https.enable=%s&org.apache.felix.https.enable@TypeHint=%s&org.osgi.service.http.port.secure=%s&org.osgi.service.http.port.secure@TypeHint=%s",
			self.basePath, http_util.encodeURIComponent(org_apache_felix_https_nio), http_util.encodeURIComponent(org_apache_felix_https_nio_type_hint), http_util.encodeURIComponent(org_apache_felix_https_keystore), http_util.encodeURIComponent(org_apache_felix_https_keystore_type_hint), http_util.encodeURIComponent(org_apache_felix_https_keystore_password), http_util.encodeURIComponent(org_apache_felix_https_keystore_password_type_hint), http_util.encodeURIComponent(org_apache_felix_https_keystore_key), http_util.encodeURIComponent(org_apache_felix_https_keystore_key_type_hint), http_util.encodeURIComponent(org_apache_felix_https_keystore_key_password), http_util.encodeURIComponent(org_apache_felix_https_keystore_key_password_type_hint), http_util.encodeURIComponent(org_apache_felix_https_truststore), http_util.encodeURIComponent(org_apache_felix_https_truststore_type_hint), http_util.encodeURIComponent(org_apache_felix_https_truststore_password), http_util.encodeURIComponent(org_apache_felix_https_truststore_password_type_hint), http_util.encodeURIComponent(org_apache_felix_https_clientcertificate), http_util.encodeURIComponent(org_apache_felix_https_clientcertificate_type_hint), http_util.encodeURIComponent(org_apache_felix_https_enable), http_util.encodeURIComponent(org_apache_felix_https_enable_type_hint), http_util.encodeURIComponent(org_osgi_service_http_port_secure), http_util.encodeURIComponent(org_osgi_service_http_port_secure_type_hint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_apache_http_components_proxy_configuration(proxy_host, proxy_host_type_hint, proxy_port, proxy_port_type_hint, proxy_exceptions, proxy_exceptions_type_hint, proxy_enabled, proxy_enabled_type_hint, proxy_user, proxy_user_type_hint, proxy_password, proxy_password_type_hint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/org.apache.http.proxyconfigurator.config?proxy.host=%s&proxy.host@TypeHint=%s&proxy.port=%s&proxy.port@TypeHint=%s&proxy.exceptions=%s&proxy.exceptions@TypeHint=%s&proxy.enabled=%s&proxy.enabled@TypeHint=%s&proxy.user=%s&proxy.user@TypeHint=%s&proxy.password=%s&proxy.password@TypeHint=%s",
			self.basePath, http_util.encodeURIComponent(proxy_host), http_util.encodeURIComponent(proxy_host_type_hint), http_util.encodeURIComponent(proxy_port), http_util.encodeURIComponent(proxy_port_type_hint), http_util.encodeURIComponent(proxy_exceptions), http_util.encodeURIComponent(proxy_exceptions_type_hint), http_util.encodeURIComponent(proxy_enabled), http_util.encodeURIComponent(proxy_enabled_type_hint), http_util.encodeURIComponent(proxy_user), http_util.encodeURIComponent(proxy_user_type_hint), http_util.encodeURIComponent(proxy_password), http_util.encodeURIComponent(proxy_password_type_hint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_apache_sling_dav_ex_servlet(alias, alias_type_hint, dav_create_absolute_uri, dav_create_absolute_uri_type_hint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet?alias=%s&alias@TypeHint=%s&dav.create-absolute-uri=%s&dav.create-absolute-uri@TypeHint=%s",
			self.basePath, http_util.encodeURIComponent(alias), http_util.encodeURIComponent(alias_type_hint), http_util.encodeURIComponent(dav_create_absolute_uri), http_util.encodeURIComponent(dav_create_absolute_uri_type_hint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_apache_sling_get_servlet(json_maximumresults, json_maximumresults_type_hint, enable_html, enable_html_type_hint, enable_txt, enable_txt_type_hint, enable_xml, enable_xml_type_hint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet?json.maximumresults=%s&json.maximumresults@TypeHint=%s&enable.html=%s&enable.html@TypeHint=%s&enable.txt=%s&enable.txt@TypeHint=%s&enable.xml=%s&enable.xml@TypeHint=%s",
			self.basePath, http_util.encodeURIComponent(json_maximumresults), http_util.encodeURIComponent(json_maximumresults_type_hint), http_util.encodeURIComponent(enable_html), http_util.encodeURIComponent(enable_html_type_hint), http_util.encodeURIComponent(enable_txt), http_util.encodeURIComponent(enable_txt_type_hint), http_util.encodeURIComponent(enable_xml), http_util.encodeURIComponent(enable_xml_type_hint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_apache_sling_referrer_filter(allow_empty, allow_empty_type_hint, allow_hosts, allow_hosts_type_hint, allow_hosts_regexp, allow_hosts_regexp_type_hint, filter_methods, filter_methods_type_hint)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/org.apache.sling.security.impl.ReferrerFilter?allow.empty=%s&allow.empty@TypeHint=%s&allow.hosts=%s&allow.hosts@TypeHint=%s&allow.hosts.regexp=%s&allow.hosts.regexp@TypeHint=%s&filter.methods=%s&filter.methods@TypeHint=%s",
			self.basePath, http_util.encodeURIComponent(allow_empty), http_util.encodeURIComponent(allow_empty_type_hint), http_util.encodeURIComponent(allow_hosts), http_util.encodeURIComponent(allow_hosts_type_hint), http_util.encodeURIComponent(allow_hosts_regexp), http_util.encodeURIComponent(allow_hosts_regexp_type_hint), http_util.encodeURIComponent(filter_methods), http_util.encodeURIComponent(filter_methods_type_hint));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_config_property(config_node_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/apps/system/config/%s",
			self.basePath, config_node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_node(path, name, operation, delete_authorizable, file)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/%s?:operation=%s&deleteAuthorizable=%s",
			self.basePath, path, name, http_util.encodeURIComponent(operation), http_util.encodeURIComponent(delete_authorizable));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	req:set_body(http_util.dict_to_query({
		["file"] = file;
	}))
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_node_rw(path, name, add_members)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s/{name}.rw.html?addMembers=%s",
			self.basePath, path, name, http_util.encodeURIComponent(add_members));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_path(path, jcrprimary_type, name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/%s?jcr:primaryType=%s&:name=%s",
			self.basePath, path, http_util.encodeURIComponent(jcrprimary_type), http_util.encodeURIComponent(name));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_query(path, p_limit, Var1_property, Var1_property_value)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/bin/querybuilder.json?path=%s&p.limit=%s&1_property=%s&1_property.value=%s",
			self.basePath, http_util.encodeURIComponent(path), http_util.encodeURIComponent(p_limit), http_util.encodeURIComponent(Var1_property), http_util.encodeURIComponent(Var1_property_value));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_tree_activation(ignoredeactivated, onlymodified, path)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/replication/treeactivation.html?ignoredeactivated=%s&onlymodified=%s&path=%s",
			self.basePath, http_util.encodeURIComponent(ignoredeactivated), http_util.encodeURIComponent(onlymodified), http_util.encodeURIComponent(path));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_truststore(operation, new_password, re_password, key_store_type, remove_alias, certificate)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/libs/granite/security/post/truststore?:operation=%s&newPassword=%s&rePassword=%s&keyStoreType=%s&removeAlias=%s",
			self.basePath, http_util.encodeURIComponent(operation), http_util.encodeURIComponent(new_password), http_util.encodeURIComponent(re_password), http_util.encodeURIComponent(key_store_type), http_util.encodeURIComponent(remove_alias));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/plain" }
	req.headers:upsert("content-type", "text/plain")

	req:set_body(http_util.dict_to_query({
		["certificate"] = certificate;
	}))
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function sling_api:post_truststore_pkcs12(truststore_p12)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/etc/truststore",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/plain" }
	req.headers:upsert("content-type", "text/plain")

	req:set_body(http_util.dict_to_query({
		["truststore.p12"] = truststore_p12;
	}))
	-- HTTP basic auth
	req.readers:upsert("authorization", "Basic " .. basexx.to_base64(self.http_username .. " " .. self.http_password))

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_sling_api;
}
