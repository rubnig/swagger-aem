/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "BundleData.h"

#include <string>
#include <sstream>
#include <stdexcept>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

BundleData::BundleData()
{
	m_Id = 0;
	m_Name = "";
	m_Fragment = false;
	m_StateRaw = 0;
	m_State = "";
	m_Version = "";
	m_SymbolicName = "";
	m_Category = "";
}

BundleData::~BundleData()
{
}

std::string BundleData::toJsonString(bool prettyJson)
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
	return ss.str();
}

void BundleData::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree BundleData::toPropertyTree()
{
	ptree pt;
	ptree tmp_node;
	pt.put("id", m_Id);
	pt.put("name", m_Name);
	pt.put("fragment", m_Fragment);
	pt.put("stateRaw", m_StateRaw);
	pt.put("state", m_State);
	pt.put("version", m_Version);
	pt.put("symbolicName", m_SymbolicName);
	pt.put("category", m_Category);
	// generate tree for Props
	if (!m_Props.empty()) {
		for (const auto &childEntry : m_Props) {
			ptree Props_node;
			Props_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Props_node));
		}
		pt.add_child("props", tmp_node);
		tmp_node.clear();
	}
	return pt;
}

void BundleData::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	m_Id = pt.get("id", 0);
	m_Name = pt.get("name", "");
	m_Fragment = pt.get("fragment", false);
	m_StateRaw = pt.get("stateRaw", 0);
	m_State = pt.get("state", "");
	m_Version = pt.get("version", "");
	m_SymbolicName = pt.get("symbolicName", "");
	m_Category = pt.get("category", "");
	// push all items of Props into member vector
	if (pt.get_child_optional("props")) {
		for (const auto &childTree : pt.get_child("props")) {
			m_Props.emplace_back(childTree.second.data());
		}
	}
}

int32_t BundleData::getId() const
{
    return m_Id;
}
void BundleData::setId(int32_t value)
{
	m_Id = value;
}
std::string BundleData::getName() const
{
    return m_Name;
}
void BundleData::setName(std::string value)
{
	m_Name = value;
}
bool BundleData::isFragment() const
{
    return m_Fragment;
}
void BundleData::setFragment(bool value)
{
	m_Fragment = value;
}
int32_t BundleData::getStateRaw() const
{
    return m_StateRaw;
}
void BundleData::setStateRaw(int32_t value)
{
	m_StateRaw = value;
}
std::string BundleData::getState() const
{
    return m_State;
}
void BundleData::setState(std::string value)
{
	m_State = value;
}
std::string BundleData::getVersion() const
{
    return m_Version;
}
void BundleData::setVersion(std::string value)
{
	m_Version = value;
}
std::string BundleData::getSymbolicName() const
{
    return m_SymbolicName;
}
void BundleData::setSymbolicName(std::string value)
{
	m_SymbolicName = value;
}
std::string BundleData::getCategory() const
{
    return m_Category;
}
void BundleData::setCategory(std::string value)
{
	m_Category = value;
}
std::vector<std::shared_ptr<BundleDataProp>> BundleData::getProps() const
{
    return m_Props;
}
void BundleData::setProps(std::vector<std::shared_ptr<BundleDataProp>> value)
{
	m_Props = value;
}

}
}
}
}

