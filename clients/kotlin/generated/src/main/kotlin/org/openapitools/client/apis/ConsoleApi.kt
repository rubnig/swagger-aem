/**
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.BundleInfo
import org.openapitools.client.models.SamlConfigurationInfo

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ConsoleApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * 
    * @return kotlin.collections.List<kotlin.String>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAemProductInfo() : kotlin.collections.List<kotlin.String> {
        val localVariableConfig = getAemProductInfoRequestConfig()

        val localVarResponse = request<Unit, kotlin.collections.List<kotlin.String>>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.String>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getAemProductInfo
    *
    * @return RequestConfig
    */
    fun getAemProductInfoRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/system/console/status-productinfo.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param name  
    * @return BundleInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBundleInfo(name: kotlin.String) : BundleInfo {
        val localVariableConfig = getBundleInfoRequestConfig(name = name)

        val localVarResponse = request<Unit, BundleInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BundleInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getBundleInfo
    *
    * @param name  
    * @return RequestConfig
    */
    fun getBundleInfoRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/system/console/bundles/{name}.json".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfigMgr() : kotlin.String {
        val localVariableConfig = getConfigMgrRequestConfig()

        val localVarResponse = request<Unit, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getConfigMgr
    *
    * @return RequestConfig
    */
    fun getConfigMgrRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/system/console/configMgr",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param name  
    * @param action  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postBundle(name: kotlin.String, action: kotlin.String) : Unit {
        val localVariableConfig = postBundleRequestConfig(name = name, action = action)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postBundle
    *
    * @param name  
    * @param action  
    * @return RequestConfig
    */
    fun postBundleRequestConfig(name: kotlin.String, action: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("action", listOf(action.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/system/console/bundles/{name}".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param action  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJmxRepository(action: kotlin.String) : Unit {
        val localVariableConfig = postJmxRepositoryRequestConfig(action = action)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postJmxRepository
    *
    * @param action  
    * @return RequestConfig
    */
    fun postJmxRepositoryRequestConfig(action: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/system/console/jmx/com.adobe.granite:type&#x3D;Repository/op/{action}".replace("{"+"action"+"}", "$action"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param post  (optional)
    * @param apply  (optional)
    * @param delete  (optional)
    * @param action  (optional)
    * @param dollarLocation  (optional)
    * @param path  (optional)
    * @param serviceRanking  (optional)
    * @param idpUrl  (optional)
    * @param idpCertAlias  (optional)
    * @param idpHttpRedirect  (optional)
    * @param serviceProviderEntityId  (optional)
    * @param assertionConsumerServiceURL  (optional)
    * @param spPrivateKeyAlias  (optional)
    * @param keyStorePassword  (optional)
    * @param defaultRedirectUrl  (optional)
    * @param userIDAttribute  (optional)
    * @param useEncryption  (optional)
    * @param createUser  (optional)
    * @param addGroupMemberships  (optional)
    * @param groupMembershipAttribute  (optional)
    * @param defaultGroups  (optional)
    * @param nameIdFormat  (optional)
    * @param synchronizeAttributes  (optional)
    * @param handleLogout  (optional)
    * @param logoutUrl  (optional)
    * @param clockTolerance  (optional)
    * @param digestMethod  (optional)
    * @param signatureMethod  (optional)
    * @param userIntermediatePath  (optional)
    * @param propertylist  (optional)
    * @return SamlConfigurationInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postSamlConfiguration(post: kotlin.Boolean?, apply: kotlin.Boolean?, delete: kotlin.Boolean?, action: kotlin.String?, dollarLocation: kotlin.String?, path: kotlin.collections.List<kotlin.String>?, serviceRanking: kotlin.Int?, idpUrl: kotlin.String?, idpCertAlias: kotlin.String?, idpHttpRedirect: kotlin.Boolean?, serviceProviderEntityId: kotlin.String?, assertionConsumerServiceURL: kotlin.String?, spPrivateKeyAlias: kotlin.String?, keyStorePassword: kotlin.String?, defaultRedirectUrl: kotlin.String?, userIDAttribute: kotlin.String?, useEncryption: kotlin.Boolean?, createUser: kotlin.Boolean?, addGroupMemberships: kotlin.Boolean?, groupMembershipAttribute: kotlin.String?, defaultGroups: kotlin.collections.List<kotlin.String>?, nameIdFormat: kotlin.String?, synchronizeAttributes: kotlin.collections.List<kotlin.String>?, handleLogout: kotlin.Boolean?, logoutUrl: kotlin.String?, clockTolerance: kotlin.Int?, digestMethod: kotlin.String?, signatureMethod: kotlin.String?, userIntermediatePath: kotlin.String?, propertylist: kotlin.collections.List<kotlin.String>?) : SamlConfigurationInfo {
        val localVariableConfig = postSamlConfigurationRequestConfig(post = post, apply = apply, delete = delete, action = action, dollarLocation = dollarLocation, path = path, serviceRanking = serviceRanking, idpUrl = idpUrl, idpCertAlias = idpCertAlias, idpHttpRedirect = idpHttpRedirect, serviceProviderEntityId = serviceProviderEntityId, assertionConsumerServiceURL = assertionConsumerServiceURL, spPrivateKeyAlias = spPrivateKeyAlias, keyStorePassword = keyStorePassword, defaultRedirectUrl = defaultRedirectUrl, userIDAttribute = userIDAttribute, useEncryption = useEncryption, createUser = createUser, addGroupMemberships = addGroupMemberships, groupMembershipAttribute = groupMembershipAttribute, defaultGroups = defaultGroups, nameIdFormat = nameIdFormat, synchronizeAttributes = synchronizeAttributes, handleLogout = handleLogout, logoutUrl = logoutUrl, clockTolerance = clockTolerance, digestMethod = digestMethod, signatureMethod = signatureMethod, userIntermediatePath = userIntermediatePath, propertylist = propertylist)

        val localVarResponse = request<Unit, SamlConfigurationInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SamlConfigurationInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postSamlConfiguration
    *
    * @param post  (optional)
    * @param apply  (optional)
    * @param delete  (optional)
    * @param action  (optional)
    * @param dollarLocation  (optional)
    * @param path  (optional)
    * @param serviceRanking  (optional)
    * @param idpUrl  (optional)
    * @param idpCertAlias  (optional)
    * @param idpHttpRedirect  (optional)
    * @param serviceProviderEntityId  (optional)
    * @param assertionConsumerServiceURL  (optional)
    * @param spPrivateKeyAlias  (optional)
    * @param keyStorePassword  (optional)
    * @param defaultRedirectUrl  (optional)
    * @param userIDAttribute  (optional)
    * @param useEncryption  (optional)
    * @param createUser  (optional)
    * @param addGroupMemberships  (optional)
    * @param groupMembershipAttribute  (optional)
    * @param defaultGroups  (optional)
    * @param nameIdFormat  (optional)
    * @param synchronizeAttributes  (optional)
    * @param handleLogout  (optional)
    * @param logoutUrl  (optional)
    * @param clockTolerance  (optional)
    * @param digestMethod  (optional)
    * @param signatureMethod  (optional)
    * @param userIntermediatePath  (optional)
    * @param propertylist  (optional)
    * @return RequestConfig
    */
    fun postSamlConfigurationRequestConfig(post: kotlin.Boolean?, apply: kotlin.Boolean?, delete: kotlin.Boolean?, action: kotlin.String?, dollarLocation: kotlin.String?, path: kotlin.collections.List<kotlin.String>?, serviceRanking: kotlin.Int?, idpUrl: kotlin.String?, idpCertAlias: kotlin.String?, idpHttpRedirect: kotlin.Boolean?, serviceProviderEntityId: kotlin.String?, assertionConsumerServiceURL: kotlin.String?, spPrivateKeyAlias: kotlin.String?, keyStorePassword: kotlin.String?, defaultRedirectUrl: kotlin.String?, userIDAttribute: kotlin.String?, useEncryption: kotlin.Boolean?, createUser: kotlin.Boolean?, addGroupMemberships: kotlin.Boolean?, groupMembershipAttribute: kotlin.String?, defaultGroups: kotlin.collections.List<kotlin.String>?, nameIdFormat: kotlin.String?, synchronizeAttributes: kotlin.collections.List<kotlin.String>?, handleLogout: kotlin.Boolean?, logoutUrl: kotlin.String?, clockTolerance: kotlin.Int?, digestMethod: kotlin.String?, signatureMethod: kotlin.String?, userIntermediatePath: kotlin.String?, propertylist: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (post != null) {
                    put("post", listOf(post.toString()))
                }
                if (apply != null) {
                    put("apply", listOf(apply.toString()))
                }
                if (delete != null) {
                    put("delete", listOf(delete.toString()))
                }
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (dollarLocation != null) {
                    put("$location", listOf(dollarLocation.toString()))
                }
                if (path != null) {
                    put("path", toMultiValue(path.toList(), "multi"))
                }
                if (serviceRanking != null) {
                    put("service.ranking", listOf(serviceRanking.toString()))
                }
                if (idpUrl != null) {
                    put("idpUrl", listOf(idpUrl.toString()))
                }
                if (idpCertAlias != null) {
                    put("idpCertAlias", listOf(idpCertAlias.toString()))
                }
                if (idpHttpRedirect != null) {
                    put("idpHttpRedirect", listOf(idpHttpRedirect.toString()))
                }
                if (serviceProviderEntityId != null) {
                    put("serviceProviderEntityId", listOf(serviceProviderEntityId.toString()))
                }
                if (assertionConsumerServiceURL != null) {
                    put("assertionConsumerServiceURL", listOf(assertionConsumerServiceURL.toString()))
                }
                if (spPrivateKeyAlias != null) {
                    put("spPrivateKeyAlias", listOf(spPrivateKeyAlias.toString()))
                }
                if (keyStorePassword != null) {
                    put("keyStorePassword", listOf(keyStorePassword.toString()))
                }
                if (defaultRedirectUrl != null) {
                    put("defaultRedirectUrl", listOf(defaultRedirectUrl.toString()))
                }
                if (userIDAttribute != null) {
                    put("userIDAttribute", listOf(userIDAttribute.toString()))
                }
                if (useEncryption != null) {
                    put("useEncryption", listOf(useEncryption.toString()))
                }
                if (createUser != null) {
                    put("createUser", listOf(createUser.toString()))
                }
                if (addGroupMemberships != null) {
                    put("addGroupMemberships", listOf(addGroupMemberships.toString()))
                }
                if (groupMembershipAttribute != null) {
                    put("groupMembershipAttribute", listOf(groupMembershipAttribute.toString()))
                }
                if (defaultGroups != null) {
                    put("defaultGroups", toMultiValue(defaultGroups.toList(), "multi"))
                }
                if (nameIdFormat != null) {
                    put("nameIdFormat", listOf(nameIdFormat.toString()))
                }
                if (synchronizeAttributes != null) {
                    put("synchronizeAttributes", toMultiValue(synchronizeAttributes.toList(), "multi"))
                }
                if (handleLogout != null) {
                    put("handleLogout", listOf(handleLogout.toString()))
                }
                if (logoutUrl != null) {
                    put("logoutUrl", listOf(logoutUrl.toString()))
                }
                if (clockTolerance != null) {
                    put("clockTolerance", listOf(clockTolerance.toString()))
                }
                if (digestMethod != null) {
                    put("digestMethod", listOf(digestMethod.toString()))
                }
                if (signatureMethod != null) {
                    put("signatureMethod", listOf(signatureMethod.toString()))
                }
                if (userIntermediatePath != null) {
                    put("userIntermediatePath", listOf(userIntermediatePath.toString()))
                }
                if (propertylist != null) {
                    put("propertylist", toMultiValue(propertylist.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
