/**
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.KeystoreInfo
import org.openapitools.client.models.TruststoreInfo

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class SlingApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param runmode  
    * @param name  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAgent(runmode: kotlin.String, name: kotlin.String) : Unit {
        val localVariableConfig = deleteAgentRequestConfig(runmode = runmode, name = name)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deleteAgent
    *
    * @param runmode  
    * @param name  
    * @return RequestConfig
    */
    fun deleteAgentRequestConfig(runmode: kotlin.String, name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/etc/replication/agents.{runmode}/{name}".replace("{"+"runmode"+"}", "$runmode").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteNode(path: kotlin.String, name: kotlin.String) : Unit {
        val localVariableConfig = deleteNodeRequestConfig(path = path, name = name)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deleteNode
    *
    * @param path  
    * @param name  
    * @return RequestConfig
    */
    fun deleteNodeRequestConfig(path: kotlin.String, name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/{path}/{name}".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param runmode  
    * @param name  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAgent(runmode: kotlin.String, name: kotlin.String) : Unit {
        val localVariableConfig = getAgentRequestConfig(runmode = runmode, name = name)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getAgent
    *
    * @param runmode  
    * @param name  
    * @return RequestConfig
    */
    fun getAgentRequestConfig(runmode: kotlin.String, name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etc/replication/agents.{runmode}/{name}".replace("{"+"runmode"+"}", "$runmode").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param runmode  
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAgents(runmode: kotlin.String) : kotlin.String {
        val localVariableConfig = getAgentsRequestConfig(runmode = runmode)

        val localVarResponse = request<Unit, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getAgents
    *
    * @param runmode  
    * @return RequestConfig
    */
    fun getAgentsRequestConfig(runmode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etc/replication/agents.{runmode}.-1.json".replace("{"+"runmode"+"}", "$runmode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param intermediatePath  
    * @param authorizableId  
    * @return KeystoreInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAuthorizableKeystore(intermediatePath: kotlin.String, authorizableId: kotlin.String) : KeystoreInfo {
        val localVariableConfig = getAuthorizableKeystoreRequestConfig(intermediatePath = intermediatePath, authorizableId = authorizableId)

        val localVarResponse = request<Unit, KeystoreInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KeystoreInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getAuthorizableKeystore
    *
    * @param intermediatePath  
    * @param authorizableId  
    * @return RequestConfig
    */
    fun getAuthorizableKeystoreRequestConfig(intermediatePath: kotlin.String, authorizableId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/{intermediatePath}/{authorizableId}.ks.json".replace("{"+"intermediatePath"+"}", "$intermediatePath").replace("{"+"authorizableId"+"}", "$authorizableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param intermediatePath  
    * @param authorizableId  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeystore(intermediatePath: kotlin.String, authorizableId: kotlin.String) : java.io.File {
        val localVariableConfig = getKeystoreRequestConfig(intermediatePath = intermediatePath, authorizableId = authorizableId)

        val localVarResponse = request<Unit, java.io.File>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getKeystore
    *
    * @param intermediatePath  
    * @param authorizableId  
    * @return RequestConfig
    */
    fun getKeystoreRequestConfig(intermediatePath: kotlin.String, authorizableId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/{intermediatePath}/{authorizableId}/keystore/store.p12".replace("{"+"intermediatePath"+"}", "$intermediatePath").replace("{"+"authorizableId"+"}", "$authorizableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNode(path: kotlin.String, name: kotlin.String) : Unit {
        val localVariableConfig = getNodeRequestConfig(path = path, name = name)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getNode
    *
    * @param path  
    * @param name  
    * @return RequestConfig
    */
    fun getNodeRequestConfig(path: kotlin.String, name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/{path}/{name}".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param group  
    * @param name  
    * @param version  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPackage(group: kotlin.String, name: kotlin.String, version: kotlin.String) : java.io.File {
        val localVariableConfig = getPackageRequestConfig(group = group, name = name, version = version)

        val localVarResponse = request<Unit, java.io.File>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getPackage
    *
    * @param group  
    * @param name  
    * @param version  
    * @return RequestConfig
    */
    fun getPackageRequestConfig(group: kotlin.String, name: kotlin.String, version: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etc/packages/{group}/{name}-{version}.zip".replace("{"+"group"+"}", "$group").replace("{"+"name"+"}", "$name").replace("{"+"version"+"}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param group  
    * @param name  
    * @param version  
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPackageFilter(group: kotlin.String, name: kotlin.String, version: kotlin.String) : kotlin.String {
        val localVariableConfig = getPackageFilterRequestConfig(group = group, name = name, version = version)

        val localVarResponse = request<Unit, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getPackageFilter
    *
    * @param group  
    * @param name  
    * @param version  
    * @return RequestConfig
    */
    fun getPackageFilterRequestConfig(group: kotlin.String, name: kotlin.String, version: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json".replace("{"+"group"+"}", "$group").replace("{"+"name"+"}", "$name").replace("{"+"version"+"}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param pLimit  
    * @param `1property`  
    * @param `1propertyValue`  
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getQuery(path: kotlin.String, pLimit: java.math.BigDecimal, `1property`: kotlin.String, `1propertyValue`: kotlin.String) : kotlin.String {
        val localVariableConfig = getQueryRequestConfig(path = path, pLimit = pLimit, `1property` = `1property`, `1propertyValue` = `1propertyValue`)

        val localVarResponse = request<Unit, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getQuery
    *
    * @param path  
    * @param pLimit  
    * @param `1property`  
    * @param `1propertyValue`  
    * @return RequestConfig
    */
    fun getQueryRequestConfig(path: kotlin.String, pLimit: java.math.BigDecimal, `1property`: kotlin.String, `1propertyValue`: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("path", listOf(path.toString()))
                put("p.limit", listOf(pLimit.toString()))
                put("1_property", listOf(`1property`.toString()))
                put("1_property.value", listOf(`1propertyValue`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bin/querybuilder.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTruststore() : java.io.File {
        val localVariableConfig = getTruststoreRequestConfig()

        val localVarResponse = request<Unit, java.io.File>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTruststore
    *
    * @return RequestConfig
    */
    fun getTruststoreRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etc/truststore/truststore.p12",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @return TruststoreInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTruststoreInfo() : TruststoreInfo {
        val localVariableConfig = getTruststoreInfoRequestConfig()

        val localVarResponse = request<Unit, TruststoreInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TruststoreInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTruststoreInfo
    *
    * @return RequestConfig
    */
    fun getTruststoreInfoRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/libs/granite/security/truststore.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param runmode  
    * @param name  
    * @param jcrColonContentCqColonDistribute  (optional)
    * @param jcrColonContentCqColonDistributeAtTypeHint  (optional)
    * @param jcrColonContentCqColonName  (optional)
    * @param jcrColonContentCqColonTemplate  (optional)
    * @param jcrColonContentEnabled  (optional)
    * @param jcrColonContentJcrColonDescription  (optional)
    * @param jcrColonContentJcrColonLastModified  (optional)
    * @param jcrColonContentJcrColonLastModifiedBy  (optional)
    * @param jcrColonContentJcrColonMixinTypes  (optional)
    * @param jcrColonContentJcrColonTitle  (optional)
    * @param jcrColonContentLogLevel  (optional)
    * @param jcrColonContentNoStatusUpdate  (optional)
    * @param jcrColonContentNoVersioning  (optional)
    * @param jcrColonContentProtocolConnectTimeout  (optional)
    * @param jcrColonContentProtocolHTTPConnectionClosed  (optional)
    * @param jcrColonContentProtocolHTTPExpired  (optional)
    * @param jcrColonContentProtocolHTTPHeaders  (optional)
    * @param jcrColonContentProtocolHTTPHeadersAtTypeHint  (optional)
    * @param jcrColonContentProtocolHTTPMethod  (optional)
    * @param jcrColonContentProtocolHTTPSRelaxed  (optional)
    * @param jcrColonContentProtocolInterface  (optional)
    * @param jcrColonContentProtocolSocketTimeout  (optional)
    * @param jcrColonContentProtocolVersion  (optional)
    * @param jcrColonContentProxyNTLMDomain  (optional)
    * @param jcrColonContentProxyNTLMHost  (optional)
    * @param jcrColonContentProxyHost  (optional)
    * @param jcrColonContentProxyPassword  (optional)
    * @param jcrColonContentProxyPort  (optional)
    * @param jcrColonContentProxyUser  (optional)
    * @param jcrColonContentQueueBatchMaxSize  (optional)
    * @param jcrColonContentQueueBatchMode  (optional)
    * @param jcrColonContentQueueBatchWaitTime  (optional)
    * @param jcrColonContentRetryDelay  (optional)
    * @param jcrColonContentReverseReplication  (optional)
    * @param jcrColonContentSerializationType  (optional)
    * @param jcrColonContentSlingColonResourceType  (optional)
    * @param jcrColonContentSsl  (optional)
    * @param jcrColonContentTransportNTLMDomain  (optional)
    * @param jcrColonContentTransportNTLMHost  (optional)
    * @param jcrColonContentTransportPassword  (optional)
    * @param jcrColonContentTransportUri  (optional)
    * @param jcrColonContentTransportUser  (optional)
    * @param jcrColonContentTriggerDistribute  (optional)
    * @param jcrColonContentTriggerModified  (optional)
    * @param jcrColonContentTriggerOnOffTime  (optional)
    * @param jcrColonContentTriggerReceive  (optional)
    * @param jcrColonContentTriggerSpecific  (optional)
    * @param jcrColonContentUserId  (optional)
    * @param jcrColonPrimaryType  (optional)
    * @param colonOperation  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postAgent(runmode: kotlin.String, name: kotlin.String, jcrColonContentCqColonDistribute: kotlin.Boolean?, jcrColonContentCqColonDistributeAtTypeHint: kotlin.String?, jcrColonContentCqColonName: kotlin.String?, jcrColonContentCqColonTemplate: kotlin.String?, jcrColonContentEnabled: kotlin.Boolean?, jcrColonContentJcrColonDescription: kotlin.String?, jcrColonContentJcrColonLastModified: kotlin.String?, jcrColonContentJcrColonLastModifiedBy: kotlin.String?, jcrColonContentJcrColonMixinTypes: kotlin.String?, jcrColonContentJcrColonTitle: kotlin.String?, jcrColonContentLogLevel: kotlin.String?, jcrColonContentNoStatusUpdate: kotlin.Boolean?, jcrColonContentNoVersioning: kotlin.Boolean?, jcrColonContentProtocolConnectTimeout: java.math.BigDecimal?, jcrColonContentProtocolHTTPConnectionClosed: kotlin.Boolean?, jcrColonContentProtocolHTTPExpired: kotlin.String?, jcrColonContentProtocolHTTPHeaders: kotlin.collections.List<kotlin.String>?, jcrColonContentProtocolHTTPHeadersAtTypeHint: kotlin.String?, jcrColonContentProtocolHTTPMethod: kotlin.String?, jcrColonContentProtocolHTTPSRelaxed: kotlin.Boolean?, jcrColonContentProtocolInterface: kotlin.String?, jcrColonContentProtocolSocketTimeout: java.math.BigDecimal?, jcrColonContentProtocolVersion: kotlin.String?, jcrColonContentProxyNTLMDomain: kotlin.String?, jcrColonContentProxyNTLMHost: kotlin.String?, jcrColonContentProxyHost: kotlin.String?, jcrColonContentProxyPassword: kotlin.String?, jcrColonContentProxyPort: java.math.BigDecimal?, jcrColonContentProxyUser: kotlin.String?, jcrColonContentQueueBatchMaxSize: java.math.BigDecimal?, jcrColonContentQueueBatchMode: kotlin.String?, jcrColonContentQueueBatchWaitTime: java.math.BigDecimal?, jcrColonContentRetryDelay: kotlin.String?, jcrColonContentReverseReplication: kotlin.Boolean?, jcrColonContentSerializationType: kotlin.String?, jcrColonContentSlingColonResourceType: kotlin.String?, jcrColonContentSsl: kotlin.String?, jcrColonContentTransportNTLMDomain: kotlin.String?, jcrColonContentTransportNTLMHost: kotlin.String?, jcrColonContentTransportPassword: kotlin.String?, jcrColonContentTransportUri: kotlin.String?, jcrColonContentTransportUser: kotlin.String?, jcrColonContentTriggerDistribute: kotlin.Boolean?, jcrColonContentTriggerModified: kotlin.Boolean?, jcrColonContentTriggerOnOffTime: kotlin.Boolean?, jcrColonContentTriggerReceive: kotlin.Boolean?, jcrColonContentTriggerSpecific: kotlin.Boolean?, jcrColonContentUserId: kotlin.String?, jcrColonPrimaryType: kotlin.String?, colonOperation: kotlin.String?) : Unit {
        val localVariableConfig = postAgentRequestConfig(runmode = runmode, name = name, jcrColonContentCqColonDistribute = jcrColonContentCqColonDistribute, jcrColonContentCqColonDistributeAtTypeHint = jcrColonContentCqColonDistributeAtTypeHint, jcrColonContentCqColonName = jcrColonContentCqColonName, jcrColonContentCqColonTemplate = jcrColonContentCqColonTemplate, jcrColonContentEnabled = jcrColonContentEnabled, jcrColonContentJcrColonDescription = jcrColonContentJcrColonDescription, jcrColonContentJcrColonLastModified = jcrColonContentJcrColonLastModified, jcrColonContentJcrColonLastModifiedBy = jcrColonContentJcrColonLastModifiedBy, jcrColonContentJcrColonMixinTypes = jcrColonContentJcrColonMixinTypes, jcrColonContentJcrColonTitle = jcrColonContentJcrColonTitle, jcrColonContentLogLevel = jcrColonContentLogLevel, jcrColonContentNoStatusUpdate = jcrColonContentNoStatusUpdate, jcrColonContentNoVersioning = jcrColonContentNoVersioning, jcrColonContentProtocolConnectTimeout = jcrColonContentProtocolConnectTimeout, jcrColonContentProtocolHTTPConnectionClosed = jcrColonContentProtocolHTTPConnectionClosed, jcrColonContentProtocolHTTPExpired = jcrColonContentProtocolHTTPExpired, jcrColonContentProtocolHTTPHeaders = jcrColonContentProtocolHTTPHeaders, jcrColonContentProtocolHTTPHeadersAtTypeHint = jcrColonContentProtocolHTTPHeadersAtTypeHint, jcrColonContentProtocolHTTPMethod = jcrColonContentProtocolHTTPMethod, jcrColonContentProtocolHTTPSRelaxed = jcrColonContentProtocolHTTPSRelaxed, jcrColonContentProtocolInterface = jcrColonContentProtocolInterface, jcrColonContentProtocolSocketTimeout = jcrColonContentProtocolSocketTimeout, jcrColonContentProtocolVersion = jcrColonContentProtocolVersion, jcrColonContentProxyNTLMDomain = jcrColonContentProxyNTLMDomain, jcrColonContentProxyNTLMHost = jcrColonContentProxyNTLMHost, jcrColonContentProxyHost = jcrColonContentProxyHost, jcrColonContentProxyPassword = jcrColonContentProxyPassword, jcrColonContentProxyPort = jcrColonContentProxyPort, jcrColonContentProxyUser = jcrColonContentProxyUser, jcrColonContentQueueBatchMaxSize = jcrColonContentQueueBatchMaxSize, jcrColonContentQueueBatchMode = jcrColonContentQueueBatchMode, jcrColonContentQueueBatchWaitTime = jcrColonContentQueueBatchWaitTime, jcrColonContentRetryDelay = jcrColonContentRetryDelay, jcrColonContentReverseReplication = jcrColonContentReverseReplication, jcrColonContentSerializationType = jcrColonContentSerializationType, jcrColonContentSlingColonResourceType = jcrColonContentSlingColonResourceType, jcrColonContentSsl = jcrColonContentSsl, jcrColonContentTransportNTLMDomain = jcrColonContentTransportNTLMDomain, jcrColonContentTransportNTLMHost = jcrColonContentTransportNTLMHost, jcrColonContentTransportPassword = jcrColonContentTransportPassword, jcrColonContentTransportUri = jcrColonContentTransportUri, jcrColonContentTransportUser = jcrColonContentTransportUser, jcrColonContentTriggerDistribute = jcrColonContentTriggerDistribute, jcrColonContentTriggerModified = jcrColonContentTriggerModified, jcrColonContentTriggerOnOffTime = jcrColonContentTriggerOnOffTime, jcrColonContentTriggerReceive = jcrColonContentTriggerReceive, jcrColonContentTriggerSpecific = jcrColonContentTriggerSpecific, jcrColonContentUserId = jcrColonContentUserId, jcrColonPrimaryType = jcrColonPrimaryType, colonOperation = colonOperation)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postAgent
    *
    * @param runmode  
    * @param name  
    * @param jcrColonContentCqColonDistribute  (optional)
    * @param jcrColonContentCqColonDistributeAtTypeHint  (optional)
    * @param jcrColonContentCqColonName  (optional)
    * @param jcrColonContentCqColonTemplate  (optional)
    * @param jcrColonContentEnabled  (optional)
    * @param jcrColonContentJcrColonDescription  (optional)
    * @param jcrColonContentJcrColonLastModified  (optional)
    * @param jcrColonContentJcrColonLastModifiedBy  (optional)
    * @param jcrColonContentJcrColonMixinTypes  (optional)
    * @param jcrColonContentJcrColonTitle  (optional)
    * @param jcrColonContentLogLevel  (optional)
    * @param jcrColonContentNoStatusUpdate  (optional)
    * @param jcrColonContentNoVersioning  (optional)
    * @param jcrColonContentProtocolConnectTimeout  (optional)
    * @param jcrColonContentProtocolHTTPConnectionClosed  (optional)
    * @param jcrColonContentProtocolHTTPExpired  (optional)
    * @param jcrColonContentProtocolHTTPHeaders  (optional)
    * @param jcrColonContentProtocolHTTPHeadersAtTypeHint  (optional)
    * @param jcrColonContentProtocolHTTPMethod  (optional)
    * @param jcrColonContentProtocolHTTPSRelaxed  (optional)
    * @param jcrColonContentProtocolInterface  (optional)
    * @param jcrColonContentProtocolSocketTimeout  (optional)
    * @param jcrColonContentProtocolVersion  (optional)
    * @param jcrColonContentProxyNTLMDomain  (optional)
    * @param jcrColonContentProxyNTLMHost  (optional)
    * @param jcrColonContentProxyHost  (optional)
    * @param jcrColonContentProxyPassword  (optional)
    * @param jcrColonContentProxyPort  (optional)
    * @param jcrColonContentProxyUser  (optional)
    * @param jcrColonContentQueueBatchMaxSize  (optional)
    * @param jcrColonContentQueueBatchMode  (optional)
    * @param jcrColonContentQueueBatchWaitTime  (optional)
    * @param jcrColonContentRetryDelay  (optional)
    * @param jcrColonContentReverseReplication  (optional)
    * @param jcrColonContentSerializationType  (optional)
    * @param jcrColonContentSlingColonResourceType  (optional)
    * @param jcrColonContentSsl  (optional)
    * @param jcrColonContentTransportNTLMDomain  (optional)
    * @param jcrColonContentTransportNTLMHost  (optional)
    * @param jcrColonContentTransportPassword  (optional)
    * @param jcrColonContentTransportUri  (optional)
    * @param jcrColonContentTransportUser  (optional)
    * @param jcrColonContentTriggerDistribute  (optional)
    * @param jcrColonContentTriggerModified  (optional)
    * @param jcrColonContentTriggerOnOffTime  (optional)
    * @param jcrColonContentTriggerReceive  (optional)
    * @param jcrColonContentTriggerSpecific  (optional)
    * @param jcrColonContentUserId  (optional)
    * @param jcrColonPrimaryType  (optional)
    * @param colonOperation  (optional)
    * @return RequestConfig
    */
    fun postAgentRequestConfig(runmode: kotlin.String, name: kotlin.String, jcrColonContentCqColonDistribute: kotlin.Boolean?, jcrColonContentCqColonDistributeAtTypeHint: kotlin.String?, jcrColonContentCqColonName: kotlin.String?, jcrColonContentCqColonTemplate: kotlin.String?, jcrColonContentEnabled: kotlin.Boolean?, jcrColonContentJcrColonDescription: kotlin.String?, jcrColonContentJcrColonLastModified: kotlin.String?, jcrColonContentJcrColonLastModifiedBy: kotlin.String?, jcrColonContentJcrColonMixinTypes: kotlin.String?, jcrColonContentJcrColonTitle: kotlin.String?, jcrColonContentLogLevel: kotlin.String?, jcrColonContentNoStatusUpdate: kotlin.Boolean?, jcrColonContentNoVersioning: kotlin.Boolean?, jcrColonContentProtocolConnectTimeout: java.math.BigDecimal?, jcrColonContentProtocolHTTPConnectionClosed: kotlin.Boolean?, jcrColonContentProtocolHTTPExpired: kotlin.String?, jcrColonContentProtocolHTTPHeaders: kotlin.collections.List<kotlin.String>?, jcrColonContentProtocolHTTPHeadersAtTypeHint: kotlin.String?, jcrColonContentProtocolHTTPMethod: kotlin.String?, jcrColonContentProtocolHTTPSRelaxed: kotlin.Boolean?, jcrColonContentProtocolInterface: kotlin.String?, jcrColonContentProtocolSocketTimeout: java.math.BigDecimal?, jcrColonContentProtocolVersion: kotlin.String?, jcrColonContentProxyNTLMDomain: kotlin.String?, jcrColonContentProxyNTLMHost: kotlin.String?, jcrColonContentProxyHost: kotlin.String?, jcrColonContentProxyPassword: kotlin.String?, jcrColonContentProxyPort: java.math.BigDecimal?, jcrColonContentProxyUser: kotlin.String?, jcrColonContentQueueBatchMaxSize: java.math.BigDecimal?, jcrColonContentQueueBatchMode: kotlin.String?, jcrColonContentQueueBatchWaitTime: java.math.BigDecimal?, jcrColonContentRetryDelay: kotlin.String?, jcrColonContentReverseReplication: kotlin.Boolean?, jcrColonContentSerializationType: kotlin.String?, jcrColonContentSlingColonResourceType: kotlin.String?, jcrColonContentSsl: kotlin.String?, jcrColonContentTransportNTLMDomain: kotlin.String?, jcrColonContentTransportNTLMHost: kotlin.String?, jcrColonContentTransportPassword: kotlin.String?, jcrColonContentTransportUri: kotlin.String?, jcrColonContentTransportUser: kotlin.String?, jcrColonContentTriggerDistribute: kotlin.Boolean?, jcrColonContentTriggerModified: kotlin.Boolean?, jcrColonContentTriggerOnOffTime: kotlin.Boolean?, jcrColonContentTriggerReceive: kotlin.Boolean?, jcrColonContentTriggerSpecific: kotlin.Boolean?, jcrColonContentUserId: kotlin.String?, jcrColonPrimaryType: kotlin.String?, colonOperation: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (jcrColonContentCqColonDistribute != null) {
                    put("jcr:content/cq:distribute", listOf(jcrColonContentCqColonDistribute.toString()))
                }
                if (jcrColonContentCqColonDistributeAtTypeHint != null) {
                    put("jcr:content/cq:distribute@TypeHint", listOf(jcrColonContentCqColonDistributeAtTypeHint.toString()))
                }
                if (jcrColonContentCqColonName != null) {
                    put("jcr:content/cq:name", listOf(jcrColonContentCqColonName.toString()))
                }
                if (jcrColonContentCqColonTemplate != null) {
                    put("jcr:content/cq:template", listOf(jcrColonContentCqColonTemplate.toString()))
                }
                if (jcrColonContentEnabled != null) {
                    put("jcr:content/enabled", listOf(jcrColonContentEnabled.toString()))
                }
                if (jcrColonContentJcrColonDescription != null) {
                    put("jcr:content/jcr:description", listOf(jcrColonContentJcrColonDescription.toString()))
                }
                if (jcrColonContentJcrColonLastModified != null) {
                    put("jcr:content/jcr:lastModified", listOf(jcrColonContentJcrColonLastModified.toString()))
                }
                if (jcrColonContentJcrColonLastModifiedBy != null) {
                    put("jcr:content/jcr:lastModifiedBy", listOf(jcrColonContentJcrColonLastModifiedBy.toString()))
                }
                if (jcrColonContentJcrColonMixinTypes != null) {
                    put("jcr:content/jcr:mixinTypes", listOf(jcrColonContentJcrColonMixinTypes.toString()))
                }
                if (jcrColonContentJcrColonTitle != null) {
                    put("jcr:content/jcr:title", listOf(jcrColonContentJcrColonTitle.toString()))
                }
                if (jcrColonContentLogLevel != null) {
                    put("jcr:content/logLevel", listOf(jcrColonContentLogLevel.toString()))
                }
                if (jcrColonContentNoStatusUpdate != null) {
                    put("jcr:content/noStatusUpdate", listOf(jcrColonContentNoStatusUpdate.toString()))
                }
                if (jcrColonContentNoVersioning != null) {
                    put("jcr:content/noVersioning", listOf(jcrColonContentNoVersioning.toString()))
                }
                if (jcrColonContentProtocolConnectTimeout != null) {
                    put("jcr:content/protocolConnectTimeout", listOf(jcrColonContentProtocolConnectTimeout.toString()))
                }
                if (jcrColonContentProtocolHTTPConnectionClosed != null) {
                    put("jcr:content/protocolHTTPConnectionClosed", listOf(jcrColonContentProtocolHTTPConnectionClosed.toString()))
                }
                if (jcrColonContentProtocolHTTPExpired != null) {
                    put("jcr:content/protocolHTTPExpired", listOf(jcrColonContentProtocolHTTPExpired.toString()))
                }
                if (jcrColonContentProtocolHTTPHeaders != null) {
                    put("jcr:content/protocolHTTPHeaders", toMultiValue(jcrColonContentProtocolHTTPHeaders.toList(), "multi"))
                }
                if (jcrColonContentProtocolHTTPHeadersAtTypeHint != null) {
                    put("jcr:content/protocolHTTPHeaders@TypeHint", listOf(jcrColonContentProtocolHTTPHeadersAtTypeHint.toString()))
                }
                if (jcrColonContentProtocolHTTPMethod != null) {
                    put("jcr:content/protocolHTTPMethod", listOf(jcrColonContentProtocolHTTPMethod.toString()))
                }
                if (jcrColonContentProtocolHTTPSRelaxed != null) {
                    put("jcr:content/protocolHTTPSRelaxed", listOf(jcrColonContentProtocolHTTPSRelaxed.toString()))
                }
                if (jcrColonContentProtocolInterface != null) {
                    put("jcr:content/protocolInterface", listOf(jcrColonContentProtocolInterface.toString()))
                }
                if (jcrColonContentProtocolSocketTimeout != null) {
                    put("jcr:content/protocolSocketTimeout", listOf(jcrColonContentProtocolSocketTimeout.toString()))
                }
                if (jcrColonContentProtocolVersion != null) {
                    put("jcr:content/protocolVersion", listOf(jcrColonContentProtocolVersion.toString()))
                }
                if (jcrColonContentProxyNTLMDomain != null) {
                    put("jcr:content/proxyNTLMDomain", listOf(jcrColonContentProxyNTLMDomain.toString()))
                }
                if (jcrColonContentProxyNTLMHost != null) {
                    put("jcr:content/proxyNTLMHost", listOf(jcrColonContentProxyNTLMHost.toString()))
                }
                if (jcrColonContentProxyHost != null) {
                    put("jcr:content/proxyHost", listOf(jcrColonContentProxyHost.toString()))
                }
                if (jcrColonContentProxyPassword != null) {
                    put("jcr:content/proxyPassword", listOf(jcrColonContentProxyPassword.toString()))
                }
                if (jcrColonContentProxyPort != null) {
                    put("jcr:content/proxyPort", listOf(jcrColonContentProxyPort.toString()))
                }
                if (jcrColonContentProxyUser != null) {
                    put("jcr:content/proxyUser", listOf(jcrColonContentProxyUser.toString()))
                }
                if (jcrColonContentQueueBatchMaxSize != null) {
                    put("jcr:content/queueBatchMaxSize", listOf(jcrColonContentQueueBatchMaxSize.toString()))
                }
                if (jcrColonContentQueueBatchMode != null) {
                    put("jcr:content/queueBatchMode", listOf(jcrColonContentQueueBatchMode.toString()))
                }
                if (jcrColonContentQueueBatchWaitTime != null) {
                    put("jcr:content/queueBatchWaitTime", listOf(jcrColonContentQueueBatchWaitTime.toString()))
                }
                if (jcrColonContentRetryDelay != null) {
                    put("jcr:content/retryDelay", listOf(jcrColonContentRetryDelay.toString()))
                }
                if (jcrColonContentReverseReplication != null) {
                    put("jcr:content/reverseReplication", listOf(jcrColonContentReverseReplication.toString()))
                }
                if (jcrColonContentSerializationType != null) {
                    put("jcr:content/serializationType", listOf(jcrColonContentSerializationType.toString()))
                }
                if (jcrColonContentSlingColonResourceType != null) {
                    put("jcr:content/sling:resourceType", listOf(jcrColonContentSlingColonResourceType.toString()))
                }
                if (jcrColonContentSsl != null) {
                    put("jcr:content/ssl", listOf(jcrColonContentSsl.toString()))
                }
                if (jcrColonContentTransportNTLMDomain != null) {
                    put("jcr:content/transportNTLMDomain", listOf(jcrColonContentTransportNTLMDomain.toString()))
                }
                if (jcrColonContentTransportNTLMHost != null) {
                    put("jcr:content/transportNTLMHost", listOf(jcrColonContentTransportNTLMHost.toString()))
                }
                if (jcrColonContentTransportPassword != null) {
                    put("jcr:content/transportPassword", listOf(jcrColonContentTransportPassword.toString()))
                }
                if (jcrColonContentTransportUri != null) {
                    put("jcr:content/transportUri", listOf(jcrColonContentTransportUri.toString()))
                }
                if (jcrColonContentTransportUser != null) {
                    put("jcr:content/transportUser", listOf(jcrColonContentTransportUser.toString()))
                }
                if (jcrColonContentTriggerDistribute != null) {
                    put("jcr:content/triggerDistribute", listOf(jcrColonContentTriggerDistribute.toString()))
                }
                if (jcrColonContentTriggerModified != null) {
                    put("jcr:content/triggerModified", listOf(jcrColonContentTriggerModified.toString()))
                }
                if (jcrColonContentTriggerOnOffTime != null) {
                    put("jcr:content/triggerOnOffTime", listOf(jcrColonContentTriggerOnOffTime.toString()))
                }
                if (jcrColonContentTriggerReceive != null) {
                    put("jcr:content/triggerReceive", listOf(jcrColonContentTriggerReceive.toString()))
                }
                if (jcrColonContentTriggerSpecific != null) {
                    put("jcr:content/triggerSpecific", listOf(jcrColonContentTriggerSpecific.toString()))
                }
                if (jcrColonContentUserId != null) {
                    put("jcr:content/userId", listOf(jcrColonContentUserId.toString()))
                }
                if (jcrColonPrimaryType != null) {
                    put("jcr:primaryType", listOf(jcrColonPrimaryType.toString()))
                }
                if (colonOperation != null) {
                    put(":operation", listOf(colonOperation.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/etc/replication/agents.{runmode}/{name}".replace("{"+"runmode"+"}", "$runmode").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param intermediatePath  
    * @param authorizableId  
    * @param colonOperation  (optional)
    * @param currentPassword  (optional)
    * @param newPassword  (optional)
    * @param rePassword  (optional)
    * @param keyPassword  (optional)
    * @param keyStorePass  (optional)
    * @param alias  (optional)
    * @param newAlias  (optional)
    * @param removeAlias  (optional)
    * @param certChain  (optional)
    * @param pk  (optional)
    * @param keyStore  (optional)
    * @return KeystoreInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postAuthorizableKeystore(intermediatePath: kotlin.String, authorizableId: kotlin.String, colonOperation: kotlin.String?, currentPassword: kotlin.String?, newPassword: kotlin.String?, rePassword: kotlin.String?, keyPassword: kotlin.String?, keyStorePass: kotlin.String?, alias: kotlin.String?, newAlias: kotlin.String?, removeAlias: kotlin.String?, certChain: java.io.File?, pk: java.io.File?, keyStore: java.io.File?) : KeystoreInfo {
        val localVariableConfig = postAuthorizableKeystoreRequestConfig(intermediatePath = intermediatePath, authorizableId = authorizableId, colonOperation = colonOperation, currentPassword = currentPassword, newPassword = newPassword, rePassword = rePassword, keyPassword = keyPassword, keyStorePass = keyStorePass, alias = alias, newAlias = newAlias, removeAlias = removeAlias, certChain = certChain, pk = pk, keyStore = keyStore)

        val localVarResponse = request<Map<String, Any?>, KeystoreInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KeystoreInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postAuthorizableKeystore
    *
    * @param intermediatePath  
    * @param authorizableId  
    * @param colonOperation  (optional)
    * @param currentPassword  (optional)
    * @param newPassword  (optional)
    * @param rePassword  (optional)
    * @param keyPassword  (optional)
    * @param keyStorePass  (optional)
    * @param alias  (optional)
    * @param newAlias  (optional)
    * @param removeAlias  (optional)
    * @param certChain  (optional)
    * @param pk  (optional)
    * @param keyStore  (optional)
    * @return RequestConfig
    */
    fun postAuthorizableKeystoreRequestConfig(intermediatePath: kotlin.String, authorizableId: kotlin.String, colonOperation: kotlin.String?, currentPassword: kotlin.String?, newPassword: kotlin.String?, rePassword: kotlin.String?, keyPassword: kotlin.String?, keyStorePass: kotlin.String?, alias: kotlin.String?, newAlias: kotlin.String?, removeAlias: kotlin.String?, certChain: java.io.File?, pk: java.io.File?, keyStore: java.io.File?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("cert-chain" to certChain, "pk" to pk, "keyStore" to keyStore)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (colonOperation != null) {
                    put(":operation", listOf(colonOperation.toString()))
                }
                if (currentPassword != null) {
                    put("currentPassword", listOf(currentPassword.toString()))
                }
                if (newPassword != null) {
                    put("newPassword", listOf(newPassword.toString()))
                }
                if (rePassword != null) {
                    put("rePassword", listOf(rePassword.toString()))
                }
                if (keyPassword != null) {
                    put("keyPassword", listOf(keyPassword.toString()))
                }
                if (keyStorePass != null) {
                    put("keyStorePass", listOf(keyStorePass.toString()))
                }
                if (alias != null) {
                    put("alias", listOf(alias.toString()))
                }
                if (newAlias != null) {
                    put("newAlias", listOf(newAlias.toString()))
                }
                if (removeAlias != null) {
                    put("removeAlias", listOf(removeAlias.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{intermediatePath}/{authorizableId}.ks.html".replace("{"+"intermediatePath"+"}", "$intermediatePath").replace("{"+"authorizableId"+"}", "$authorizableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param authorizableId  
    * @param intermediatePath  
    * @param createUser  (optional)
    * @param createGroup  (optional)
    * @param repColonPassword  (optional)
    * @param profileGivenName  (optional)
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postAuthorizables(authorizableId: kotlin.String, intermediatePath: kotlin.String, createUser: kotlin.String?, createGroup: kotlin.String?, repColonPassword: kotlin.String?, profileGivenName: kotlin.String?) : kotlin.String {
        val localVariableConfig = postAuthorizablesRequestConfig(authorizableId = authorizableId, intermediatePath = intermediatePath, createUser = createUser, createGroup = createGroup, repColonPassword = repColonPassword, profileGivenName = profileGivenName)

        val localVarResponse = request<Unit, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postAuthorizables
    *
    * @param authorizableId  
    * @param intermediatePath  
    * @param createUser  (optional)
    * @param createGroup  (optional)
    * @param repColonPassword  (optional)
    * @param profileGivenName  (optional)
    * @return RequestConfig
    */
    fun postAuthorizablesRequestConfig(authorizableId: kotlin.String, intermediatePath: kotlin.String, createUser: kotlin.String?, createGroup: kotlin.String?, repColonPassword: kotlin.String?, profileGivenName: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("authorizableId", listOf(authorizableId.toString()))
                put("intermediatePath", listOf(intermediatePath.toString()))
                if (createUser != null) {
                    put("createUser", listOf(createUser.toString()))
                }
                if (createGroup != null) {
                    put("createGroup", listOf(createGroup.toString()))
                }
                if (repColonPassword != null) {
                    put("rep:password", listOf(repColonPassword.toString()))
                }
                if (profileGivenName != null) {
                    put("profile/givenName", listOf(profileGivenName.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/libs/granite/security/post/authorizables",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param keyStorePassword  (optional)
    * @param keyStorePasswordAtTypeHint  (optional)
    * @param serviceRanking  (optional)
    * @param serviceRankingAtTypeHint  (optional)
    * @param idpHttpRedirect  (optional)
    * @param idpHttpRedirectAtTypeHint  (optional)
    * @param createUser  (optional)
    * @param createUserAtTypeHint  (optional)
    * @param defaultRedirectUrl  (optional)
    * @param defaultRedirectUrlAtTypeHint  (optional)
    * @param userIDAttribute  (optional)
    * @param userIDAttributeAtTypeHint  (optional)
    * @param defaultGroups  (optional)
    * @param defaultGroupsAtTypeHint  (optional)
    * @param idpCertAlias  (optional)
    * @param idpCertAliasAtTypeHint  (optional)
    * @param addGroupMemberships  (optional)
    * @param addGroupMembershipsAtTypeHint  (optional)
    * @param path  (optional)
    * @param pathAtTypeHint  (optional)
    * @param synchronizeAttributes  (optional)
    * @param synchronizeAttributesAtTypeHint  (optional)
    * @param clockTolerance  (optional)
    * @param clockToleranceAtTypeHint  (optional)
    * @param groupMembershipAttribute  (optional)
    * @param groupMembershipAttributeAtTypeHint  (optional)
    * @param idpUrl  (optional)
    * @param idpUrlAtTypeHint  (optional)
    * @param logoutUrl  (optional)
    * @param logoutUrlAtTypeHint  (optional)
    * @param serviceProviderEntityId  (optional)
    * @param serviceProviderEntityIdAtTypeHint  (optional)
    * @param assertionConsumerServiceURL  (optional)
    * @param assertionConsumerServiceURLAtTypeHint  (optional)
    * @param handleLogout  (optional)
    * @param handleLogoutAtTypeHint  (optional)
    * @param spPrivateKeyAlias  (optional)
    * @param spPrivateKeyAliasAtTypeHint  (optional)
    * @param useEncryption  (optional)
    * @param useEncryptionAtTypeHint  (optional)
    * @param nameIdFormat  (optional)
    * @param nameIdFormatAtTypeHint  (optional)
    * @param digestMethod  (optional)
    * @param digestMethodAtTypeHint  (optional)
    * @param signatureMethod  (optional)
    * @param signatureMethodAtTypeHint  (optional)
    * @param userIntermediatePath  (optional)
    * @param userIntermediatePathAtTypeHint  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword: kotlin.String?, keyStorePasswordAtTypeHint: kotlin.String?, serviceRanking: kotlin.Int?, serviceRankingAtTypeHint: kotlin.String?, idpHttpRedirect: kotlin.Boolean?, idpHttpRedirectAtTypeHint: kotlin.String?, createUser: kotlin.Boolean?, createUserAtTypeHint: kotlin.String?, defaultRedirectUrl: kotlin.String?, defaultRedirectUrlAtTypeHint: kotlin.String?, userIDAttribute: kotlin.String?, userIDAttributeAtTypeHint: kotlin.String?, defaultGroups: kotlin.collections.List<kotlin.String>?, defaultGroupsAtTypeHint: kotlin.String?, idpCertAlias: kotlin.String?, idpCertAliasAtTypeHint: kotlin.String?, addGroupMemberships: kotlin.Boolean?, addGroupMembershipsAtTypeHint: kotlin.String?, path: kotlin.collections.List<kotlin.String>?, pathAtTypeHint: kotlin.String?, synchronizeAttributes: kotlin.collections.List<kotlin.String>?, synchronizeAttributesAtTypeHint: kotlin.String?, clockTolerance: kotlin.Int?, clockToleranceAtTypeHint: kotlin.String?, groupMembershipAttribute: kotlin.String?, groupMembershipAttributeAtTypeHint: kotlin.String?, idpUrl: kotlin.String?, idpUrlAtTypeHint: kotlin.String?, logoutUrl: kotlin.String?, logoutUrlAtTypeHint: kotlin.String?, serviceProviderEntityId: kotlin.String?, serviceProviderEntityIdAtTypeHint: kotlin.String?, assertionConsumerServiceURL: kotlin.String?, assertionConsumerServiceURLAtTypeHint: kotlin.String?, handleLogout: kotlin.Boolean?, handleLogoutAtTypeHint: kotlin.String?, spPrivateKeyAlias: kotlin.String?, spPrivateKeyAliasAtTypeHint: kotlin.String?, useEncryption: kotlin.Boolean?, useEncryptionAtTypeHint: kotlin.String?, nameIdFormat: kotlin.String?, nameIdFormatAtTypeHint: kotlin.String?, digestMethod: kotlin.String?, digestMethodAtTypeHint: kotlin.String?, signatureMethod: kotlin.String?, signatureMethodAtTypeHint: kotlin.String?, userIntermediatePath: kotlin.String?, userIntermediatePathAtTypeHint: kotlin.String?) : Unit {
        val localVariableConfig = postConfigAdobeGraniteSamlAuthenticationHandlerRequestConfig(keyStorePassword = keyStorePassword, keyStorePasswordAtTypeHint = keyStorePasswordAtTypeHint, serviceRanking = serviceRanking, serviceRankingAtTypeHint = serviceRankingAtTypeHint, idpHttpRedirect = idpHttpRedirect, idpHttpRedirectAtTypeHint = idpHttpRedirectAtTypeHint, createUser = createUser, createUserAtTypeHint = createUserAtTypeHint, defaultRedirectUrl = defaultRedirectUrl, defaultRedirectUrlAtTypeHint = defaultRedirectUrlAtTypeHint, userIDAttribute = userIDAttribute, userIDAttributeAtTypeHint = userIDAttributeAtTypeHint, defaultGroups = defaultGroups, defaultGroupsAtTypeHint = defaultGroupsAtTypeHint, idpCertAlias = idpCertAlias, idpCertAliasAtTypeHint = idpCertAliasAtTypeHint, addGroupMemberships = addGroupMemberships, addGroupMembershipsAtTypeHint = addGroupMembershipsAtTypeHint, path = path, pathAtTypeHint = pathAtTypeHint, synchronizeAttributes = synchronizeAttributes, synchronizeAttributesAtTypeHint = synchronizeAttributesAtTypeHint, clockTolerance = clockTolerance, clockToleranceAtTypeHint = clockToleranceAtTypeHint, groupMembershipAttribute = groupMembershipAttribute, groupMembershipAttributeAtTypeHint = groupMembershipAttributeAtTypeHint, idpUrl = idpUrl, idpUrlAtTypeHint = idpUrlAtTypeHint, logoutUrl = logoutUrl, logoutUrlAtTypeHint = logoutUrlAtTypeHint, serviceProviderEntityId = serviceProviderEntityId, serviceProviderEntityIdAtTypeHint = serviceProviderEntityIdAtTypeHint, assertionConsumerServiceURL = assertionConsumerServiceURL, assertionConsumerServiceURLAtTypeHint = assertionConsumerServiceURLAtTypeHint, handleLogout = handleLogout, handleLogoutAtTypeHint = handleLogoutAtTypeHint, spPrivateKeyAlias = spPrivateKeyAlias, spPrivateKeyAliasAtTypeHint = spPrivateKeyAliasAtTypeHint, useEncryption = useEncryption, useEncryptionAtTypeHint = useEncryptionAtTypeHint, nameIdFormat = nameIdFormat, nameIdFormatAtTypeHint = nameIdFormatAtTypeHint, digestMethod = digestMethod, digestMethodAtTypeHint = digestMethodAtTypeHint, signatureMethod = signatureMethod, signatureMethodAtTypeHint = signatureMethodAtTypeHint, userIntermediatePath = userIntermediatePath, userIntermediatePathAtTypeHint = userIntermediatePathAtTypeHint)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigAdobeGraniteSamlAuthenticationHandler
    *
    * @param keyStorePassword  (optional)
    * @param keyStorePasswordAtTypeHint  (optional)
    * @param serviceRanking  (optional)
    * @param serviceRankingAtTypeHint  (optional)
    * @param idpHttpRedirect  (optional)
    * @param idpHttpRedirectAtTypeHint  (optional)
    * @param createUser  (optional)
    * @param createUserAtTypeHint  (optional)
    * @param defaultRedirectUrl  (optional)
    * @param defaultRedirectUrlAtTypeHint  (optional)
    * @param userIDAttribute  (optional)
    * @param userIDAttributeAtTypeHint  (optional)
    * @param defaultGroups  (optional)
    * @param defaultGroupsAtTypeHint  (optional)
    * @param idpCertAlias  (optional)
    * @param idpCertAliasAtTypeHint  (optional)
    * @param addGroupMemberships  (optional)
    * @param addGroupMembershipsAtTypeHint  (optional)
    * @param path  (optional)
    * @param pathAtTypeHint  (optional)
    * @param synchronizeAttributes  (optional)
    * @param synchronizeAttributesAtTypeHint  (optional)
    * @param clockTolerance  (optional)
    * @param clockToleranceAtTypeHint  (optional)
    * @param groupMembershipAttribute  (optional)
    * @param groupMembershipAttributeAtTypeHint  (optional)
    * @param idpUrl  (optional)
    * @param idpUrlAtTypeHint  (optional)
    * @param logoutUrl  (optional)
    * @param logoutUrlAtTypeHint  (optional)
    * @param serviceProviderEntityId  (optional)
    * @param serviceProviderEntityIdAtTypeHint  (optional)
    * @param assertionConsumerServiceURL  (optional)
    * @param assertionConsumerServiceURLAtTypeHint  (optional)
    * @param handleLogout  (optional)
    * @param handleLogoutAtTypeHint  (optional)
    * @param spPrivateKeyAlias  (optional)
    * @param spPrivateKeyAliasAtTypeHint  (optional)
    * @param useEncryption  (optional)
    * @param useEncryptionAtTypeHint  (optional)
    * @param nameIdFormat  (optional)
    * @param nameIdFormatAtTypeHint  (optional)
    * @param digestMethod  (optional)
    * @param digestMethodAtTypeHint  (optional)
    * @param signatureMethod  (optional)
    * @param signatureMethodAtTypeHint  (optional)
    * @param userIntermediatePath  (optional)
    * @param userIntermediatePathAtTypeHint  (optional)
    * @return RequestConfig
    */
    fun postConfigAdobeGraniteSamlAuthenticationHandlerRequestConfig(keyStorePassword: kotlin.String?, keyStorePasswordAtTypeHint: kotlin.String?, serviceRanking: kotlin.Int?, serviceRankingAtTypeHint: kotlin.String?, idpHttpRedirect: kotlin.Boolean?, idpHttpRedirectAtTypeHint: kotlin.String?, createUser: kotlin.Boolean?, createUserAtTypeHint: kotlin.String?, defaultRedirectUrl: kotlin.String?, defaultRedirectUrlAtTypeHint: kotlin.String?, userIDAttribute: kotlin.String?, userIDAttributeAtTypeHint: kotlin.String?, defaultGroups: kotlin.collections.List<kotlin.String>?, defaultGroupsAtTypeHint: kotlin.String?, idpCertAlias: kotlin.String?, idpCertAliasAtTypeHint: kotlin.String?, addGroupMemberships: kotlin.Boolean?, addGroupMembershipsAtTypeHint: kotlin.String?, path: kotlin.collections.List<kotlin.String>?, pathAtTypeHint: kotlin.String?, synchronizeAttributes: kotlin.collections.List<kotlin.String>?, synchronizeAttributesAtTypeHint: kotlin.String?, clockTolerance: kotlin.Int?, clockToleranceAtTypeHint: kotlin.String?, groupMembershipAttribute: kotlin.String?, groupMembershipAttributeAtTypeHint: kotlin.String?, idpUrl: kotlin.String?, idpUrlAtTypeHint: kotlin.String?, logoutUrl: kotlin.String?, logoutUrlAtTypeHint: kotlin.String?, serviceProviderEntityId: kotlin.String?, serviceProviderEntityIdAtTypeHint: kotlin.String?, assertionConsumerServiceURL: kotlin.String?, assertionConsumerServiceURLAtTypeHint: kotlin.String?, handleLogout: kotlin.Boolean?, handleLogoutAtTypeHint: kotlin.String?, spPrivateKeyAlias: kotlin.String?, spPrivateKeyAliasAtTypeHint: kotlin.String?, useEncryption: kotlin.Boolean?, useEncryptionAtTypeHint: kotlin.String?, nameIdFormat: kotlin.String?, nameIdFormatAtTypeHint: kotlin.String?, digestMethod: kotlin.String?, digestMethodAtTypeHint: kotlin.String?, signatureMethod: kotlin.String?, signatureMethodAtTypeHint: kotlin.String?, userIntermediatePath: kotlin.String?, userIntermediatePathAtTypeHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (keyStorePassword != null) {
                    put("keyStorePassword", listOf(keyStorePassword.toString()))
                }
                if (keyStorePasswordAtTypeHint != null) {
                    put("keyStorePassword@TypeHint", listOf(keyStorePasswordAtTypeHint.toString()))
                }
                if (serviceRanking != null) {
                    put("service.ranking", listOf(serviceRanking.toString()))
                }
                if (serviceRankingAtTypeHint != null) {
                    put("service.ranking@TypeHint", listOf(serviceRankingAtTypeHint.toString()))
                }
                if (idpHttpRedirect != null) {
                    put("idpHttpRedirect", listOf(idpHttpRedirect.toString()))
                }
                if (idpHttpRedirectAtTypeHint != null) {
                    put("idpHttpRedirect@TypeHint", listOf(idpHttpRedirectAtTypeHint.toString()))
                }
                if (createUser != null) {
                    put("createUser", listOf(createUser.toString()))
                }
                if (createUserAtTypeHint != null) {
                    put("createUser@TypeHint", listOf(createUserAtTypeHint.toString()))
                }
                if (defaultRedirectUrl != null) {
                    put("defaultRedirectUrl", listOf(defaultRedirectUrl.toString()))
                }
                if (defaultRedirectUrlAtTypeHint != null) {
                    put("defaultRedirectUrl@TypeHint", listOf(defaultRedirectUrlAtTypeHint.toString()))
                }
                if (userIDAttribute != null) {
                    put("userIDAttribute", listOf(userIDAttribute.toString()))
                }
                if (userIDAttributeAtTypeHint != null) {
                    put("userIDAttribute@TypeHint", listOf(userIDAttributeAtTypeHint.toString()))
                }
                if (defaultGroups != null) {
                    put("defaultGroups", toMultiValue(defaultGroups.toList(), "multi"))
                }
                if (defaultGroupsAtTypeHint != null) {
                    put("defaultGroups@TypeHint", listOf(defaultGroupsAtTypeHint.toString()))
                }
                if (idpCertAlias != null) {
                    put("idpCertAlias", listOf(idpCertAlias.toString()))
                }
                if (idpCertAliasAtTypeHint != null) {
                    put("idpCertAlias@TypeHint", listOf(idpCertAliasAtTypeHint.toString()))
                }
                if (addGroupMemberships != null) {
                    put("addGroupMemberships", listOf(addGroupMemberships.toString()))
                }
                if (addGroupMembershipsAtTypeHint != null) {
                    put("addGroupMemberships@TypeHint", listOf(addGroupMembershipsAtTypeHint.toString()))
                }
                if (path != null) {
                    put("path", toMultiValue(path.toList(), "multi"))
                }
                if (pathAtTypeHint != null) {
                    put("path@TypeHint", listOf(pathAtTypeHint.toString()))
                }
                if (synchronizeAttributes != null) {
                    put("synchronizeAttributes", toMultiValue(synchronizeAttributes.toList(), "multi"))
                }
                if (synchronizeAttributesAtTypeHint != null) {
                    put("synchronizeAttributes@TypeHint", listOf(synchronizeAttributesAtTypeHint.toString()))
                }
                if (clockTolerance != null) {
                    put("clockTolerance", listOf(clockTolerance.toString()))
                }
                if (clockToleranceAtTypeHint != null) {
                    put("clockTolerance@TypeHint", listOf(clockToleranceAtTypeHint.toString()))
                }
                if (groupMembershipAttribute != null) {
                    put("groupMembershipAttribute", listOf(groupMembershipAttribute.toString()))
                }
                if (groupMembershipAttributeAtTypeHint != null) {
                    put("groupMembershipAttribute@TypeHint", listOf(groupMembershipAttributeAtTypeHint.toString()))
                }
                if (idpUrl != null) {
                    put("idpUrl", listOf(idpUrl.toString()))
                }
                if (idpUrlAtTypeHint != null) {
                    put("idpUrl@TypeHint", listOf(idpUrlAtTypeHint.toString()))
                }
                if (logoutUrl != null) {
                    put("logoutUrl", listOf(logoutUrl.toString()))
                }
                if (logoutUrlAtTypeHint != null) {
                    put("logoutUrl@TypeHint", listOf(logoutUrlAtTypeHint.toString()))
                }
                if (serviceProviderEntityId != null) {
                    put("serviceProviderEntityId", listOf(serviceProviderEntityId.toString()))
                }
                if (serviceProviderEntityIdAtTypeHint != null) {
                    put("serviceProviderEntityId@TypeHint", listOf(serviceProviderEntityIdAtTypeHint.toString()))
                }
                if (assertionConsumerServiceURL != null) {
                    put("assertionConsumerServiceURL", listOf(assertionConsumerServiceURL.toString()))
                }
                if (assertionConsumerServiceURLAtTypeHint != null) {
                    put("assertionConsumerServiceURL@TypeHint", listOf(assertionConsumerServiceURLAtTypeHint.toString()))
                }
                if (handleLogout != null) {
                    put("handleLogout", listOf(handleLogout.toString()))
                }
                if (handleLogoutAtTypeHint != null) {
                    put("handleLogout@TypeHint", listOf(handleLogoutAtTypeHint.toString()))
                }
                if (spPrivateKeyAlias != null) {
                    put("spPrivateKeyAlias", listOf(spPrivateKeyAlias.toString()))
                }
                if (spPrivateKeyAliasAtTypeHint != null) {
                    put("spPrivateKeyAlias@TypeHint", listOf(spPrivateKeyAliasAtTypeHint.toString()))
                }
                if (useEncryption != null) {
                    put("useEncryption", listOf(useEncryption.toString()))
                }
                if (useEncryptionAtTypeHint != null) {
                    put("useEncryption@TypeHint", listOf(useEncryptionAtTypeHint.toString()))
                }
                if (nameIdFormat != null) {
                    put("nameIdFormat", listOf(nameIdFormat.toString()))
                }
                if (nameIdFormatAtTypeHint != null) {
                    put("nameIdFormat@TypeHint", listOf(nameIdFormatAtTypeHint.toString()))
                }
                if (digestMethod != null) {
                    put("digestMethod", listOf(digestMethod.toString()))
                }
                if (digestMethodAtTypeHint != null) {
                    put("digestMethod@TypeHint", listOf(digestMethodAtTypeHint.toString()))
                }
                if (signatureMethod != null) {
                    put("signatureMethod", listOf(signatureMethod.toString()))
                }
                if (signatureMethodAtTypeHint != null) {
                    put("signatureMethod@TypeHint", listOf(signatureMethodAtTypeHint.toString()))
                }
                if (userIntermediatePath != null) {
                    put("userIntermediatePath", listOf(userIntermediatePath.toString()))
                }
                if (userIntermediatePathAtTypeHint != null) {
                    put("userIntermediatePath@TypeHint", listOf(userIntermediatePathAtTypeHint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param orgApacheFelixHttpsNio  (optional)
    * @param orgApacheFelixHttpsNioAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystore  (optional)
    * @param orgApacheFelixHttpsKeystoreAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystorePassword  (optional)
    * @param orgApacheFelixHttpsKeystorePasswordAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystoreKey  (optional)
    * @param orgApacheFelixHttpsKeystoreKeyAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystoreKeyPassword  (optional)
    * @param orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint  (optional)
    * @param orgApacheFelixHttpsTruststore  (optional)
    * @param orgApacheFelixHttpsTruststoreAtTypeHint  (optional)
    * @param orgApacheFelixHttpsTruststorePassword  (optional)
    * @param orgApacheFelixHttpsTruststorePasswordAtTypeHint  (optional)
    * @param orgApacheFelixHttpsClientcertificate  (optional)
    * @param orgApacheFelixHttpsClientcertificateAtTypeHint  (optional)
    * @param orgApacheFelixHttpsEnable  (optional)
    * @param orgApacheFelixHttpsEnableAtTypeHint  (optional)
    * @param orgOsgiServiceHttpPortSecure  (optional)
    * @param orgOsgiServiceHttpPortSecureAtTypeHint  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio: kotlin.Boolean?, orgApacheFelixHttpsNioAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystore: kotlin.String?, orgApacheFelixHttpsKeystoreAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystorePassword: kotlin.String?, orgApacheFelixHttpsKeystorePasswordAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystoreKey: kotlin.String?, orgApacheFelixHttpsKeystoreKeyAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystoreKeyPassword: kotlin.String?, orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint: kotlin.String?, orgApacheFelixHttpsTruststore: kotlin.String?, orgApacheFelixHttpsTruststoreAtTypeHint: kotlin.String?, orgApacheFelixHttpsTruststorePassword: kotlin.String?, orgApacheFelixHttpsTruststorePasswordAtTypeHint: kotlin.String?, orgApacheFelixHttpsClientcertificate: kotlin.String?, orgApacheFelixHttpsClientcertificateAtTypeHint: kotlin.String?, orgApacheFelixHttpsEnable: kotlin.Boolean?, orgApacheFelixHttpsEnableAtTypeHint: kotlin.String?, orgOsgiServiceHttpPortSecure: kotlin.String?, orgOsgiServiceHttpPortSecureAtTypeHint: kotlin.String?) : Unit {
        val localVariableConfig = postConfigApacheFelixJettyBasedHttpServiceRequestConfig(orgApacheFelixHttpsNio = orgApacheFelixHttpsNio, orgApacheFelixHttpsNioAtTypeHint = orgApacheFelixHttpsNioAtTypeHint, orgApacheFelixHttpsKeystore = orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystoreAtTypeHint = orgApacheFelixHttpsKeystoreAtTypeHint, orgApacheFelixHttpsKeystorePassword = orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePasswordAtTypeHint = orgApacheFelixHttpsKeystorePasswordAtTypeHint, orgApacheFelixHttpsKeystoreKey = orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKeyAtTypeHint = orgApacheFelixHttpsKeystoreKeyAtTypeHint, orgApacheFelixHttpsKeystoreKeyPassword = orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint = orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint, orgApacheFelixHttpsTruststore = orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststoreAtTypeHint = orgApacheFelixHttpsTruststoreAtTypeHint, orgApacheFelixHttpsTruststorePassword = orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePasswordAtTypeHint = orgApacheFelixHttpsTruststorePasswordAtTypeHint, orgApacheFelixHttpsClientcertificate = orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificateAtTypeHint = orgApacheFelixHttpsClientcertificateAtTypeHint, orgApacheFelixHttpsEnable = orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnableAtTypeHint = orgApacheFelixHttpsEnableAtTypeHint, orgOsgiServiceHttpPortSecure = orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecureAtTypeHint = orgOsgiServiceHttpPortSecureAtTypeHint)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigApacheFelixJettyBasedHttpService
    *
    * @param orgApacheFelixHttpsNio  (optional)
    * @param orgApacheFelixHttpsNioAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystore  (optional)
    * @param orgApacheFelixHttpsKeystoreAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystorePassword  (optional)
    * @param orgApacheFelixHttpsKeystorePasswordAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystoreKey  (optional)
    * @param orgApacheFelixHttpsKeystoreKeyAtTypeHint  (optional)
    * @param orgApacheFelixHttpsKeystoreKeyPassword  (optional)
    * @param orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint  (optional)
    * @param orgApacheFelixHttpsTruststore  (optional)
    * @param orgApacheFelixHttpsTruststoreAtTypeHint  (optional)
    * @param orgApacheFelixHttpsTruststorePassword  (optional)
    * @param orgApacheFelixHttpsTruststorePasswordAtTypeHint  (optional)
    * @param orgApacheFelixHttpsClientcertificate  (optional)
    * @param orgApacheFelixHttpsClientcertificateAtTypeHint  (optional)
    * @param orgApacheFelixHttpsEnable  (optional)
    * @param orgApacheFelixHttpsEnableAtTypeHint  (optional)
    * @param orgOsgiServiceHttpPortSecure  (optional)
    * @param orgOsgiServiceHttpPortSecureAtTypeHint  (optional)
    * @return RequestConfig
    */
    fun postConfigApacheFelixJettyBasedHttpServiceRequestConfig(orgApacheFelixHttpsNio: kotlin.Boolean?, orgApacheFelixHttpsNioAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystore: kotlin.String?, orgApacheFelixHttpsKeystoreAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystorePassword: kotlin.String?, orgApacheFelixHttpsKeystorePasswordAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystoreKey: kotlin.String?, orgApacheFelixHttpsKeystoreKeyAtTypeHint: kotlin.String?, orgApacheFelixHttpsKeystoreKeyPassword: kotlin.String?, orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint: kotlin.String?, orgApacheFelixHttpsTruststore: kotlin.String?, orgApacheFelixHttpsTruststoreAtTypeHint: kotlin.String?, orgApacheFelixHttpsTruststorePassword: kotlin.String?, orgApacheFelixHttpsTruststorePasswordAtTypeHint: kotlin.String?, orgApacheFelixHttpsClientcertificate: kotlin.String?, orgApacheFelixHttpsClientcertificateAtTypeHint: kotlin.String?, orgApacheFelixHttpsEnable: kotlin.Boolean?, orgApacheFelixHttpsEnableAtTypeHint: kotlin.String?, orgOsgiServiceHttpPortSecure: kotlin.String?, orgOsgiServiceHttpPortSecureAtTypeHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (orgApacheFelixHttpsNio != null) {
                    put("org.apache.felix.https.nio", listOf(orgApacheFelixHttpsNio.toString()))
                }
                if (orgApacheFelixHttpsNioAtTypeHint != null) {
                    put("org.apache.felix.https.nio@TypeHint", listOf(orgApacheFelixHttpsNioAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsKeystore != null) {
                    put("org.apache.felix.https.keystore", listOf(orgApacheFelixHttpsKeystore.toString()))
                }
                if (orgApacheFelixHttpsKeystoreAtTypeHint != null) {
                    put("org.apache.felix.https.keystore@TypeHint", listOf(orgApacheFelixHttpsKeystoreAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsKeystorePassword != null) {
                    put("org.apache.felix.https.keystore.password", listOf(orgApacheFelixHttpsKeystorePassword.toString()))
                }
                if (orgApacheFelixHttpsKeystorePasswordAtTypeHint != null) {
                    put("org.apache.felix.https.keystore.password@TypeHint", listOf(orgApacheFelixHttpsKeystorePasswordAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsKeystoreKey != null) {
                    put("org.apache.felix.https.keystore.key", listOf(orgApacheFelixHttpsKeystoreKey.toString()))
                }
                if (orgApacheFelixHttpsKeystoreKeyAtTypeHint != null) {
                    put("org.apache.felix.https.keystore.key@TypeHint", listOf(orgApacheFelixHttpsKeystoreKeyAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsKeystoreKeyPassword != null) {
                    put("org.apache.felix.https.keystore.key.password", listOf(orgApacheFelixHttpsKeystoreKeyPassword.toString()))
                }
                if (orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint != null) {
                    put("org.apache.felix.https.keystore.key.password@TypeHint", listOf(orgApacheFelixHttpsKeystoreKeyPasswordAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsTruststore != null) {
                    put("org.apache.felix.https.truststore", listOf(orgApacheFelixHttpsTruststore.toString()))
                }
                if (orgApacheFelixHttpsTruststoreAtTypeHint != null) {
                    put("org.apache.felix.https.truststore@TypeHint", listOf(orgApacheFelixHttpsTruststoreAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsTruststorePassword != null) {
                    put("org.apache.felix.https.truststore.password", listOf(orgApacheFelixHttpsTruststorePassword.toString()))
                }
                if (orgApacheFelixHttpsTruststorePasswordAtTypeHint != null) {
                    put("org.apache.felix.https.truststore.password@TypeHint", listOf(orgApacheFelixHttpsTruststorePasswordAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsClientcertificate != null) {
                    put("org.apache.felix.https.clientcertificate", listOf(orgApacheFelixHttpsClientcertificate.toString()))
                }
                if (orgApacheFelixHttpsClientcertificateAtTypeHint != null) {
                    put("org.apache.felix.https.clientcertificate@TypeHint", listOf(orgApacheFelixHttpsClientcertificateAtTypeHint.toString()))
                }
                if (orgApacheFelixHttpsEnable != null) {
                    put("org.apache.felix.https.enable", listOf(orgApacheFelixHttpsEnable.toString()))
                }
                if (orgApacheFelixHttpsEnableAtTypeHint != null) {
                    put("org.apache.felix.https.enable@TypeHint", listOf(orgApacheFelixHttpsEnableAtTypeHint.toString()))
                }
                if (orgOsgiServiceHttpPortSecure != null) {
                    put("org.osgi.service.http.port.secure", listOf(orgOsgiServiceHttpPortSecure.toString()))
                }
                if (orgOsgiServiceHttpPortSecureAtTypeHint != null) {
                    put("org.osgi.service.http.port.secure@TypeHint", listOf(orgOsgiServiceHttpPortSecureAtTypeHint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/org.apache.felix.http",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param proxyHost  (optional)
    * @param proxyHostAtTypeHint  (optional)
    * @param proxyPort  (optional)
    * @param proxyPortAtTypeHint  (optional)
    * @param proxyExceptions  (optional)
    * @param proxyExceptionsAtTypeHint  (optional)
    * @param proxyEnabled  (optional)
    * @param proxyEnabledAtTypeHint  (optional)
    * @param proxyUser  (optional)
    * @param proxyUserAtTypeHint  (optional)
    * @param proxyPassword  (optional)
    * @param proxyPasswordAtTypeHint  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigApacheHttpComponentsProxyConfiguration(proxyHost: kotlin.String?, proxyHostAtTypeHint: kotlin.String?, proxyPort: kotlin.Int?, proxyPortAtTypeHint: kotlin.String?, proxyExceptions: kotlin.collections.List<kotlin.String>?, proxyExceptionsAtTypeHint: kotlin.String?, proxyEnabled: kotlin.Boolean?, proxyEnabledAtTypeHint: kotlin.String?, proxyUser: kotlin.String?, proxyUserAtTypeHint: kotlin.String?, proxyPassword: kotlin.String?, proxyPasswordAtTypeHint: kotlin.String?) : Unit {
        val localVariableConfig = postConfigApacheHttpComponentsProxyConfigurationRequestConfig(proxyHost = proxyHost, proxyHostAtTypeHint = proxyHostAtTypeHint, proxyPort = proxyPort, proxyPortAtTypeHint = proxyPortAtTypeHint, proxyExceptions = proxyExceptions, proxyExceptionsAtTypeHint = proxyExceptionsAtTypeHint, proxyEnabled = proxyEnabled, proxyEnabledAtTypeHint = proxyEnabledAtTypeHint, proxyUser = proxyUser, proxyUserAtTypeHint = proxyUserAtTypeHint, proxyPassword = proxyPassword, proxyPasswordAtTypeHint = proxyPasswordAtTypeHint)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigApacheHttpComponentsProxyConfiguration
    *
    * @param proxyHost  (optional)
    * @param proxyHostAtTypeHint  (optional)
    * @param proxyPort  (optional)
    * @param proxyPortAtTypeHint  (optional)
    * @param proxyExceptions  (optional)
    * @param proxyExceptionsAtTypeHint  (optional)
    * @param proxyEnabled  (optional)
    * @param proxyEnabledAtTypeHint  (optional)
    * @param proxyUser  (optional)
    * @param proxyUserAtTypeHint  (optional)
    * @param proxyPassword  (optional)
    * @param proxyPasswordAtTypeHint  (optional)
    * @return RequestConfig
    */
    fun postConfigApacheHttpComponentsProxyConfigurationRequestConfig(proxyHost: kotlin.String?, proxyHostAtTypeHint: kotlin.String?, proxyPort: kotlin.Int?, proxyPortAtTypeHint: kotlin.String?, proxyExceptions: kotlin.collections.List<kotlin.String>?, proxyExceptionsAtTypeHint: kotlin.String?, proxyEnabled: kotlin.Boolean?, proxyEnabledAtTypeHint: kotlin.String?, proxyUser: kotlin.String?, proxyUserAtTypeHint: kotlin.String?, proxyPassword: kotlin.String?, proxyPasswordAtTypeHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (proxyHost != null) {
                    put("proxy.host", listOf(proxyHost.toString()))
                }
                if (proxyHostAtTypeHint != null) {
                    put("proxy.host@TypeHint", listOf(proxyHostAtTypeHint.toString()))
                }
                if (proxyPort != null) {
                    put("proxy.port", listOf(proxyPort.toString()))
                }
                if (proxyPortAtTypeHint != null) {
                    put("proxy.port@TypeHint", listOf(proxyPortAtTypeHint.toString()))
                }
                if (proxyExceptions != null) {
                    put("proxy.exceptions", toMultiValue(proxyExceptions.toList(), "multi"))
                }
                if (proxyExceptionsAtTypeHint != null) {
                    put("proxy.exceptions@TypeHint", listOf(proxyExceptionsAtTypeHint.toString()))
                }
                if (proxyEnabled != null) {
                    put("proxy.enabled", listOf(proxyEnabled.toString()))
                }
                if (proxyEnabledAtTypeHint != null) {
                    put("proxy.enabled@TypeHint", listOf(proxyEnabledAtTypeHint.toString()))
                }
                if (proxyUser != null) {
                    put("proxy.user", listOf(proxyUser.toString()))
                }
                if (proxyUserAtTypeHint != null) {
                    put("proxy.user@TypeHint", listOf(proxyUserAtTypeHint.toString()))
                }
                if (proxyPassword != null) {
                    put("proxy.password", listOf(proxyPassword.toString()))
                }
                if (proxyPasswordAtTypeHint != null) {
                    put("proxy.password@TypeHint", listOf(proxyPasswordAtTypeHint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/org.apache.http.proxyconfigurator.config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param alias  (optional)
    * @param aliasAtTypeHint  (optional)
    * @param davCreateAbsoluteUri  (optional)
    * @param davCreateAbsoluteUriAtTypeHint  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigApacheSlingDavExServlet(alias: kotlin.String?, aliasAtTypeHint: kotlin.String?, davCreateAbsoluteUri: kotlin.Boolean?, davCreateAbsoluteUriAtTypeHint: kotlin.String?) : Unit {
        val localVariableConfig = postConfigApacheSlingDavExServletRequestConfig(alias = alias, aliasAtTypeHint = aliasAtTypeHint, davCreateAbsoluteUri = davCreateAbsoluteUri, davCreateAbsoluteUriAtTypeHint = davCreateAbsoluteUriAtTypeHint)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigApacheSlingDavExServlet
    *
    * @param alias  (optional)
    * @param aliasAtTypeHint  (optional)
    * @param davCreateAbsoluteUri  (optional)
    * @param davCreateAbsoluteUriAtTypeHint  (optional)
    * @return RequestConfig
    */
    fun postConfigApacheSlingDavExServletRequestConfig(alias: kotlin.String?, aliasAtTypeHint: kotlin.String?, davCreateAbsoluteUri: kotlin.Boolean?, davCreateAbsoluteUriAtTypeHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (alias != null) {
                    put("alias", listOf(alias.toString()))
                }
                if (aliasAtTypeHint != null) {
                    put("alias@TypeHint", listOf(aliasAtTypeHint.toString()))
                }
                if (davCreateAbsoluteUri != null) {
                    put("dav.create-absolute-uri", listOf(davCreateAbsoluteUri.toString()))
                }
                if (davCreateAbsoluteUriAtTypeHint != null) {
                    put("dav.create-absolute-uri@TypeHint", listOf(davCreateAbsoluteUriAtTypeHint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param jsonMaximumresults  (optional)
    * @param jsonMaximumresultsAtTypeHint  (optional)
    * @param enableHtml  (optional)
    * @param enableHtmlAtTypeHint  (optional)
    * @param enableTxt  (optional)
    * @param enableTxtAtTypeHint  (optional)
    * @param enableXml  (optional)
    * @param enableXmlAtTypeHint  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigApacheSlingGetServlet(jsonMaximumresults: kotlin.String?, jsonMaximumresultsAtTypeHint: kotlin.String?, enableHtml: kotlin.Boolean?, enableHtmlAtTypeHint: kotlin.String?, enableTxt: kotlin.Boolean?, enableTxtAtTypeHint: kotlin.String?, enableXml: kotlin.Boolean?, enableXmlAtTypeHint: kotlin.String?) : Unit {
        val localVariableConfig = postConfigApacheSlingGetServletRequestConfig(jsonMaximumresults = jsonMaximumresults, jsonMaximumresultsAtTypeHint = jsonMaximumresultsAtTypeHint, enableHtml = enableHtml, enableHtmlAtTypeHint = enableHtmlAtTypeHint, enableTxt = enableTxt, enableTxtAtTypeHint = enableTxtAtTypeHint, enableXml = enableXml, enableXmlAtTypeHint = enableXmlAtTypeHint)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigApacheSlingGetServlet
    *
    * @param jsonMaximumresults  (optional)
    * @param jsonMaximumresultsAtTypeHint  (optional)
    * @param enableHtml  (optional)
    * @param enableHtmlAtTypeHint  (optional)
    * @param enableTxt  (optional)
    * @param enableTxtAtTypeHint  (optional)
    * @param enableXml  (optional)
    * @param enableXmlAtTypeHint  (optional)
    * @return RequestConfig
    */
    fun postConfigApacheSlingGetServletRequestConfig(jsonMaximumresults: kotlin.String?, jsonMaximumresultsAtTypeHint: kotlin.String?, enableHtml: kotlin.Boolean?, enableHtmlAtTypeHint: kotlin.String?, enableTxt: kotlin.Boolean?, enableTxtAtTypeHint: kotlin.String?, enableXml: kotlin.Boolean?, enableXmlAtTypeHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (jsonMaximumresults != null) {
                    put("json.maximumresults", listOf(jsonMaximumresults.toString()))
                }
                if (jsonMaximumresultsAtTypeHint != null) {
                    put("json.maximumresults@TypeHint", listOf(jsonMaximumresultsAtTypeHint.toString()))
                }
                if (enableHtml != null) {
                    put("enable.html", listOf(enableHtml.toString()))
                }
                if (enableHtmlAtTypeHint != null) {
                    put("enable.html@TypeHint", listOf(enableHtmlAtTypeHint.toString()))
                }
                if (enableTxt != null) {
                    put("enable.txt", listOf(enableTxt.toString()))
                }
                if (enableTxtAtTypeHint != null) {
                    put("enable.txt@TypeHint", listOf(enableTxtAtTypeHint.toString()))
                }
                if (enableXml != null) {
                    put("enable.xml", listOf(enableXml.toString()))
                }
                if (enableXmlAtTypeHint != null) {
                    put("enable.xml@TypeHint", listOf(enableXmlAtTypeHint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param allowEmpty  (optional)
    * @param allowEmptyAtTypeHint  (optional)
    * @param allowHosts  (optional)
    * @param allowHostsAtTypeHint  (optional)
    * @param allowHostsRegexp  (optional)
    * @param allowHostsRegexpAtTypeHint  (optional)
    * @param filterMethods  (optional)
    * @param filterMethodsAtTypeHint  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigApacheSlingReferrerFilter(allowEmpty: kotlin.Boolean?, allowEmptyAtTypeHint: kotlin.String?, allowHosts: kotlin.String?, allowHostsAtTypeHint: kotlin.String?, allowHostsRegexp: kotlin.String?, allowHostsRegexpAtTypeHint: kotlin.String?, filterMethods: kotlin.String?, filterMethodsAtTypeHint: kotlin.String?) : Unit {
        val localVariableConfig = postConfigApacheSlingReferrerFilterRequestConfig(allowEmpty = allowEmpty, allowEmptyAtTypeHint = allowEmptyAtTypeHint, allowHosts = allowHosts, allowHostsAtTypeHint = allowHostsAtTypeHint, allowHostsRegexp = allowHostsRegexp, allowHostsRegexpAtTypeHint = allowHostsRegexpAtTypeHint, filterMethods = filterMethods, filterMethodsAtTypeHint = filterMethodsAtTypeHint)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigApacheSlingReferrerFilter
    *
    * @param allowEmpty  (optional)
    * @param allowEmptyAtTypeHint  (optional)
    * @param allowHosts  (optional)
    * @param allowHostsAtTypeHint  (optional)
    * @param allowHostsRegexp  (optional)
    * @param allowHostsRegexpAtTypeHint  (optional)
    * @param filterMethods  (optional)
    * @param filterMethodsAtTypeHint  (optional)
    * @return RequestConfig
    */
    fun postConfigApacheSlingReferrerFilterRequestConfig(allowEmpty: kotlin.Boolean?, allowEmptyAtTypeHint: kotlin.String?, allowHosts: kotlin.String?, allowHostsAtTypeHint: kotlin.String?, allowHostsRegexp: kotlin.String?, allowHostsRegexpAtTypeHint: kotlin.String?, filterMethods: kotlin.String?, filterMethodsAtTypeHint: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (allowEmpty != null) {
                    put("allow.empty", listOf(allowEmpty.toString()))
                }
                if (allowEmptyAtTypeHint != null) {
                    put("allow.empty@TypeHint", listOf(allowEmptyAtTypeHint.toString()))
                }
                if (allowHosts != null) {
                    put("allow.hosts", listOf(allowHosts.toString()))
                }
                if (allowHostsAtTypeHint != null) {
                    put("allow.hosts@TypeHint", listOf(allowHostsAtTypeHint.toString()))
                }
                if (allowHostsRegexp != null) {
                    put("allow.hosts.regexp", listOf(allowHostsRegexp.toString()))
                }
                if (allowHostsRegexpAtTypeHint != null) {
                    put("allow.hosts.regexp@TypeHint", listOf(allowHostsRegexpAtTypeHint.toString()))
                }
                if (filterMethods != null) {
                    put("filter.methods", listOf(filterMethods.toString()))
                }
                if (filterMethodsAtTypeHint != null) {
                    put("filter.methods@TypeHint", listOf(filterMethodsAtTypeHint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param configNodeName  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postConfigProperty(configNodeName: kotlin.String) : Unit {
        val localVariableConfig = postConfigPropertyRequestConfig(configNodeName = configNodeName)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postConfigProperty
    *
    * @param configNodeName  
    * @return RequestConfig
    */
    fun postConfigPropertyRequestConfig(configNodeName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/apps/system/config/{configNodeName}".replace("{"+"configNodeName"+"}", "$configNodeName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @param colonOperation  (optional)
    * @param deleteAuthorizable  (optional)
    * @param file  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postNode(path: kotlin.String, name: kotlin.String, colonOperation: kotlin.String?, deleteAuthorizable: kotlin.String?, file: java.io.File?) : Unit {
        val localVariableConfig = postNodeRequestConfig(path = path, name = name, colonOperation = colonOperation, deleteAuthorizable = deleteAuthorizable, file = file)

        val localVarResponse = request<Map<String, Any?>, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postNode
    *
    * @param path  
    * @param name  
    * @param colonOperation  (optional)
    * @param deleteAuthorizable  (optional)
    * @param file  (optional)
    * @return RequestConfig
    */
    fun postNodeRequestConfig(path: kotlin.String, name: kotlin.String, colonOperation: kotlin.String?, deleteAuthorizable: kotlin.String?, file: java.io.File?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("file" to file)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (colonOperation != null) {
                    put(":operation", listOf(colonOperation.toString()))
                }
                if (deleteAuthorizable != null) {
                    put("deleteAuthorizable", listOf(deleteAuthorizable.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{path}/{name}".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param name  
    * @param addMembers  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postNodeRw(path: kotlin.String, name: kotlin.String, addMembers: kotlin.String?) : Unit {
        val localVariableConfig = postNodeRwRequestConfig(path = path, name = name, addMembers = addMembers)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postNodeRw
    *
    * @param path  
    * @param name  
    * @param addMembers  (optional)
    * @return RequestConfig
    */
    fun postNodeRwRequestConfig(path: kotlin.String, name: kotlin.String, addMembers: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (addMembers != null) {
                    put("addMembers", listOf(addMembers.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{path}/{name}.rw.html".replace("{"+"path"+"}", "$path").replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param jcrColonPrimaryType  
    * @param colonName  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postPath(path: kotlin.String, jcrColonPrimaryType: kotlin.String, colonName: kotlin.String) : Unit {
        val localVariableConfig = postPathRequestConfig(path = path, jcrColonPrimaryType = jcrColonPrimaryType, colonName = colonName)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postPath
    *
    * @param path  
    * @param jcrColonPrimaryType  
    * @param colonName  
    * @return RequestConfig
    */
    fun postPathRequestConfig(path: kotlin.String, jcrColonPrimaryType: kotlin.String, colonName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("jcr:primaryType", listOf(jcrColonPrimaryType.toString()))
                put(":name", listOf(colonName.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{path}/".replace("{"+"path"+"}", "$path"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param path  
    * @param pLimit  
    * @param `1property`  
    * @param `1propertyValue`  
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postQuery(path: kotlin.String, pLimit: java.math.BigDecimal, `1property`: kotlin.String, `1propertyValue`: kotlin.String) : kotlin.String {
        val localVariableConfig = postQueryRequestConfig(path = path, pLimit = pLimit, `1property` = `1property`, `1propertyValue` = `1propertyValue`)

        val localVarResponse = request<Unit, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postQuery
    *
    * @param path  
    * @param pLimit  
    * @param `1property`  
    * @param `1propertyValue`  
    * @return RequestConfig
    */
    fun postQueryRequestConfig(path: kotlin.String, pLimit: java.math.BigDecimal, `1property`: kotlin.String, `1propertyValue`: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("path", listOf(path.toString()))
                put("p.limit", listOf(pLimit.toString()))
                put("1_property", listOf(`1property`.toString()))
                put("1_property.value", listOf(`1propertyValue`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/bin/querybuilder.json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param ignoredeactivated  
    * @param onlymodified  
    * @param path  
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTreeActivation(ignoredeactivated: kotlin.Boolean, onlymodified: kotlin.Boolean, path: kotlin.String) : Unit {
        val localVariableConfig = postTreeActivationRequestConfig(ignoredeactivated = ignoredeactivated, onlymodified = onlymodified, path = path)

        val localVarResponse = request<Unit, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postTreeActivation
    *
    * @param ignoredeactivated  
    * @param onlymodified  
    * @param path  
    * @return RequestConfig
    */
    fun postTreeActivationRequestConfig(ignoredeactivated: kotlin.Boolean, onlymodified: kotlin.Boolean, path: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("ignoredeactivated", listOf(ignoredeactivated.toString()))
                put("onlymodified", listOf(onlymodified.toString()))
                put("path", listOf(path.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/etc/replication/treeactivation.html",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param colonOperation  (optional)
    * @param newPassword  (optional)
    * @param rePassword  (optional)
    * @param keyStoreType  (optional)
    * @param removeAlias  (optional)
    * @param certificate  (optional)
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTruststore(colonOperation: kotlin.String?, newPassword: kotlin.String?, rePassword: kotlin.String?, keyStoreType: kotlin.String?, removeAlias: kotlin.String?, certificate: java.io.File?) : kotlin.String {
        val localVariableConfig = postTruststoreRequestConfig(colonOperation = colonOperation, newPassword = newPassword, rePassword = rePassword, keyStoreType = keyStoreType, removeAlias = removeAlias, certificate = certificate)

        val localVarResponse = request<Map<String, Any?>, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postTruststore
    *
    * @param colonOperation  (optional)
    * @param newPassword  (optional)
    * @param rePassword  (optional)
    * @param keyStoreType  (optional)
    * @param removeAlias  (optional)
    * @param certificate  (optional)
    * @return RequestConfig
    */
    fun postTruststoreRequestConfig(colonOperation: kotlin.String?, newPassword: kotlin.String?, rePassword: kotlin.String?, keyStoreType: kotlin.String?, removeAlias: kotlin.String?, certificate: java.io.File?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("certificate" to certificate)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (colonOperation != null) {
                    put(":operation", listOf(colonOperation.toString()))
                }
                if (newPassword != null) {
                    put("newPassword", listOf(newPassword.toString()))
                }
                if (rePassword != null) {
                    put("rePassword", listOf(rePassword.toString()))
                }
                if (keyStoreType != null) {
                    put("keyStoreType", listOf(keyStoreType.toString()))
                }
                if (removeAlias != null) {
                    put("removeAlias", listOf(removeAlias.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/libs/granite/security/post/truststore",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param truststoreP12  (optional)
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTruststorePKCS12(truststoreP12: java.io.File?) : kotlin.String {
        val localVariableConfig = postTruststorePKCS12RequestConfig(truststoreP12 = truststoreP12)

        val localVarResponse = request<Map<String, Any?>, kotlin.String>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postTruststorePKCS12
    *
    * @param truststoreP12  (optional)
    * @return RequestConfig
    */
    fun postTruststorePKCS12RequestConfig(truststoreP12: java.io.File?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("truststore.p12" to truststoreP12)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/etc/truststore",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
