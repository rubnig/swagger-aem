note
 description:"[
		Adobe Experience Manager (AEM) API
 		Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
  		The version of the OpenAPI document: 3.5.0-pre.0
 	    Contact: opensource@shinesolutions.com

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	SLING_API

inherit

    API_I


feature -- API Access


	agent (runmode: STRING_32; name: STRING_32)
			-- 
			-- 
			-- 
			-- argument: runmode  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/replication/agents.{runmode}/{name}"
			l_path.replace_substring_all ("{"+"runmode"+"}", api_client.url_encode (runmode.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	agents (runmode: STRING_32): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: runmode  (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/replication/agents.{runmode}.-1.json"
			l_path.replace_substring_all ("{"+"runmode"+"}", api_client.url_encode (runmode.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	authorizable_keystore (intermediate_path: STRING_32; authorizable_id: STRING_32): detachable KEYSTORE_INFO
			-- 
			-- 
			-- 
			-- argument: intermediate_path  (required)
			-- 
			-- argument: authorizable_id  (required)
			-- 
			-- 
			-- Result KEYSTORE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{intermediatePath}/{authorizableId}.ks.json"
			l_path.replace_substring_all ("{"+"intermediatePath"+"}", api_client.url_encode (intermediate_path.out))
			l_path.replace_substring_all ("{"+"authorizableId"+"}", api_client.url_encode (authorizable_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { KEYSTORE_INFO } l_response.data ({ KEYSTORE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	delete_agent (runmode: STRING_32; name: STRING_32)
			-- 
			-- 
			-- 
			-- argument: runmode  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/replication/agents.{runmode}/{name}"
			l_path.replace_substring_all ("{"+"runmode"+"}", api_client.url_encode (runmode.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	delete_node (path: STRING_32; name: STRING_32)
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{path}/{name}"
			l_path.replace_substring_all ("{"+"path"+"}", api_client.url_encode (path.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	keystore (intermediate_path: STRING_32; authorizable_id: STRING_32): detachable FILE
			-- 
			-- 
			-- 
			-- argument: intermediate_path  (required)
			-- 
			-- argument: authorizable_id  (required)
			-- 
			-- 
			-- Result FILE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{intermediatePath}/{authorizableId}/keystore/store.p12"
			l_path.replace_substring_all ("{"+"intermediatePath"+"}", api_client.url_encode (intermediate_path.out))
			l_path.replace_substring_all ("{"+"authorizableId"+"}", api_client.url_encode (authorizable_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/octet-stream">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FILE } l_response.data ({ FILE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	node (path: STRING_32; name: STRING_32)
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{path}/{name}"
			l_path.replace_substring_all ("{"+"path"+"}", api_client.url_encode (path.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	package (group: STRING_32; name: STRING_32; version: STRING_32): detachable FILE
			-- 
			-- 
			-- 
			-- argument: group  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- argument: version  (required)
			-- 
			-- 
			-- Result FILE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/packages/{group}/{name}-{version}.zip"
			l_path.replace_substring_all ("{"+"group"+"}", api_client.url_encode (group.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))
			l_path.replace_substring_all ("{"+"version"+"}", api_client.url_encode (version.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/octet-stream">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FILE } l_response.data ({ FILE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	package_filter (group: STRING_32; name: STRING_32; version: STRING_32): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: group  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- argument: version  (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json"
			l_path.replace_substring_all ("{"+"group"+"}", api_client.url_encode (group.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))
			l_path.replace_substring_all ("{"+"version"+"}", api_client.url_encode (version.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	post_agent (runmode: STRING_32; name: STRING_32; jcrcontent_cqdistribute: BOOLEAN; jcrcontent_cqdistribute_type_hint: STRING_32; jcrcontent_cqname: STRING_32; jcrcontent_cqtemplate: STRING_32; jcrcontent_enabled: BOOLEAN; jcrcontent_jcrdescription: STRING_32; jcrcontent_jcrlast_modified: STRING_32; jcrcontent_jcrlast_modified_by: STRING_32; jcrcontent_jcrmixin_types: STRING_32; jcrcontent_jcrtitle: STRING_32; jcrcontent_log_level: STRING_32; jcrcontent_no_status_update: BOOLEAN; jcrcontent_no_versioning: BOOLEAN; jcrcontent_protocol_connect_timeout: REAL_32; jcrcontent_protocol_ht_tp_connection_closed: BOOLEAN; jcrcontent_protocol_ht_tp_expired: STRING_32; jcrcontent_protocol_ht_tp_headers: detachable LIST [STRING_32]; jcrcontent_protocol_ht_tp_headers_type_hint: STRING_32; jcrcontent_protocol_ht_tp_method: STRING_32; jcrcontent_protocol_ht_tp_srelaxed: BOOLEAN; jcrcontent_protocol_interface: STRING_32; jcrcontent_protocol_socket_timeout: REAL_32; jcrcontent_protocol_version: STRING_32; jcrcontent_proxy_nt_lm_domain: STRING_32; jcrcontent_proxy_nt_lm_host: STRING_32; jcrcontent_proxy_host: STRING_32; jcrcontent_proxy_password: STRING_32; jcrcontent_proxy_port: REAL_32; jcrcontent_proxy_user: STRING_32; jcrcontent_queue_batch_max_size: REAL_32; jcrcontent_queue_batch_mode: STRING_32; jcrcontent_queue_batch_wait_time: REAL_32; jcrcontent_retry_delay: STRING_32; jcrcontent_reverse_replication: BOOLEAN; jcrcontent_serialization_type: STRING_32; jcrcontent_slingresource_type: STRING_32; jcrcontent_ssl: STRING_32; jcrcontent_transport_nt_lm_domain: STRING_32; jcrcontent_transport_nt_lm_host: STRING_32; jcrcontent_transport_password: STRING_32; jcrcontent_transport_uri: STRING_32; jcrcontent_transport_user: STRING_32; jcrcontent_trigger_distribute: BOOLEAN; jcrcontent_trigger_modified: BOOLEAN; jcrcontent_trigger_on_off_time: BOOLEAN; jcrcontent_trigger_receive: BOOLEAN; jcrcontent_trigger_specific: BOOLEAN; jcrcontent_user_id: STRING_32; jcrprimary_type: STRING_32; operation: STRING_32)
			-- 
			-- 
			-- 
			-- argument: runmode  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- argument: jcrcontent_cqdistribute  (optional, default to null)
			-- 
			-- argument: jcrcontent_cqdistribute_type_hint  (optional, default to null)
			-- 
			-- argument: jcrcontent_cqname  (optional, default to null)
			-- 
			-- argument: jcrcontent_cqtemplate  (optional, default to null)
			-- 
			-- argument: jcrcontent_enabled  (optional, default to null)
			-- 
			-- argument: jcrcontent_jcrdescription  (optional, default to null)
			-- 
			-- argument: jcrcontent_jcrlast_modified  (optional, default to null)
			-- 
			-- argument: jcrcontent_jcrlast_modified_by  (optional, default to null)
			-- 
			-- argument: jcrcontent_jcrmixin_types  (optional, default to null)
			-- 
			-- argument: jcrcontent_jcrtitle  (optional, default to null)
			-- 
			-- argument: jcrcontent_log_level  (optional, default to null)
			-- 
			-- argument: jcrcontent_no_status_update  (optional, default to null)
			-- 
			-- argument: jcrcontent_no_versioning  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_connect_timeout  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_ht_tp_connection_closed  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_ht_tp_expired  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_ht_tp_headers  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_ht_tp_headers_type_hint  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_ht_tp_method  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_ht_tp_srelaxed  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_interface  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_socket_timeout  (optional, default to null)
			-- 
			-- argument: jcrcontent_protocol_version  (optional, default to null)
			-- 
			-- argument: jcrcontent_proxy_nt_lm_domain  (optional, default to null)
			-- 
			-- argument: jcrcontent_proxy_nt_lm_host  (optional, default to null)
			-- 
			-- argument: jcrcontent_proxy_host  (optional, default to null)
			-- 
			-- argument: jcrcontent_proxy_password  (optional, default to null)
			-- 
			-- argument: jcrcontent_proxy_port  (optional, default to null)
			-- 
			-- argument: jcrcontent_proxy_user  (optional, default to null)
			-- 
			-- argument: jcrcontent_queue_batch_max_size  (optional, default to null)
			-- 
			-- argument: jcrcontent_queue_batch_mode  (optional, default to null)
			-- 
			-- argument: jcrcontent_queue_batch_wait_time  (optional, default to null)
			-- 
			-- argument: jcrcontent_retry_delay  (optional, default to null)
			-- 
			-- argument: jcrcontent_reverse_replication  (optional, default to null)
			-- 
			-- argument: jcrcontent_serialization_type  (optional, default to null)
			-- 
			-- argument: jcrcontent_slingresource_type  (optional, default to null)
			-- 
			-- argument: jcrcontent_ssl  (optional, default to null)
			-- 
			-- argument: jcrcontent_transport_nt_lm_domain  (optional, default to null)
			-- 
			-- argument: jcrcontent_transport_nt_lm_host  (optional, default to null)
			-- 
			-- argument: jcrcontent_transport_password  (optional, default to null)
			-- 
			-- argument: jcrcontent_transport_uri  (optional, default to null)
			-- 
			-- argument: jcrcontent_transport_user  (optional, default to null)
			-- 
			-- argument: jcrcontent_trigger_distribute  (optional, default to null)
			-- 
			-- argument: jcrcontent_trigger_modified  (optional, default to null)
			-- 
			-- argument: jcrcontent_trigger_on_off_time  (optional, default to null)
			-- 
			-- argument: jcrcontent_trigger_receive  (optional, default to null)
			-- 
			-- argument: jcrcontent_trigger_specific  (optional, default to null)
			-- 
			-- argument: jcrcontent_user_id  (optional, default to null)
			-- 
			-- argument: jcrprimary_type  (optional, default to null)
			-- 
			-- argument: operation  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/replication/agents.{runmode}/{name}"
			l_path.replace_substring_all ("{"+"runmode"+"}", api_client.url_encode (runmode.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/cq:distribute", jcrcontent_cqdistribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/cq:distribute@TypeHint", jcrcontent_cqdistribute_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/cq:name", jcrcontent_cqname));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/cq:template", jcrcontent_cqtemplate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/enabled", jcrcontent_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/jcr:description", jcrcontent_jcrdescription));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/jcr:lastModified", jcrcontent_jcrlast_modified));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/jcr:lastModifiedBy", jcrcontent_jcrlast_modified_by));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/jcr:mixinTypes", jcrcontent_jcrmixin_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/jcr:title", jcrcontent_jcrtitle));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/logLevel", jcrcontent_log_level));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/noStatusUpdate", jcrcontent_no_status_update));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/noVersioning", jcrcontent_no_versioning));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolConnectTimeout", jcrcontent_protocol_connect_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolHTTPConnectionClosed", jcrcontent_protocol_ht_tp_connection_closed));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolHTTPExpired", jcrcontent_protocol_ht_tp_expired));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "jcr:content/protocolHTTPHeaders", jcrcontent_protocol_ht_tp_headers));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolHTTPHeaders@TypeHint", jcrcontent_protocol_ht_tp_headers_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolHTTPMethod", jcrcontent_protocol_ht_tp_method));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolHTTPSRelaxed", jcrcontent_protocol_ht_tp_srelaxed));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolInterface", jcrcontent_protocol_interface));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolSocketTimeout", jcrcontent_protocol_socket_timeout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/protocolVersion", jcrcontent_protocol_version));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/proxyNTLMDomain", jcrcontent_proxy_nt_lm_domain));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/proxyNTLMHost", jcrcontent_proxy_nt_lm_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/proxyHost", jcrcontent_proxy_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/proxyPassword", jcrcontent_proxy_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/proxyPort", jcrcontent_proxy_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/proxyUser", jcrcontent_proxy_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/queueBatchMaxSize", jcrcontent_queue_batch_max_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/queueBatchMode", jcrcontent_queue_batch_mode));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/queueBatchWaitTime", jcrcontent_queue_batch_wait_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/retryDelay", jcrcontent_retry_delay));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/reverseReplication", jcrcontent_reverse_replication));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/serializationType", jcrcontent_serialization_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/sling:resourceType", jcrcontent_slingresource_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/ssl", jcrcontent_ssl));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/transportNTLMDomain", jcrcontent_transport_nt_lm_domain));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/transportNTLMHost", jcrcontent_transport_nt_lm_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/transportPassword", jcrcontent_transport_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/transportUri", jcrcontent_transport_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/transportUser", jcrcontent_transport_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/triggerDistribute", jcrcontent_trigger_distribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/triggerModified", jcrcontent_trigger_modified));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/triggerOnOffTime", jcrcontent_trigger_on_off_time));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/triggerReceive", jcrcontent_trigger_receive));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/triggerSpecific", jcrcontent_trigger_specific));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:content/userId", jcrcontent_user_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:primaryType", jcrprimary_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", ":operation", operation));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_authorizable_keystore (intermediate_path: STRING_32; authorizable_id: STRING_32; operation: STRING_32; current_password: STRING_32; new_password: STRING_32; re_password: STRING_32; key_password: STRING_32; key_store_pass: STRING_32; var_alias: STRING_32; new_alias: STRING_32; remove_alias: STRING_32; cert_chain: FILE; pk: FILE; key_store: FILE): detachable KEYSTORE_INFO
			-- 
			-- 
			-- 
			-- argument: intermediate_path  (required)
			-- 
			-- argument: authorizable_id  (required)
			-- 
			-- argument: operation  (optional, default to null)
			-- 
			-- argument: current_password  (optional, default to null)
			-- 
			-- argument: new_password  (optional, default to null)
			-- 
			-- argument: re_password  (optional, default to null)
			-- 
			-- argument: key_password  (optional, default to null)
			-- 
			-- argument: key_store_pass  (optional, default to null)
			-- 
			-- argument: var_alias  (optional, default to null)
			-- 
			-- argument: new_alias  (optional, default to null)
			-- 
			-- argument: remove_alias  (optional, default to null)
			-- 
			-- argument: cert_chain  (optional, default to null)
			-- 
			-- argument: pk  (optional, default to null)
			-- 
			-- argument: key_store  (optional, default to null)
			-- 
			-- 
			-- Result KEYSTORE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{intermediatePath}/{authorizableId}.ks.html"
			l_path.replace_substring_all ("{"+"intermediatePath"+"}", api_client.url_encode (intermediate_path.out))
			l_path.replace_substring_all ("{"+"authorizableId"+"}", api_client.url_encode (authorizable_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", ":operation", operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "currentPassword", current_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "newPassword", new_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rePassword", re_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keyPassword", key_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keyStorePass", key_store_pass));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "alias", var_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "newAlias", new_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "removeAlias", remove_alias));

			if attached cert_chain as l_cert_chain then
				l_request.add_form(l_cert_chain,"cert-chain");
			end
			if attached pk as l_pk then
				l_request.add_form(l_pk,"pk");
			end
			if attached key_store as l_key_store then
				l_request.add_form(l_key_store,"keyStore");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { KEYSTORE_INFO } l_response.data ({ KEYSTORE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	post_authorizables (authorizable_id: STRING_32; intermediate_path: STRING_32; create_user: STRING_32; create_group: STRING_32; reppassword: STRING_32; profile_given_name: STRING_32): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: authorizable_id  (required)
			-- 
			-- argument: intermediate_path  (required)
			-- 
			-- argument: create_user  (optional, default to null)
			-- 
			-- argument: create_group  (optional, default to null)
			-- 
			-- argument: reppassword  (optional, default to null)
			-- 
			-- argument: profile_given_name  (optional, default to null)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/libs/granite/security/post/authorizables"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "authorizableId", authorizable_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "intermediatePath", intermediate_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createUser", create_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createGroup", create_group));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rep:password", reppassword));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "profile/givenName", profile_given_name));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/html">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	post_config_adobe_granite_saml_authentication_handler (key_store_password: STRING_32; key_store_password_type_hint: STRING_32; service_ranking: INTEGER_32; service_ranking_type_hint: STRING_32; idp_http_redirect: BOOLEAN; idp_http_redirect_type_hint: STRING_32; create_user: BOOLEAN; create_user_type_hint: STRING_32; default_redirect_url: STRING_32; default_redirect_url_type_hint: STRING_32; user_id_attribute: STRING_32; user_id_attribute_type_hint: STRING_32; default_groups: detachable LIST [STRING_32]; default_groups_type_hint: STRING_32; idp_cert_alias: STRING_32; idp_cert_alias_type_hint: STRING_32; add_group_memberships: BOOLEAN; add_group_memberships_type_hint: STRING_32; path: detachable LIST [STRING_32]; path_type_hint: STRING_32; synchronize_attributes: detachable LIST [STRING_32]; synchronize_attributes_type_hint: STRING_32; clock_tolerance: INTEGER_32; clock_tolerance_type_hint: STRING_32; group_membership_attribute: STRING_32; group_membership_attribute_type_hint: STRING_32; idp_url: STRING_32; idp_url_type_hint: STRING_32; logout_url: STRING_32; logout_url_type_hint: STRING_32; service_provider_entity_id: STRING_32; service_provider_entity_id_type_hint: STRING_32; assertion_consumer_service_ur_l: STRING_32; assertion_consumer_service_ur_ltype_hint: STRING_32; handle_logout: BOOLEAN; handle_logout_type_hint: STRING_32; sp_private_key_alias: STRING_32; sp_private_key_alias_type_hint: STRING_32; use_encryption: BOOLEAN; use_encryption_type_hint: STRING_32; name_id_format: STRING_32; name_id_format_type_hint: STRING_32; digest_method: STRING_32; digest_method_type_hint: STRING_32; signature_method: STRING_32; signature_method_type_hint: STRING_32; user_intermediate_path: STRING_32; user_intermediate_path_type_hint: STRING_32)
			-- 
			-- 
			-- 
			-- argument: key_store_password  (optional, default to null)
			-- 
			-- argument: key_store_password_type_hint  (optional, default to null)
			-- 
			-- argument: service_ranking  (optional, default to null)
			-- 
			-- argument: service_ranking_type_hint  (optional, default to null)
			-- 
			-- argument: idp_http_redirect  (optional, default to null)
			-- 
			-- argument: idp_http_redirect_type_hint  (optional, default to null)
			-- 
			-- argument: create_user  (optional, default to null)
			-- 
			-- argument: create_user_type_hint  (optional, default to null)
			-- 
			-- argument: default_redirect_url  (optional, default to null)
			-- 
			-- argument: default_redirect_url_type_hint  (optional, default to null)
			-- 
			-- argument: user_id_attribute  (optional, default to null)
			-- 
			-- argument: user_id_attribute_type_hint  (optional, default to null)
			-- 
			-- argument: default_groups  (optional, default to null)
			-- 
			-- argument: default_groups_type_hint  (optional, default to null)
			-- 
			-- argument: idp_cert_alias  (optional, default to null)
			-- 
			-- argument: idp_cert_alias_type_hint  (optional, default to null)
			-- 
			-- argument: add_group_memberships  (optional, default to null)
			-- 
			-- argument: add_group_memberships_type_hint  (optional, default to null)
			-- 
			-- argument: path  (optional, default to null)
			-- 
			-- argument: path_type_hint  (optional, default to null)
			-- 
			-- argument: synchronize_attributes  (optional, default to null)
			-- 
			-- argument: synchronize_attributes_type_hint  (optional, default to null)
			-- 
			-- argument: clock_tolerance  (optional, default to null)
			-- 
			-- argument: clock_tolerance_type_hint  (optional, default to null)
			-- 
			-- argument: group_membership_attribute  (optional, default to null)
			-- 
			-- argument: group_membership_attribute_type_hint  (optional, default to null)
			-- 
			-- argument: idp_url  (optional, default to null)
			-- 
			-- argument: idp_url_type_hint  (optional, default to null)
			-- 
			-- argument: logout_url  (optional, default to null)
			-- 
			-- argument: logout_url_type_hint  (optional, default to null)
			-- 
			-- argument: service_provider_entity_id  (optional, default to null)
			-- 
			-- argument: service_provider_entity_id_type_hint  (optional, default to null)
			-- 
			-- argument: assertion_consumer_service_ur_l  (optional, default to null)
			-- 
			-- argument: assertion_consumer_service_ur_ltype_hint  (optional, default to null)
			-- 
			-- argument: handle_logout  (optional, default to null)
			-- 
			-- argument: handle_logout_type_hint  (optional, default to null)
			-- 
			-- argument: sp_private_key_alias  (optional, default to null)
			-- 
			-- argument: sp_private_key_alias_type_hint  (optional, default to null)
			-- 
			-- argument: use_encryption  (optional, default to null)
			-- 
			-- argument: use_encryption_type_hint  (optional, default to null)
			-- 
			-- argument: name_id_format  (optional, default to null)
			-- 
			-- argument: name_id_format_type_hint  (optional, default to null)
			-- 
			-- argument: digest_method  (optional, default to null)
			-- 
			-- argument: digest_method_type_hint  (optional, default to null)
			-- 
			-- argument: signature_method  (optional, default to null)
			-- 
			-- argument: signature_method_type_hint  (optional, default to null)
			-- 
			-- argument: user_intermediate_path  (optional, default to null)
			-- 
			-- argument: user_intermediate_path_type_hint  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keyStorePassword", key_store_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keyStorePassword@TypeHint", key_store_password_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking", service_ranking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service.ranking@TypeHint", service_ranking_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpHttpRedirect", idp_http_redirect));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpHttpRedirect@TypeHint", idp_http_redirect_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createUser", create_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "createUser@TypeHint", create_user_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultRedirectUrl", default_redirect_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultRedirectUrl@TypeHint", default_redirect_url_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userIDAttribute", user_id_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userIDAttribute@TypeHint", user_id_attribute_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "defaultGroups", default_groups));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "defaultGroups@TypeHint", default_groups_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpCertAlias", idp_cert_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpCertAlias@TypeHint", idp_cert_alias_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addGroupMemberships", add_group_memberships));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addGroupMemberships@TypeHint", add_group_memberships_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path@TypeHint", path_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "synchronizeAttributes", synchronize_attributes));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "synchronizeAttributes@TypeHint", synchronize_attributes_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "clockTolerance", clock_tolerance));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "clockTolerance@TypeHint", clock_tolerance_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "groupMembershipAttribute", group_membership_attribute));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "groupMembershipAttribute@TypeHint", group_membership_attribute_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpUrl", idp_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "idpUrl@TypeHint", idp_url_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "logoutUrl", logout_url));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "logoutUrl@TypeHint", logout_url_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceProviderEntityId", service_provider_entity_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "serviceProviderEntityId@TypeHint", service_provider_entity_id_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "assertionConsumerServiceURL", assertion_consumer_service_ur_l));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "assertionConsumerServiceURL@TypeHint", assertion_consumer_service_ur_ltype_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "handleLogout", handle_logout));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "handleLogout@TypeHint", handle_logout_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "spPrivateKeyAlias", sp_private_key_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "spPrivateKeyAlias@TypeHint", sp_private_key_alias_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useEncryption", use_encryption));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "useEncryption@TypeHint", use_encryption_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nameIdFormat", name_id_format));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "nameIdFormat@TypeHint", name_id_format_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "digestMethod", digest_method));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "digestMethod@TypeHint", digest_method_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "signatureMethod", signature_method));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "signatureMethod@TypeHint", signature_method_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userIntermediatePath", user_intermediate_path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "userIntermediatePath@TypeHint", user_intermediate_path_type_hint));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_config_apache_felix_jetty_based_http_service (org_apache_felix_https_nio: BOOLEAN; org_apache_felix_https_nio_type_hint: STRING_32; org_apache_felix_https_keystore: STRING_32; org_apache_felix_https_keystore_type_hint: STRING_32; org_apache_felix_https_keystore_password: STRING_32; org_apache_felix_https_keystore_password_type_hint: STRING_32; org_apache_felix_https_keystore_key: STRING_32; org_apache_felix_https_keystore_key_type_hint: STRING_32; org_apache_felix_https_keystore_key_password: STRING_32; org_apache_felix_https_keystore_key_password_type_hint: STRING_32; org_apache_felix_https_truststore: STRING_32; org_apache_felix_https_truststore_type_hint: STRING_32; org_apache_felix_https_truststore_password: STRING_32; org_apache_felix_https_truststore_password_type_hint: STRING_32; org_apache_felix_https_clientcertificate: STRING_32; org_apache_felix_https_clientcertificate_type_hint: STRING_32; org_apache_felix_https_enable: BOOLEAN; org_apache_felix_https_enable_type_hint: STRING_32; org_osgi_service_http_port_secure: STRING_32; org_osgi_service_http_port_secure_type_hint: STRING_32)
			-- 
			-- 
			-- 
			-- argument: org_apache_felix_https_nio  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_nio_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_password  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_password_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_key  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_key_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_key_password  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_keystore_key_password_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_truststore  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_truststore_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_truststore_password  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_truststore_password_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_clientcertificate  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_clientcertificate_type_hint  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_enable  (optional, default to null)
			-- 
			-- argument: org_apache_felix_https_enable_type_hint  (optional, default to null)
			-- 
			-- argument: org_osgi_service_http_port_secure  (optional, default to null)
			-- 
			-- argument: org_osgi_service_http_port_secure_type_hint  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/org.apache.felix.http"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.nio", org_apache_felix_https_nio));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.nio@TypeHint", org_apache_felix_https_nio_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore", org_apache_felix_https_keystore));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore@TypeHint", org_apache_felix_https_keystore_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.password", org_apache_felix_https_keystore_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.password@TypeHint", org_apache_felix_https_keystore_password_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.key", org_apache_felix_https_keystore_key));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.key@TypeHint", org_apache_felix_https_keystore_key_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.key.password", org_apache_felix_https_keystore_key_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.keystore.key.password@TypeHint", org_apache_felix_https_keystore_key_password_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.truststore", org_apache_felix_https_truststore));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.truststore@TypeHint", org_apache_felix_https_truststore_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.truststore.password", org_apache_felix_https_truststore_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.truststore.password@TypeHint", org_apache_felix_https_truststore_password_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.clientcertificate", org_apache_felix_https_clientcertificate));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.clientcertificate@TypeHint", org_apache_felix_https_clientcertificate_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.enable", org_apache_felix_https_enable));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.apache.felix.https.enable@TypeHint", org_apache_felix_https_enable_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.osgi.service.http.port.secure", org_osgi_service_http_port_secure));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "org.osgi.service.http.port.secure@TypeHint", org_osgi_service_http_port_secure_type_hint));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_config_apache_http_components_proxy_configuration (proxy_host: STRING_32; proxy_host_type_hint: STRING_32; proxy_port: INTEGER_32; proxy_port_type_hint: STRING_32; proxy_exceptions: detachable LIST [STRING_32]; proxy_exceptions_type_hint: STRING_32; proxy_enabled: BOOLEAN; proxy_enabled_type_hint: STRING_32; proxy_user: STRING_32; proxy_user_type_hint: STRING_32; proxy_password: STRING_32; proxy_password_type_hint: STRING_32)
			-- 
			-- 
			-- 
			-- argument: proxy_host  (optional, default to null)
			-- 
			-- argument: proxy_host_type_hint  (optional, default to null)
			-- 
			-- argument: proxy_port  (optional, default to null)
			-- 
			-- argument: proxy_port_type_hint  (optional, default to null)
			-- 
			-- argument: proxy_exceptions  (optional, default to null)
			-- 
			-- argument: proxy_exceptions_type_hint  (optional, default to null)
			-- 
			-- argument: proxy_enabled  (optional, default to null)
			-- 
			-- argument: proxy_enabled_type_hint  (optional, default to null)
			-- 
			-- argument: proxy_user  (optional, default to null)
			-- 
			-- argument: proxy_user_type_hint  (optional, default to null)
			-- 
			-- argument: proxy_password  (optional, default to null)
			-- 
			-- argument: proxy_password_type_hint  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/org.apache.http.proxyconfigurator.config"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.host", proxy_host));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.host@TypeHint", proxy_host_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.port", proxy_port));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.port@TypeHint", proxy_port_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("multi", "proxy.exceptions", proxy_exceptions));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.exceptions@TypeHint", proxy_exceptions_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.enabled", proxy_enabled));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.enabled@TypeHint", proxy_enabled_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.user", proxy_user));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.user@TypeHint", proxy_user_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.password", proxy_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "proxy.password@TypeHint", proxy_password_type_hint));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_config_apache_sling_dav_ex_servlet (var_alias: STRING_32; alias_type_hint: STRING_32; dav_create_absolute_uri: BOOLEAN; dav_create_absolute_uri_type_hint: STRING_32)
			-- 
			-- 
			-- 
			-- argument: var_alias  (optional, default to null)
			-- 
			-- argument: alias_type_hint  (optional, default to null)
			-- 
			-- argument: dav_create_absolute_uri  (optional, default to null)
			-- 
			-- argument: dav_create_absolute_uri_type_hint  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "alias", var_alias));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "alias@TypeHint", alias_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.create-absolute-uri", dav_create_absolute_uri));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dav.create-absolute-uri@TypeHint", dav_create_absolute_uri_type_hint));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_config_apache_sling_get_servlet (json_maximumresults: STRING_32; json_maximumresults_type_hint: STRING_32; enable_html: BOOLEAN; enable_html_type_hint: STRING_32; enable_txt: BOOLEAN; enable_txt_type_hint: STRING_32; enable_xml: BOOLEAN; enable_xml_type_hint: STRING_32)
			-- 
			-- 
			-- 
			-- argument: json_maximumresults  (optional, default to null)
			-- 
			-- argument: json_maximumresults_type_hint  (optional, default to null)
			-- 
			-- argument: enable_html  (optional, default to null)
			-- 
			-- argument: enable_html_type_hint  (optional, default to null)
			-- 
			-- argument: enable_txt  (optional, default to null)
			-- 
			-- argument: enable_txt_type_hint  (optional, default to null)
			-- 
			-- argument: enable_xml  (optional, default to null)
			-- 
			-- argument: enable_xml_type_hint  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "json.maximumresults", json_maximumresults));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "json.maximumresults@TypeHint", json_maximumresults_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.html", enable_html));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.html@TypeHint", enable_html_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.txt", enable_txt));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.txt@TypeHint", enable_txt_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.xml", enable_xml));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enable.xml@TypeHint", enable_xml_type_hint));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_config_apache_sling_referrer_filter (allow_empty: BOOLEAN; allow_empty_type_hint: STRING_32; allow_hosts: STRING_32; allow_hosts_type_hint: STRING_32; allow_hosts_regexp: STRING_32; allow_hosts_regexp_type_hint: STRING_32; filter_methods: STRING_32; filter_methods_type_hint: STRING_32)
			-- 
			-- 
			-- 
			-- argument: allow_empty  (optional, default to null)
			-- 
			-- argument: allow_empty_type_hint  (optional, default to null)
			-- 
			-- argument: allow_hosts  (optional, default to null)
			-- 
			-- argument: allow_hosts_type_hint  (optional, default to null)
			-- 
			-- argument: allow_hosts_regexp  (optional, default to null)
			-- 
			-- argument: allow_hosts_regexp_type_hint  (optional, default to null)
			-- 
			-- argument: filter_methods  (optional, default to null)
			-- 
			-- argument: filter_methods_type_hint  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.empty", allow_empty));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.empty@TypeHint", allow_empty_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.hosts", allow_hosts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.hosts@TypeHint", allow_hosts_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.hosts.regexp", allow_hosts_regexp));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "allow.hosts.regexp@TypeHint", allow_hosts_regexp_type_hint));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.methods", filter_methods));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "filter.methods@TypeHint", filter_methods_type_hint));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_config_property (config_node_name: STRING_32)
			-- 
			-- 
			-- 
			-- argument: config_node_name  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/apps/system/config/{configNodeName}"
			l_path.replace_substring_all ("{"+"configNodeName"+"}", api_client.url_encode (config_node_name.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_node (path: STRING_32; name: STRING_32; operation: STRING_32; delete_authorizable: STRING_32; file: FILE)
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- argument: operation  (optional, default to null)
			-- 
			-- argument: delete_authorizable  (optional, default to null)
			-- 
			-- argument: file  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{path}/{name}"
			l_path.replace_substring_all ("{"+"path"+"}", api_client.url_encode (path.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", ":operation", operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "deleteAuthorizable", delete_authorizable));

			if attached file as l_file then
				l_request.add_form(l_file,"file");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_node_rw (path: STRING_32; name: STRING_32; add_members: STRING_32)
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- argument: add_members  (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{path}/{name}.rw.html"
			l_path.replace_substring_all ("{"+"path"+"}", api_client.url_encode (path.out))
			l_path.replace_substring_all ("{"+"name"+"}", api_client.url_encode (name.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "addMembers", add_members));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_path (path: STRING_32; jcrprimary_type: STRING_32; name: STRING_32)
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: jcrprimary_type  (required)
			-- 
			-- argument: name  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/{path}/"
			l_path.replace_substring_all ("{"+"path"+"}", api_client.url_encode (path.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "jcr:primaryType", jcrprimary_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", ":name", name));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_query (path: STRING_32; p_limit: REAL_32; var_1_property: STRING_32; var_1_property_value: STRING_32): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: p_limit  (required)
			-- 
			-- argument: var_1_property  (required)
			-- 
			-- argument: var_1_property_value  (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/bin/querybuilder.json"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "p.limit", p_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "1_property", var_1_property));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "1_property.value", var_1_property_value));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	post_tree_activation (ignoredeactivated: BOOLEAN; onlymodified: BOOLEAN; path: STRING_32)
			-- 
			-- 
			-- 
			-- argument: ignoredeactivated  (required)
			-- 
			-- argument: onlymodified  (required)
			-- 
			-- argument: path  (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/replication/treeactivation.html"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ignoredeactivated", ignoredeactivated));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "onlymodified", onlymodified));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	post_truststore (operation: STRING_32; new_password: STRING_32; re_password: STRING_32; key_store_type: STRING_32; remove_alias: STRING_32; certificate: FILE): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: operation  (optional, default to null)
			-- 
			-- argument: new_password  (optional, default to null)
			-- 
			-- argument: re_password  (optional, default to null)
			-- 
			-- argument: key_store_type  (optional, default to null)
			-- 
			-- argument: remove_alias  (optional, default to null)
			-- 
			-- argument: certificate  (optional, default to null)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/libs/granite/security/post/truststore"
			l_request.fill_query_params(api_client.parameter_to_tuple("", ":operation", operation));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "newPassword", new_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "rePassword", re_password));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "keyStoreType", key_store_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "removeAlias", remove_alias));

			if attached certificate as l_certificate then
				l_request.add_form(l_certificate,"certificate");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	post_truststore_pk_cs12 (truststore_p12: FILE): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: truststore_p12  (optional, default to null)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/truststore"

			if attached truststore_p12 as l_truststore_p12 then
				l_request.add_form(l_truststore_p12,"truststore.p12");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"text/plain">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	query (path: STRING_32; p_limit: REAL_32; var_1_property: STRING_32; var_1_property_value: STRING_32): detachable STRING_32
			-- 
			-- 
			-- 
			-- argument: path  (required)
			-- 
			-- argument: p_limit  (required)
			-- 
			-- argument: var_1_property  (required)
			-- 
			-- argument: var_1_property_value  (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/bin/querybuilder.json"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "p.limit", p_limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "1_property", var_1_property));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "1_property.value", var_1_property_value));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	truststore : detachable FILE
			-- 
			-- 
			-- 
			-- 
			-- Result FILE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/etc/truststore/truststore.p12"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/octet-stream">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FILE } l_response.data ({ FILE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	truststore_info : detachable TRUSTSTORE_INFO
			-- 
			-- 
			-- 
			-- 
			-- Result TRUSTSTORE_INFO
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/libs/granite/security/truststore.json"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"aemAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { TRUSTSTORE_INFO } l_response.data ({ TRUSTSTORE_INFO }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
