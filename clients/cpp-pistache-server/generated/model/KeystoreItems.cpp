/**
* Adobe Experience Manager (AEM) API
* Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
*
* The version of the OpenAPI document: 3.5.0-pre.0
* Contact: opensource@shinesolutions.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "KeystoreItems.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

KeystoreItems::KeystoreItems()
{
    m_Alias = "";
    m_AliasIsSet = false;
    m_EntryType = "";
    m_EntryTypeIsSet = false;
    m_Algorithm = "";
    m_AlgorithmIsSet = false;
    m_Format = "";
    m_FormatIsSet = false;
    m_ChainIsSet = false;
    
}

void KeystoreItems::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool KeystoreItems::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool KeystoreItems::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "KeystoreItems" : pathPrefix;

                         
    if (chainIsSet())
    {
        const std::vector<KeystoreChainItems>& value = m_Chain;
        const std::string currentValuePath = _pathPrefix + ".chain";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const KeystoreChainItems& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".chain") && success;
 
                i++;
            }
        }

    }
    
    return success;
}

bool KeystoreItems::operator==(const KeystoreItems& rhs) const
{
    return
    
    
    
    ((!aliasIsSet() && !rhs.aliasIsSet()) || (aliasIsSet() && rhs.aliasIsSet() && getAlias() == rhs.getAlias())) &&
    
    
    ((!entryTypeIsSet() && !rhs.entryTypeIsSet()) || (entryTypeIsSet() && rhs.entryTypeIsSet() && getEntryType() == rhs.getEntryType())) &&
    
    
    ((!algorithmIsSet() && !rhs.algorithmIsSet()) || (algorithmIsSet() && rhs.algorithmIsSet() && getAlgorithm() == rhs.getAlgorithm())) &&
    
    
    ((!formatIsSet() && !rhs.formatIsSet()) || (formatIsSet() && rhs.formatIsSet() && getFormat() == rhs.getFormat())) &&
    
    
    ((!chainIsSet() && !rhs.chainIsSet()) || (chainIsSet() && rhs.chainIsSet() && getChain() == rhs.getChain()))
    
    ;
}

bool KeystoreItems::operator!=(const KeystoreItems& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const KeystoreItems& o)
{
    j = nlohmann::json();
    if(o.aliasIsSet())
        j["alias"] = o.m_Alias;
    if(o.entryTypeIsSet())
        j["entryType"] = o.m_EntryType;
    if(o.algorithmIsSet())
        j["algorithm"] = o.m_Algorithm;
    if(o.formatIsSet())
        j["format"] = o.m_Format;
    if(o.chainIsSet() || !o.m_Chain.empty())
        j["chain"] = o.m_Chain;
    
}

void from_json(const nlohmann::json& j, KeystoreItems& o)
{
    if(j.find("alias") != j.end())
    {
        j.at("alias").get_to(o.m_Alias);
        o.m_AliasIsSet = true;
    } 
    if(j.find("entryType") != j.end())
    {
        j.at("entryType").get_to(o.m_EntryType);
        o.m_EntryTypeIsSet = true;
    } 
    if(j.find("algorithm") != j.end())
    {
        j.at("algorithm").get_to(o.m_Algorithm);
        o.m_AlgorithmIsSet = true;
    } 
    if(j.find("format") != j.end())
    {
        j.at("format").get_to(o.m_Format);
        o.m_FormatIsSet = true;
    } 
    if(j.find("chain") != j.end())
    {
        j.at("chain").get_to(o.m_Chain);
        o.m_ChainIsSet = true;
    } 
    
}

std::string KeystoreItems::getAlias() const
{
    return m_Alias;
}
void KeystoreItems::setAlias(std::string const& value)
{
    m_Alias = value;
    m_AliasIsSet = true;
}
bool KeystoreItems::aliasIsSet() const
{
    return m_AliasIsSet;
}
void KeystoreItems::unsetAlias()
{
    m_AliasIsSet = false;
}
std::string KeystoreItems::getEntryType() const
{
    return m_EntryType;
}
void KeystoreItems::setEntryType(std::string const& value)
{
    m_EntryType = value;
    m_EntryTypeIsSet = true;
}
bool KeystoreItems::entryTypeIsSet() const
{
    return m_EntryTypeIsSet;
}
void KeystoreItems::unsetEntryType()
{
    m_EntryTypeIsSet = false;
}
std::string KeystoreItems::getAlgorithm() const
{
    return m_Algorithm;
}
void KeystoreItems::setAlgorithm(std::string const& value)
{
    m_Algorithm = value;
    m_AlgorithmIsSet = true;
}
bool KeystoreItems::algorithmIsSet() const
{
    return m_AlgorithmIsSet;
}
void KeystoreItems::unsetAlgorithm()
{
    m_AlgorithmIsSet = false;
}
std::string KeystoreItems::getFormat() const
{
    return m_Format;
}
void KeystoreItems::setFormat(std::string const& value)
{
    m_Format = value;
    m_FormatIsSet = true;
}
bool KeystoreItems::formatIsSet() const
{
    return m_FormatIsSet;
}
void KeystoreItems::unsetFormat()
{
    m_FormatIsSet = false;
}
std::vector<KeystoreChainItems> KeystoreItems::getChain() const
{
    return m_Chain;
}
void KeystoreItems::setChain(std::vector<KeystoreChainItems> const& value)
{
    m_Chain = value;
    m_ChainIsSet = true;
}
bool KeystoreItems::chainIsSet() const
{
    return m_ChainIsSet;
}
void KeystoreItems::unsetChain()
{
    m_ChainIsSet = false;
}


} // namespace org::openapitools::server::model

