/**
* Adobe Experience Manager (AEM) API
* Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
*
* The version of the OpenAPI document: 3.5.0-pre.0
* Contact: opensource@shinesolutions.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "SlingApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string SlingApi::base = "";

SlingApi::SlingApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : router(rtr)
{
}

void SlingApi::init() {
    setupRoutes();
}

void SlingApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Delete(*router, base + "/etc/replication/agents.:runmode/:name", Routes::bind(&SlingApi::delete_agent_handler, this));
    Routes::Delete(*router, base + "/:path/:name", Routes::bind(&SlingApi::delete_node_handler, this));
    Routes::Get(*router, base + "/etc/replication/agents.:runmode/:name", Routes::bind(&SlingApi::get_agent_handler, this));
    Routes::Get(*router, base + "/etc/replication/agents.:runmode.-1.json", Routes::bind(&SlingApi::get_agents_handler, this));
    Routes::Get(*router, base + "/:intermediatePath/:authorizableId.ks.json", Routes::bind(&SlingApi::get_authorizable_keystore_handler, this));
    Routes::Get(*router, base + "/:intermediatePath/:authorizableId/keystore/store.p12", Routes::bind(&SlingApi::get_keystore_handler, this));
    Routes::Get(*router, base + "/:path/:name", Routes::bind(&SlingApi::get_node_handler, this));
    Routes::Get(*router, base + "/etc/packages/:group/:name-:version.zip", Routes::bind(&SlingApi::get_package_handler, this));
    Routes::Get(*router, base + "/etc/packages/:group/:name-:version.zip/jcr:content/vlt:definition/filter.tidy.2.json", Routes::bind(&SlingApi::get_package_filter_handler, this));
    Routes::Get(*router, base + "/bin/querybuilder.json", Routes::bind(&SlingApi::get_query_handler, this));
    Routes::Get(*router, base + "/etc/truststore/truststore.p12", Routes::bind(&SlingApi::get_truststore_handler, this));
    Routes::Get(*router, base + "/libs/granite/security/truststore.json", Routes::bind(&SlingApi::get_truststore_info_handler, this));
    Routes::Post(*router, base + "/etc/replication/agents.:runmode/:name", Routes::bind(&SlingApi::post_agent_handler, this));
    Routes::Post(*router, base + "/:intermediatePath/:authorizableId.ks.html", Routes::bind(&SlingApi::post_authorizable_keystore_handler, this));
    Routes::Post(*router, base + "/libs/granite/security/post/authorizables", Routes::bind(&SlingApi::post_authorizables_handler, this));
    Routes::Post(*router, base + "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config", Routes::bind(&SlingApi::post_config_adobe_granite_saml_authentication_handler_handler, this));
    Routes::Post(*router, base + "/apps/system/config/org.apache.felix.http", Routes::bind(&SlingApi::post_config_apache_felix_jetty_based_http_service_handler, this));
    Routes::Post(*router, base + "/apps/system/config/org.apache.http.proxyconfigurator.config", Routes::bind(&SlingApi::post_config_apache_http_components_proxy_configuration_handler, this));
    Routes::Post(*router, base + "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet", Routes::bind(&SlingApi::post_config_apache_sling_dav_ex_servlet_handler, this));
    Routes::Post(*router, base + "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet", Routes::bind(&SlingApi::post_config_apache_sling_get_servlet_handler, this));
    Routes::Post(*router, base + "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter", Routes::bind(&SlingApi::post_config_apache_sling_referrer_filter_handler, this));
    Routes::Post(*router, base + "/apps/system/config/:configNodeName", Routes::bind(&SlingApi::post_config_property_handler, this));
    Routes::Post(*router, base + "/:path/:name", Routes::bind(&SlingApi::post_node_handler, this));
    Routes::Post(*router, base + "/:path/:name.rw.html", Routes::bind(&SlingApi::post_node_rw_handler, this));
    Routes::Post(*router, base + "/:path/", Routes::bind(&SlingApi::post_path_handler, this));
    Routes::Post(*router, base + "/bin/querybuilder.json", Routes::bind(&SlingApi::post_query_handler, this));
    Routes::Post(*router, base + "/etc/replication/treeactivation.html", Routes::bind(&SlingApi::post_tree_activation_handler, this));
    Routes::Post(*router, base + "/libs/granite/security/post/truststore", Routes::bind(&SlingApi::post_truststore_handler, this));
    Routes::Post(*router, base + "/etc/truststore", Routes::bind(&SlingApi::post_truststore_pkcs12_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&SlingApi::sling_api_default_handler, this));
}

std::pair<Pistache::Http::Code, std::string> SlingApi::handleParsingException(const std::exception& ex) const noexcept
{
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

std::pair<Pistache::Http::Code, std::string> SlingApi::handleOperationException(const std::exception& ex) const noexcept
{
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void SlingApi::delete_agent_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto runmode = request.param(":runmode").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    
    try {
        this->delete_agent(runmode, name, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::delete_node_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto path = request.param(":path").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    
    try {
        this->delete_node(path, name, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_agent_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto runmode = request.param(":runmode").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    
    try {
        this->get_agent(runmode, name, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_agents_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto runmode = request.param(":runmode").as<std::string>();
    
    try {
        this->get_agents(runmode, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_authorizable_keystore_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto intermediatePath = request.param(":intermediatePath").as<std::string>();
    auto authorizableId = request.param(":authorizableId").as<std::string>();
    
    try {
        this->get_authorizable_keystore(intermediatePath, authorizableId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_keystore_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto intermediatePath = request.param(":intermediatePath").as<std::string>();
    auto authorizableId = request.param(":authorizableId").as<std::string>();
    
    try {
        this->get_keystore(intermediatePath, authorizableId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_node_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto path = request.param(":path").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    
    try {
        this->get_node(path, name, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_package_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto group = request.param(":group").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    auto version = request.param(":version").as<std::string>();
    
    try {
        this->get_package(group, name, version, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_package_filter_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto group = request.param(":group").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    auto version = request.param(":version").as<std::string>();
    
    try {
        this->get_package_filter(group, name, version, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_query_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto pathQuery = request.query().get("path");
    Pistache::Optional<std::string> path;
    if(!pathQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(pathQuery.get(), valueQuery_instance)){
            path = Pistache::Some(valueQuery_instance);
        }
    }
    auto pPeriodlimitQuery = request.query().get("p.limit");
    Pistache::Optional<double> pPeriodlimit;
    if(!pPeriodlimitQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(pPeriodlimitQuery.get(), valueQuery_instance)){
            pPeriodlimit = Pistache::Some(valueQuery_instance);
        }
    }
    auto r_1_propertyQuery = request.query().get("1_property");
    Pistache::Optional<std::string> r_1_property;
    if(!r_1_propertyQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(r_1_propertyQuery.get(), valueQuery_instance)){
            r_1_property = Pistache::Some(valueQuery_instance);
        }
    }
    auto r_1_property_valueQuery = request.query().get("1_property.value");
    Pistache::Optional<std::string> r_1_property_value;
    if(!r_1_property_valueQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(r_1_property_valueQuery.get(), valueQuery_instance)){
            r_1_property_value = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_query(path, pPeriodlimit, r_1_property, r_1_property_value, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_truststore_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->get_truststore(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::get_truststore_info_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->get_truststore_info(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_agent_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto runmode = request.param(":runmode").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    
    // Getting the query params
    auto jcrContentSlashcqDistributeQuery = request.query().get("jcr:content/cq:distribute");
    Pistache::Optional<bool> jcrContentSlashcqDistribute;
    if(!jcrContentSlashcqDistributeQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashcqDistributeQuery.get(), valueQuery_instance)){
            jcrContentSlashcqDistribute = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashcqDistributeAtTypeHintQuery = request.query().get("jcr:content/cq:distribute@TypeHint");
    Pistache::Optional<std::string> jcrContentSlashcqDistributeAtTypeHint;
    if(!jcrContentSlashcqDistributeAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashcqDistributeAtTypeHintQuery.get(), valueQuery_instance)){
            jcrContentSlashcqDistributeAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashcqNameQuery = request.query().get("jcr:content/cq:name");
    Pistache::Optional<std::string> jcrContentSlashcqName;
    if(!jcrContentSlashcqNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashcqNameQuery.get(), valueQuery_instance)){
            jcrContentSlashcqName = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashcqTemplateQuery = request.query().get("jcr:content/cq:template");
    Pistache::Optional<std::string> jcrContentSlashcqTemplate;
    if(!jcrContentSlashcqTemplateQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashcqTemplateQuery.get(), valueQuery_instance)){
            jcrContentSlashcqTemplate = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashenabledQuery = request.query().get("jcr:content/enabled");
    Pistache::Optional<bool> jcrContentSlashenabled;
    if(!jcrContentSlashenabledQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashenabledQuery.get(), valueQuery_instance)){
            jcrContentSlashenabled = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashjcrDescriptionQuery = request.query().get("jcr:content/jcr:description");
    Pistache::Optional<std::string> jcrContentSlashjcrDescription;
    if(!jcrContentSlashjcrDescriptionQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashjcrDescriptionQuery.get(), valueQuery_instance)){
            jcrContentSlashjcrDescription = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashjcrLastModifiedQuery = request.query().get("jcr:content/jcr:lastModified");
    Pistache::Optional<std::string> jcrContentSlashjcrLastModified;
    if(!jcrContentSlashjcrLastModifiedQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashjcrLastModifiedQuery.get(), valueQuery_instance)){
            jcrContentSlashjcrLastModified = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashjcrLastModifiedByQuery = request.query().get("jcr:content/jcr:lastModifiedBy");
    Pistache::Optional<std::string> jcrContentSlashjcrLastModifiedBy;
    if(!jcrContentSlashjcrLastModifiedByQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashjcrLastModifiedByQuery.get(), valueQuery_instance)){
            jcrContentSlashjcrLastModifiedBy = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashjcrMixinTypesQuery = request.query().get("jcr:content/jcr:mixinTypes");
    Pistache::Optional<std::string> jcrContentSlashjcrMixinTypes;
    if(!jcrContentSlashjcrMixinTypesQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashjcrMixinTypesQuery.get(), valueQuery_instance)){
            jcrContentSlashjcrMixinTypes = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashjcrTitleQuery = request.query().get("jcr:content/jcr:title");
    Pistache::Optional<std::string> jcrContentSlashjcrTitle;
    if(!jcrContentSlashjcrTitleQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashjcrTitleQuery.get(), valueQuery_instance)){
            jcrContentSlashjcrTitle = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashlogLevelQuery = request.query().get("jcr:content/logLevel");
    Pistache::Optional<std::string> jcrContentSlashlogLevel;
    if(!jcrContentSlashlogLevelQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashlogLevelQuery.get(), valueQuery_instance)){
            jcrContentSlashlogLevel = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashnoStatusUpdateQuery = request.query().get("jcr:content/noStatusUpdate");
    Pistache::Optional<bool> jcrContentSlashnoStatusUpdate;
    if(!jcrContentSlashnoStatusUpdateQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashnoStatusUpdateQuery.get(), valueQuery_instance)){
            jcrContentSlashnoStatusUpdate = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashnoVersioningQuery = request.query().get("jcr:content/noVersioning");
    Pistache::Optional<bool> jcrContentSlashnoVersioning;
    if(!jcrContentSlashnoVersioningQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashnoVersioningQuery.get(), valueQuery_instance)){
            jcrContentSlashnoVersioning = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolConnectTimeoutQuery = request.query().get("jcr:content/protocolConnectTimeout");
    Pistache::Optional<double> jcrContentSlashprotocolConnectTimeout;
    if(!jcrContentSlashprotocolConnectTimeoutQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolConnectTimeoutQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolConnectTimeout = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolHTTPConnectionClosedQuery = request.query().get("jcr:content/protocolHTTPConnectionClosed");
    Pistache::Optional<bool> jcrContentSlashprotocolHTTPConnectionClosed;
    if(!jcrContentSlashprotocolHTTPConnectionClosedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolHTTPConnectionClosedQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolHTTPConnectionClosed = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolHTTPExpiredQuery = request.query().get("jcr:content/protocolHTTPExpired");
    Pistache::Optional<std::string> jcrContentSlashprotocolHTTPExpired;
    if(!jcrContentSlashprotocolHTTPExpiredQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolHTTPExpiredQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolHTTPExpired = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolHTTPHeadersQuery = request.query().get("jcr:content/protocolHTTPHeaders");
    Pistache::Optional<std::vector<std::string>> jcrContentSlashprotocolHTTPHeaders;
    if(!jcrContentSlashprotocolHTTPHeadersQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolHTTPHeadersQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolHTTPHeaders = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolHTTPHeadersAtTypeHintQuery = request.query().get("jcr:content/protocolHTTPHeaders@TypeHint");
    Pistache::Optional<std::string> jcrContentSlashprotocolHTTPHeadersAtTypeHint;
    if(!jcrContentSlashprotocolHTTPHeadersAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolHTTPHeadersAtTypeHintQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolHTTPHeadersAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolHTTPMethodQuery = request.query().get("jcr:content/protocolHTTPMethod");
    Pistache::Optional<std::string> jcrContentSlashprotocolHTTPMethod;
    if(!jcrContentSlashprotocolHTTPMethodQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolHTTPMethodQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolHTTPMethod = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolHTTPSRelaxedQuery = request.query().get("jcr:content/protocolHTTPSRelaxed");
    Pistache::Optional<bool> jcrContentSlashprotocolHTTPSRelaxed;
    if(!jcrContentSlashprotocolHTTPSRelaxedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolHTTPSRelaxedQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolHTTPSRelaxed = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolInterfaceQuery = request.query().get("jcr:content/protocolInterface");
    Pistache::Optional<std::string> jcrContentSlashprotocolInterface;
    if(!jcrContentSlashprotocolInterfaceQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolInterfaceQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolInterface = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolSocketTimeoutQuery = request.query().get("jcr:content/protocolSocketTimeout");
    Pistache::Optional<double> jcrContentSlashprotocolSocketTimeout;
    if(!jcrContentSlashprotocolSocketTimeoutQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolSocketTimeoutQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolSocketTimeout = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashprotocolVersionQuery = request.query().get("jcr:content/protocolVersion");
    Pistache::Optional<std::string> jcrContentSlashprotocolVersion;
    if(!jcrContentSlashprotocolVersionQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashprotocolVersionQuery.get(), valueQuery_instance)){
            jcrContentSlashprotocolVersion = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashproxyNTLMDomainQuery = request.query().get("jcr:content/proxyNTLMDomain");
    Pistache::Optional<std::string> jcrContentSlashproxyNTLMDomain;
    if(!jcrContentSlashproxyNTLMDomainQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashproxyNTLMDomainQuery.get(), valueQuery_instance)){
            jcrContentSlashproxyNTLMDomain = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashproxyNTLMHostQuery = request.query().get("jcr:content/proxyNTLMHost");
    Pistache::Optional<std::string> jcrContentSlashproxyNTLMHost;
    if(!jcrContentSlashproxyNTLMHostQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashproxyNTLMHostQuery.get(), valueQuery_instance)){
            jcrContentSlashproxyNTLMHost = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashproxyHostQuery = request.query().get("jcr:content/proxyHost");
    Pistache::Optional<std::string> jcrContentSlashproxyHost;
    if(!jcrContentSlashproxyHostQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashproxyHostQuery.get(), valueQuery_instance)){
            jcrContentSlashproxyHost = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashproxyPasswordQuery = request.query().get("jcr:content/proxyPassword");
    Pistache::Optional<std::string> jcrContentSlashproxyPassword;
    if(!jcrContentSlashproxyPasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashproxyPasswordQuery.get(), valueQuery_instance)){
            jcrContentSlashproxyPassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashproxyPortQuery = request.query().get("jcr:content/proxyPort");
    Pistache::Optional<double> jcrContentSlashproxyPort;
    if(!jcrContentSlashproxyPortQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(jcrContentSlashproxyPortQuery.get(), valueQuery_instance)){
            jcrContentSlashproxyPort = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashproxyUserQuery = request.query().get("jcr:content/proxyUser");
    Pistache::Optional<std::string> jcrContentSlashproxyUser;
    if(!jcrContentSlashproxyUserQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashproxyUserQuery.get(), valueQuery_instance)){
            jcrContentSlashproxyUser = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashqueueBatchMaxSizeQuery = request.query().get("jcr:content/queueBatchMaxSize");
    Pistache::Optional<double> jcrContentSlashqueueBatchMaxSize;
    if(!jcrContentSlashqueueBatchMaxSizeQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(jcrContentSlashqueueBatchMaxSizeQuery.get(), valueQuery_instance)){
            jcrContentSlashqueueBatchMaxSize = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashqueueBatchModeQuery = request.query().get("jcr:content/queueBatchMode");
    Pistache::Optional<std::string> jcrContentSlashqueueBatchMode;
    if(!jcrContentSlashqueueBatchModeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashqueueBatchModeQuery.get(), valueQuery_instance)){
            jcrContentSlashqueueBatchMode = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashqueueBatchWaitTimeQuery = request.query().get("jcr:content/queueBatchWaitTime");
    Pistache::Optional<double> jcrContentSlashqueueBatchWaitTime;
    if(!jcrContentSlashqueueBatchWaitTimeQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(jcrContentSlashqueueBatchWaitTimeQuery.get(), valueQuery_instance)){
            jcrContentSlashqueueBatchWaitTime = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashretryDelayQuery = request.query().get("jcr:content/retryDelay");
    Pistache::Optional<std::string> jcrContentSlashretryDelay;
    if(!jcrContentSlashretryDelayQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashretryDelayQuery.get(), valueQuery_instance)){
            jcrContentSlashretryDelay = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashreverseReplicationQuery = request.query().get("jcr:content/reverseReplication");
    Pistache::Optional<bool> jcrContentSlashreverseReplication;
    if(!jcrContentSlashreverseReplicationQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashreverseReplicationQuery.get(), valueQuery_instance)){
            jcrContentSlashreverseReplication = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashserializationTypeQuery = request.query().get("jcr:content/serializationType");
    Pistache::Optional<std::string> jcrContentSlashserializationType;
    if(!jcrContentSlashserializationTypeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashserializationTypeQuery.get(), valueQuery_instance)){
            jcrContentSlashserializationType = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashslingResourceTypeQuery = request.query().get("jcr:content/sling:resourceType");
    Pistache::Optional<std::string> jcrContentSlashslingResourceType;
    if(!jcrContentSlashslingResourceTypeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashslingResourceTypeQuery.get(), valueQuery_instance)){
            jcrContentSlashslingResourceType = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashsslQuery = request.query().get("jcr:content/ssl");
    Pistache::Optional<std::string> jcrContentSlashssl;
    if(!jcrContentSlashsslQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashsslQuery.get(), valueQuery_instance)){
            jcrContentSlashssl = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtransportNTLMDomainQuery = request.query().get("jcr:content/transportNTLMDomain");
    Pistache::Optional<std::string> jcrContentSlashtransportNTLMDomain;
    if(!jcrContentSlashtransportNTLMDomainQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashtransportNTLMDomainQuery.get(), valueQuery_instance)){
            jcrContentSlashtransportNTLMDomain = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtransportNTLMHostQuery = request.query().get("jcr:content/transportNTLMHost");
    Pistache::Optional<std::string> jcrContentSlashtransportNTLMHost;
    if(!jcrContentSlashtransportNTLMHostQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashtransportNTLMHostQuery.get(), valueQuery_instance)){
            jcrContentSlashtransportNTLMHost = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtransportPasswordQuery = request.query().get("jcr:content/transportPassword");
    Pistache::Optional<std::string> jcrContentSlashtransportPassword;
    if(!jcrContentSlashtransportPasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashtransportPasswordQuery.get(), valueQuery_instance)){
            jcrContentSlashtransportPassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtransportUriQuery = request.query().get("jcr:content/transportUri");
    Pistache::Optional<std::string> jcrContentSlashtransportUri;
    if(!jcrContentSlashtransportUriQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashtransportUriQuery.get(), valueQuery_instance)){
            jcrContentSlashtransportUri = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtransportUserQuery = request.query().get("jcr:content/transportUser");
    Pistache::Optional<std::string> jcrContentSlashtransportUser;
    if(!jcrContentSlashtransportUserQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashtransportUserQuery.get(), valueQuery_instance)){
            jcrContentSlashtransportUser = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtriggerDistributeQuery = request.query().get("jcr:content/triggerDistribute");
    Pistache::Optional<bool> jcrContentSlashtriggerDistribute;
    if(!jcrContentSlashtriggerDistributeQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashtriggerDistributeQuery.get(), valueQuery_instance)){
            jcrContentSlashtriggerDistribute = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtriggerModifiedQuery = request.query().get("jcr:content/triggerModified");
    Pistache::Optional<bool> jcrContentSlashtriggerModified;
    if(!jcrContentSlashtriggerModifiedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashtriggerModifiedQuery.get(), valueQuery_instance)){
            jcrContentSlashtriggerModified = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtriggerOnOffTimeQuery = request.query().get("jcr:content/triggerOnOffTime");
    Pistache::Optional<bool> jcrContentSlashtriggerOnOffTime;
    if(!jcrContentSlashtriggerOnOffTimeQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashtriggerOnOffTimeQuery.get(), valueQuery_instance)){
            jcrContentSlashtriggerOnOffTime = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtriggerReceiveQuery = request.query().get("jcr:content/triggerReceive");
    Pistache::Optional<bool> jcrContentSlashtriggerReceive;
    if(!jcrContentSlashtriggerReceiveQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashtriggerReceiveQuery.get(), valueQuery_instance)){
            jcrContentSlashtriggerReceive = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashtriggerSpecificQuery = request.query().get("jcr:content/triggerSpecific");
    Pistache::Optional<bool> jcrContentSlashtriggerSpecific;
    if(!jcrContentSlashtriggerSpecificQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(jcrContentSlashtriggerSpecificQuery.get(), valueQuery_instance)){
            jcrContentSlashtriggerSpecific = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrContentSlashuserIdQuery = request.query().get("jcr:content/userId");
    Pistache::Optional<std::string> jcrContentSlashuserId;
    if(!jcrContentSlashuserIdQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrContentSlashuserIdQuery.get(), valueQuery_instance)){
            jcrContentSlashuserId = Pistache::Some(valueQuery_instance);
        }
    }
    auto jcrPrimaryTypeQuery = request.query().get("jcr:primaryType");
    Pistache::Optional<std::string> jcrPrimaryType;
    if(!jcrPrimaryTypeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrPrimaryTypeQuery.get(), valueQuery_instance)){
            jcrPrimaryType = Pistache::Some(valueQuery_instance);
        }
    }
    auto operationQuery = request.query().get(":operation");
    Pistache::Optional<std::string> operation;
    if(!operationQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(operationQuery.get(), valueQuery_instance)){
            operation = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_agent(runmode, name, jcrContentSlashcqDistribute, jcrContentSlashcqDistributeAtTypeHint, jcrContentSlashcqName, jcrContentSlashcqTemplate, jcrContentSlashenabled, jcrContentSlashjcrDescription, jcrContentSlashjcrLastModified, jcrContentSlashjcrLastModifiedBy, jcrContentSlashjcrMixinTypes, jcrContentSlashjcrTitle, jcrContentSlashlogLevel, jcrContentSlashnoStatusUpdate, jcrContentSlashnoVersioning, jcrContentSlashprotocolConnectTimeout, jcrContentSlashprotocolHTTPConnectionClosed, jcrContentSlashprotocolHTTPExpired, jcrContentSlashprotocolHTTPHeaders, jcrContentSlashprotocolHTTPHeadersAtTypeHint, jcrContentSlashprotocolHTTPMethod, jcrContentSlashprotocolHTTPSRelaxed, jcrContentSlashprotocolInterface, jcrContentSlashprotocolSocketTimeout, jcrContentSlashprotocolVersion, jcrContentSlashproxyNTLMDomain, jcrContentSlashproxyNTLMHost, jcrContentSlashproxyHost, jcrContentSlashproxyPassword, jcrContentSlashproxyPort, jcrContentSlashproxyUser, jcrContentSlashqueueBatchMaxSize, jcrContentSlashqueueBatchMode, jcrContentSlashqueueBatchWaitTime, jcrContentSlashretryDelay, jcrContentSlashreverseReplication, jcrContentSlashserializationType, jcrContentSlashslingResourceType, jcrContentSlashssl, jcrContentSlashtransportNTLMDomain, jcrContentSlashtransportNTLMHost, jcrContentSlashtransportPassword, jcrContentSlashtransportUri, jcrContentSlashtransportUser, jcrContentSlashtriggerDistribute, jcrContentSlashtriggerModified, jcrContentSlashtriggerOnOffTime, jcrContentSlashtriggerReceive, jcrContentSlashtriggerSpecific, jcrContentSlashuserId, jcrPrimaryType, operation, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_authorizable_keystore_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    try {
      this->post_authorizable_keystore(request, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_authorizables_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto authorizableIdQuery = request.query().get("authorizableId");
    Pistache::Optional<std::string> authorizableId;
    if(!authorizableIdQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(authorizableIdQuery.get(), valueQuery_instance)){
            authorizableId = Pistache::Some(valueQuery_instance);
        }
    }
    auto intermediatePathQuery = request.query().get("intermediatePath");
    Pistache::Optional<std::string> intermediatePath;
    if(!intermediatePathQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(intermediatePathQuery.get(), valueQuery_instance)){
            intermediatePath = Pistache::Some(valueQuery_instance);
        }
    }
    auto createUserQuery = request.query().get("createUser");
    Pistache::Optional<std::string> createUser;
    if(!createUserQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(createUserQuery.get(), valueQuery_instance)){
            createUser = Pistache::Some(valueQuery_instance);
        }
    }
    auto createGroupQuery = request.query().get("createGroup");
    Pistache::Optional<std::string> createGroup;
    if(!createGroupQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(createGroupQuery.get(), valueQuery_instance)){
            createGroup = Pistache::Some(valueQuery_instance);
        }
    }
    auto repPasswordQuery = request.query().get("rep:password");
    Pistache::Optional<std::string> repPassword;
    if(!repPasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(repPasswordQuery.get(), valueQuery_instance)){
            repPassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto profileSlashgivenNameQuery = request.query().get("profile/givenName");
    Pistache::Optional<std::string> profileSlashgivenName;
    if(!profileSlashgivenNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(profileSlashgivenNameQuery.get(), valueQuery_instance)){
            profileSlashgivenName = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_authorizables(authorizableId, intermediatePath, createUser, createGroup, repPassword, profileSlashgivenName, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_adobe_granite_saml_authentication_handler_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto keyStorePasswordQuery = request.query().get("keyStorePassword");
    Pistache::Optional<std::string> keyStorePassword;
    if(!keyStorePasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(keyStorePasswordQuery.get(), valueQuery_instance)){
            keyStorePassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto keyStorePasswordAtTypeHintQuery = request.query().get("keyStorePassword@TypeHint");
    Pistache::Optional<std::string> keyStorePasswordAtTypeHint;
    if(!keyStorePasswordAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(keyStorePasswordAtTypeHintQuery.get(), valueQuery_instance)){
            keyStorePasswordAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto servicePeriodrankingQuery = request.query().get("service.ranking");
    Pistache::Optional<int32_t> servicePeriodranking;
    if(!servicePeriodrankingQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(servicePeriodrankingQuery.get(), valueQuery_instance)){
            servicePeriodranking = Pistache::Some(valueQuery_instance);
        }
    }
    auto servicePeriodrankingAtTypeHintQuery = request.query().get("service.ranking@TypeHint");
    Pistache::Optional<std::string> servicePeriodrankingAtTypeHint;
    if(!servicePeriodrankingAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(servicePeriodrankingAtTypeHintQuery.get(), valueQuery_instance)){
            servicePeriodrankingAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto idpHttpRedirectQuery = request.query().get("idpHttpRedirect");
    Pistache::Optional<bool> idpHttpRedirect;
    if(!idpHttpRedirectQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(idpHttpRedirectQuery.get(), valueQuery_instance)){
            idpHttpRedirect = Pistache::Some(valueQuery_instance);
        }
    }
    auto idpHttpRedirectAtTypeHintQuery = request.query().get("idpHttpRedirect@TypeHint");
    Pistache::Optional<std::string> idpHttpRedirectAtTypeHint;
    if(!idpHttpRedirectAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(idpHttpRedirectAtTypeHintQuery.get(), valueQuery_instance)){
            idpHttpRedirectAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto createUserQuery = request.query().get("createUser");
    Pistache::Optional<bool> createUser;
    if(!createUserQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(createUserQuery.get(), valueQuery_instance)){
            createUser = Pistache::Some(valueQuery_instance);
        }
    }
    auto createUserAtTypeHintQuery = request.query().get("createUser@TypeHint");
    Pistache::Optional<std::string> createUserAtTypeHint;
    if(!createUserAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(createUserAtTypeHintQuery.get(), valueQuery_instance)){
            createUserAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto defaultRedirectUrlQuery = request.query().get("defaultRedirectUrl");
    Pistache::Optional<std::string> defaultRedirectUrl;
    if(!defaultRedirectUrlQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(defaultRedirectUrlQuery.get(), valueQuery_instance)){
            defaultRedirectUrl = Pistache::Some(valueQuery_instance);
        }
    }
    auto defaultRedirectUrlAtTypeHintQuery = request.query().get("defaultRedirectUrl@TypeHint");
    Pistache::Optional<std::string> defaultRedirectUrlAtTypeHint;
    if(!defaultRedirectUrlAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(defaultRedirectUrlAtTypeHintQuery.get(), valueQuery_instance)){
            defaultRedirectUrlAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto userIDAttributeQuery = request.query().get("userIDAttribute");
    Pistache::Optional<std::string> userIDAttribute;
    if(!userIDAttributeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(userIDAttributeQuery.get(), valueQuery_instance)){
            userIDAttribute = Pistache::Some(valueQuery_instance);
        }
    }
    auto userIDAttributeAtTypeHintQuery = request.query().get("userIDAttribute@TypeHint");
    Pistache::Optional<std::string> userIDAttributeAtTypeHint;
    if(!userIDAttributeAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(userIDAttributeAtTypeHintQuery.get(), valueQuery_instance)){
            userIDAttributeAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto defaultGroupsQuery = request.query().get("defaultGroups");
    Pistache::Optional<std::vector<std::string>> defaultGroups;
    if(!defaultGroupsQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(defaultGroupsQuery.get(), valueQuery_instance)){
            defaultGroups = Pistache::Some(valueQuery_instance);
        }
    }
    auto defaultGroupsAtTypeHintQuery = request.query().get("defaultGroups@TypeHint");
    Pistache::Optional<std::string> defaultGroupsAtTypeHint;
    if(!defaultGroupsAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(defaultGroupsAtTypeHintQuery.get(), valueQuery_instance)){
            defaultGroupsAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto idpCertAliasQuery = request.query().get("idpCertAlias");
    Pistache::Optional<std::string> idpCertAlias;
    if(!idpCertAliasQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(idpCertAliasQuery.get(), valueQuery_instance)){
            idpCertAlias = Pistache::Some(valueQuery_instance);
        }
    }
    auto idpCertAliasAtTypeHintQuery = request.query().get("idpCertAlias@TypeHint");
    Pistache::Optional<std::string> idpCertAliasAtTypeHint;
    if(!idpCertAliasAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(idpCertAliasAtTypeHintQuery.get(), valueQuery_instance)){
            idpCertAliasAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto addGroupMembershipsQuery = request.query().get("addGroupMemberships");
    Pistache::Optional<bool> addGroupMemberships;
    if(!addGroupMembershipsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(addGroupMembershipsQuery.get(), valueQuery_instance)){
            addGroupMemberships = Pistache::Some(valueQuery_instance);
        }
    }
    auto addGroupMembershipsAtTypeHintQuery = request.query().get("addGroupMemberships@TypeHint");
    Pistache::Optional<std::string> addGroupMembershipsAtTypeHint;
    if(!addGroupMembershipsAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(addGroupMembershipsAtTypeHintQuery.get(), valueQuery_instance)){
            addGroupMembershipsAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto pathQuery = request.query().get("path");
    Pistache::Optional<std::vector<std::string>> path;
    if(!pathQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(pathQuery.get(), valueQuery_instance)){
            path = Pistache::Some(valueQuery_instance);
        }
    }
    auto pathAtTypeHintQuery = request.query().get("path@TypeHint");
    Pistache::Optional<std::string> pathAtTypeHint;
    if(!pathAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(pathAtTypeHintQuery.get(), valueQuery_instance)){
            pathAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto synchronizeAttributesQuery = request.query().get("synchronizeAttributes");
    Pistache::Optional<std::vector<std::string>> synchronizeAttributes;
    if(!synchronizeAttributesQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(synchronizeAttributesQuery.get(), valueQuery_instance)){
            synchronizeAttributes = Pistache::Some(valueQuery_instance);
        }
    }
    auto synchronizeAttributesAtTypeHintQuery = request.query().get("synchronizeAttributes@TypeHint");
    Pistache::Optional<std::string> synchronizeAttributesAtTypeHint;
    if(!synchronizeAttributesAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(synchronizeAttributesAtTypeHintQuery.get(), valueQuery_instance)){
            synchronizeAttributesAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto clockToleranceQuery = request.query().get("clockTolerance");
    Pistache::Optional<int32_t> clockTolerance;
    if(!clockToleranceQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(clockToleranceQuery.get(), valueQuery_instance)){
            clockTolerance = Pistache::Some(valueQuery_instance);
        }
    }
    auto clockToleranceAtTypeHintQuery = request.query().get("clockTolerance@TypeHint");
    Pistache::Optional<std::string> clockToleranceAtTypeHint;
    if(!clockToleranceAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(clockToleranceAtTypeHintQuery.get(), valueQuery_instance)){
            clockToleranceAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto groupMembershipAttributeQuery = request.query().get("groupMembershipAttribute");
    Pistache::Optional<std::string> groupMembershipAttribute;
    if(!groupMembershipAttributeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(groupMembershipAttributeQuery.get(), valueQuery_instance)){
            groupMembershipAttribute = Pistache::Some(valueQuery_instance);
        }
    }
    auto groupMembershipAttributeAtTypeHintQuery = request.query().get("groupMembershipAttribute@TypeHint");
    Pistache::Optional<std::string> groupMembershipAttributeAtTypeHint;
    if(!groupMembershipAttributeAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(groupMembershipAttributeAtTypeHintQuery.get(), valueQuery_instance)){
            groupMembershipAttributeAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto idpUrlQuery = request.query().get("idpUrl");
    Pistache::Optional<std::string> idpUrl;
    if(!idpUrlQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(idpUrlQuery.get(), valueQuery_instance)){
            idpUrl = Pistache::Some(valueQuery_instance);
        }
    }
    auto idpUrlAtTypeHintQuery = request.query().get("idpUrl@TypeHint");
    Pistache::Optional<std::string> idpUrlAtTypeHint;
    if(!idpUrlAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(idpUrlAtTypeHintQuery.get(), valueQuery_instance)){
            idpUrlAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto logoutUrlQuery = request.query().get("logoutUrl");
    Pistache::Optional<std::string> logoutUrl;
    if(!logoutUrlQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(logoutUrlQuery.get(), valueQuery_instance)){
            logoutUrl = Pistache::Some(valueQuery_instance);
        }
    }
    auto logoutUrlAtTypeHintQuery = request.query().get("logoutUrl@TypeHint");
    Pistache::Optional<std::string> logoutUrlAtTypeHint;
    if(!logoutUrlAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(logoutUrlAtTypeHintQuery.get(), valueQuery_instance)){
            logoutUrlAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto serviceProviderEntityIdQuery = request.query().get("serviceProviderEntityId");
    Pistache::Optional<std::string> serviceProviderEntityId;
    if(!serviceProviderEntityIdQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(serviceProviderEntityIdQuery.get(), valueQuery_instance)){
            serviceProviderEntityId = Pistache::Some(valueQuery_instance);
        }
    }
    auto serviceProviderEntityIdAtTypeHintQuery = request.query().get("serviceProviderEntityId@TypeHint");
    Pistache::Optional<std::string> serviceProviderEntityIdAtTypeHint;
    if(!serviceProviderEntityIdAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(serviceProviderEntityIdAtTypeHintQuery.get(), valueQuery_instance)){
            serviceProviderEntityIdAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto assertionConsumerServiceURLQuery = request.query().get("assertionConsumerServiceURL");
    Pistache::Optional<std::string> assertionConsumerServiceURL;
    if(!assertionConsumerServiceURLQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(assertionConsumerServiceURLQuery.get(), valueQuery_instance)){
            assertionConsumerServiceURL = Pistache::Some(valueQuery_instance);
        }
    }
    auto assertionConsumerServiceURLAtTypeHintQuery = request.query().get("assertionConsumerServiceURL@TypeHint");
    Pistache::Optional<std::string> assertionConsumerServiceURLAtTypeHint;
    if(!assertionConsumerServiceURLAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(assertionConsumerServiceURLAtTypeHintQuery.get(), valueQuery_instance)){
            assertionConsumerServiceURLAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto handleLogoutQuery = request.query().get("handleLogout");
    Pistache::Optional<bool> handleLogout;
    if(!handleLogoutQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(handleLogoutQuery.get(), valueQuery_instance)){
            handleLogout = Pistache::Some(valueQuery_instance);
        }
    }
    auto handleLogoutAtTypeHintQuery = request.query().get("handleLogout@TypeHint");
    Pistache::Optional<std::string> handleLogoutAtTypeHint;
    if(!handleLogoutAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(handleLogoutAtTypeHintQuery.get(), valueQuery_instance)){
            handleLogoutAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto spPrivateKeyAliasQuery = request.query().get("spPrivateKeyAlias");
    Pistache::Optional<std::string> spPrivateKeyAlias;
    if(!spPrivateKeyAliasQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(spPrivateKeyAliasQuery.get(), valueQuery_instance)){
            spPrivateKeyAlias = Pistache::Some(valueQuery_instance);
        }
    }
    auto spPrivateKeyAliasAtTypeHintQuery = request.query().get("spPrivateKeyAlias@TypeHint");
    Pistache::Optional<std::string> spPrivateKeyAliasAtTypeHint;
    if(!spPrivateKeyAliasAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(spPrivateKeyAliasAtTypeHintQuery.get(), valueQuery_instance)){
            spPrivateKeyAliasAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto useEncryptionQuery = request.query().get("useEncryption");
    Pistache::Optional<bool> useEncryption;
    if(!useEncryptionQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(useEncryptionQuery.get(), valueQuery_instance)){
            useEncryption = Pistache::Some(valueQuery_instance);
        }
    }
    auto useEncryptionAtTypeHintQuery = request.query().get("useEncryption@TypeHint");
    Pistache::Optional<std::string> useEncryptionAtTypeHint;
    if(!useEncryptionAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(useEncryptionAtTypeHintQuery.get(), valueQuery_instance)){
            useEncryptionAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto nameIdFormatQuery = request.query().get("nameIdFormat");
    Pistache::Optional<std::string> nameIdFormat;
    if(!nameIdFormatQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(nameIdFormatQuery.get(), valueQuery_instance)){
            nameIdFormat = Pistache::Some(valueQuery_instance);
        }
    }
    auto nameIdFormatAtTypeHintQuery = request.query().get("nameIdFormat@TypeHint");
    Pistache::Optional<std::string> nameIdFormatAtTypeHint;
    if(!nameIdFormatAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(nameIdFormatAtTypeHintQuery.get(), valueQuery_instance)){
            nameIdFormatAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto digestMethodQuery = request.query().get("digestMethod");
    Pistache::Optional<std::string> digestMethod;
    if(!digestMethodQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(digestMethodQuery.get(), valueQuery_instance)){
            digestMethod = Pistache::Some(valueQuery_instance);
        }
    }
    auto digestMethodAtTypeHintQuery = request.query().get("digestMethod@TypeHint");
    Pistache::Optional<std::string> digestMethodAtTypeHint;
    if(!digestMethodAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(digestMethodAtTypeHintQuery.get(), valueQuery_instance)){
            digestMethodAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto signatureMethodQuery = request.query().get("signatureMethod");
    Pistache::Optional<std::string> signatureMethod;
    if(!signatureMethodQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(signatureMethodQuery.get(), valueQuery_instance)){
            signatureMethod = Pistache::Some(valueQuery_instance);
        }
    }
    auto signatureMethodAtTypeHintQuery = request.query().get("signatureMethod@TypeHint");
    Pistache::Optional<std::string> signatureMethodAtTypeHint;
    if(!signatureMethodAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(signatureMethodAtTypeHintQuery.get(), valueQuery_instance)){
            signatureMethodAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto userIntermediatePathQuery = request.query().get("userIntermediatePath");
    Pistache::Optional<std::string> userIntermediatePath;
    if(!userIntermediatePathQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(userIntermediatePathQuery.get(), valueQuery_instance)){
            userIntermediatePath = Pistache::Some(valueQuery_instance);
        }
    }
    auto userIntermediatePathAtTypeHintQuery = request.query().get("userIntermediatePath@TypeHint");
    Pistache::Optional<std::string> userIntermediatePathAtTypeHint;
    if(!userIntermediatePathAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(userIntermediatePathAtTypeHintQuery.get(), valueQuery_instance)){
            userIntermediatePathAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_config_adobe_granite_saml_authentication_handler(keyStorePassword, keyStorePasswordAtTypeHint, servicePeriodranking, servicePeriodrankingAtTypeHint, idpHttpRedirect, idpHttpRedirectAtTypeHint, createUser, createUserAtTypeHint, defaultRedirectUrl, defaultRedirectUrlAtTypeHint, userIDAttribute, userIDAttributeAtTypeHint, defaultGroups, defaultGroupsAtTypeHint, idpCertAlias, idpCertAliasAtTypeHint, addGroupMemberships, addGroupMembershipsAtTypeHint, path, pathAtTypeHint, synchronizeAttributes, synchronizeAttributesAtTypeHint, clockTolerance, clockToleranceAtTypeHint, groupMembershipAttribute, groupMembershipAttributeAtTypeHint, idpUrl, idpUrlAtTypeHint, logoutUrl, logoutUrlAtTypeHint, serviceProviderEntityId, serviceProviderEntityIdAtTypeHint, assertionConsumerServiceURL, assertionConsumerServiceURLAtTypeHint, handleLogout, handleLogoutAtTypeHint, spPrivateKeyAlias, spPrivateKeyAliasAtTypeHint, useEncryption, useEncryptionAtTypeHint, nameIdFormat, nameIdFormatAtTypeHint, digestMethod, digestMethodAtTypeHint, signatureMethod, signatureMethodAtTypeHint, userIntermediatePath, userIntermediatePathAtTypeHint, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_apache_felix_jetty_based_http_service_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodnioQuery = request.query().get("org.apache.felix.https.nio");
    Pistache::Optional<bool> orgPeriodapachePeriodfelixPeriodhttpsPeriodnio;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodnioQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodnioQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodnio = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHintQuery = request.query().get("org.apache.felix.https.nio@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreQuery = request.query().get("org.apache.felix.https.keystore");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHintQuery = request.query().get("org.apache.felix.https.keystore@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordQuery = request.query().get("org.apache.felix.https.keystore.password");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHintQuery = request.query().get("org.apache.felix.https.keystore.password@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyQuery = request.query().get("org.apache.felix.https.keystore.key");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHintQuery = request.query().get("org.apache.felix.https.keystore.key@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordQuery = request.query().get("org.apache.felix.https.keystore.key.password");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHintQuery = request.query().get("org.apache.felix.https.keystore.key.password@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreQuery = request.query().get("org.apache.felix.https.truststore");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHintQuery = request.query().get("org.apache.felix.https.truststore@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordQuery = request.query().get("org.apache.felix.https.truststore.password");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHintQuery = request.query().get("org.apache.felix.https.truststore.password@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateQuery = request.query().get("org.apache.felix.https.clientcertificate");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHintQuery = request.query().get("org.apache.felix.https.clientcertificate@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodenableQuery = request.query().get("org.apache.felix.https.enable");
    Pistache::Optional<bool> orgPeriodapachePeriodfelixPeriodhttpsPeriodenable;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodenableQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodenableQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodenable = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHintQuery = request.query().get("org.apache.felix.https.enable@TypeHint");
    Pistache::Optional<std::string> orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint;
    if(!orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureQuery = request.query().get("org.osgi.service.http.port.secure");
    Pistache::Optional<std::string> orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure;
    if(!orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureQuery.get(), valueQuery_instance)){
            orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure = Pistache::Some(valueQuery_instance);
        }
    }
    auto orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHintQuery = request.query().get("org.osgi.service.http.port.secure@TypeHint");
    Pistache::Optional<std::string> orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint;
    if(!orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHintQuery.get(), valueQuery_instance)){
            orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_config_apache_felix_jetty_based_http_service(orgPeriodapachePeriodfelixPeriodhttpsPeriodnio, orgPeriodapachePeriodfelixPeriodhttpsPeriodnioAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystore, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystoreAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpassword, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodpasswordAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkey, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpassword, orgPeriodapachePeriodfelixPeriodhttpsPeriodkeystorePeriodkeyPeriodpasswordAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststore, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststoreAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpassword, orgPeriodapachePeriodfelixPeriodhttpsPeriodtruststorePeriodpasswordAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificate, orgPeriodapachePeriodfelixPeriodhttpsPeriodclientcertificateAtTypeHint, orgPeriodapachePeriodfelixPeriodhttpsPeriodenable, orgPeriodapachePeriodfelixPeriodhttpsPeriodenableAtTypeHint, orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecure, orgPeriodosgiPeriodservicePeriodhttpPeriodportPeriodsecureAtTypeHint, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_apache_http_components_proxy_configuration_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto proxyPeriodhostQuery = request.query().get("proxy.host");
    Pistache::Optional<std::string> proxyPeriodhost;
    if(!proxyPeriodhostQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodhostQuery.get(), valueQuery_instance)){
            proxyPeriodhost = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodhostAtTypeHintQuery = request.query().get("proxy.host@TypeHint");
    Pistache::Optional<std::string> proxyPeriodhostAtTypeHint;
    if(!proxyPeriodhostAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodhostAtTypeHintQuery.get(), valueQuery_instance)){
            proxyPeriodhostAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodportQuery = request.query().get("proxy.port");
    Pistache::Optional<int32_t> proxyPeriodport;
    if(!proxyPeriodportQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(proxyPeriodportQuery.get(), valueQuery_instance)){
            proxyPeriodport = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodportAtTypeHintQuery = request.query().get("proxy.port@TypeHint");
    Pistache::Optional<std::string> proxyPeriodportAtTypeHint;
    if(!proxyPeriodportAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodportAtTypeHintQuery.get(), valueQuery_instance)){
            proxyPeriodportAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodexceptionsQuery = request.query().get("proxy.exceptions");
    Pistache::Optional<std::vector<std::string>> proxyPeriodexceptions;
    if(!proxyPeriodexceptionsQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(proxyPeriodexceptionsQuery.get(), valueQuery_instance)){
            proxyPeriodexceptions = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodexceptionsAtTypeHintQuery = request.query().get("proxy.exceptions@TypeHint");
    Pistache::Optional<std::string> proxyPeriodexceptionsAtTypeHint;
    if(!proxyPeriodexceptionsAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodexceptionsAtTypeHintQuery.get(), valueQuery_instance)){
            proxyPeriodexceptionsAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodenabledQuery = request.query().get("proxy.enabled");
    Pistache::Optional<bool> proxyPeriodenabled;
    if(!proxyPeriodenabledQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(proxyPeriodenabledQuery.get(), valueQuery_instance)){
            proxyPeriodenabled = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodenabledAtTypeHintQuery = request.query().get("proxy.enabled@TypeHint");
    Pistache::Optional<std::string> proxyPeriodenabledAtTypeHint;
    if(!proxyPeriodenabledAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodenabledAtTypeHintQuery.get(), valueQuery_instance)){
            proxyPeriodenabledAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPerioduserQuery = request.query().get("proxy.user");
    Pistache::Optional<std::string> proxyPerioduser;
    if(!proxyPerioduserQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPerioduserQuery.get(), valueQuery_instance)){
            proxyPerioduser = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPerioduserAtTypeHintQuery = request.query().get("proxy.user@TypeHint");
    Pistache::Optional<std::string> proxyPerioduserAtTypeHint;
    if(!proxyPerioduserAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPerioduserAtTypeHintQuery.get(), valueQuery_instance)){
            proxyPerioduserAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodpasswordQuery = request.query().get("proxy.password");
    Pistache::Optional<std::string> proxyPeriodpassword;
    if(!proxyPeriodpasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodpasswordQuery.get(), valueQuery_instance)){
            proxyPeriodpassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto proxyPeriodpasswordAtTypeHintQuery = request.query().get("proxy.password@TypeHint");
    Pistache::Optional<std::string> proxyPeriodpasswordAtTypeHint;
    if(!proxyPeriodpasswordAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(proxyPeriodpasswordAtTypeHintQuery.get(), valueQuery_instance)){
            proxyPeriodpasswordAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_config_apache_http_components_proxy_configuration(proxyPeriodhost, proxyPeriodhostAtTypeHint, proxyPeriodport, proxyPeriodportAtTypeHint, proxyPeriodexceptions, proxyPeriodexceptionsAtTypeHint, proxyPeriodenabled, proxyPeriodenabledAtTypeHint, proxyPerioduser, proxyPerioduserAtTypeHint, proxyPeriodpassword, proxyPeriodpasswordAtTypeHint, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_apache_sling_dav_ex_servlet_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto aliasQuery = request.query().get("alias");
    Pistache::Optional<std::string> alias;
    if(!aliasQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(aliasQuery.get(), valueQuery_instance)){
            alias = Pistache::Some(valueQuery_instance);
        }
    }
    auto aliasAtTypeHintQuery = request.query().get("alias@TypeHint");
    Pistache::Optional<std::string> aliasAtTypeHint;
    if(!aliasAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(aliasAtTypeHintQuery.get(), valueQuery_instance)){
            aliasAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto davPeriodcreateAbsoluteUriQuery = request.query().get("dav.create-absolute-uri");
    Pistache::Optional<bool> davPeriodcreateAbsoluteUri;
    if(!davPeriodcreateAbsoluteUriQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(davPeriodcreateAbsoluteUriQuery.get(), valueQuery_instance)){
            davPeriodcreateAbsoluteUri = Pistache::Some(valueQuery_instance);
        }
    }
    auto davPeriodcreateAbsoluteUriAtTypeHintQuery = request.query().get("dav.create-absolute-uri@TypeHint");
    Pistache::Optional<std::string> davPeriodcreateAbsoluteUriAtTypeHint;
    if(!davPeriodcreateAbsoluteUriAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(davPeriodcreateAbsoluteUriAtTypeHintQuery.get(), valueQuery_instance)){
            davPeriodcreateAbsoluteUriAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_config_apache_sling_dav_ex_servlet(alias, aliasAtTypeHint, davPeriodcreateAbsoluteUri, davPeriodcreateAbsoluteUriAtTypeHint, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_apache_sling_get_servlet_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto jsonPeriodmaximumresultsQuery = request.query().get("json.maximumresults");
    Pistache::Optional<std::string> jsonPeriodmaximumresults;
    if(!jsonPeriodmaximumresultsQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jsonPeriodmaximumresultsQuery.get(), valueQuery_instance)){
            jsonPeriodmaximumresults = Pistache::Some(valueQuery_instance);
        }
    }
    auto jsonPeriodmaximumresultsAtTypeHintQuery = request.query().get("json.maximumresults@TypeHint");
    Pistache::Optional<std::string> jsonPeriodmaximumresultsAtTypeHint;
    if(!jsonPeriodmaximumresultsAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jsonPeriodmaximumresultsAtTypeHintQuery.get(), valueQuery_instance)){
            jsonPeriodmaximumresultsAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto enablePeriodhtmlQuery = request.query().get("enable.html");
    Pistache::Optional<bool> enablePeriodhtml;
    if(!enablePeriodhtmlQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enablePeriodhtmlQuery.get(), valueQuery_instance)){
            enablePeriodhtml = Pistache::Some(valueQuery_instance);
        }
    }
    auto enablePeriodhtmlAtTypeHintQuery = request.query().get("enable.html@TypeHint");
    Pistache::Optional<std::string> enablePeriodhtmlAtTypeHint;
    if(!enablePeriodhtmlAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(enablePeriodhtmlAtTypeHintQuery.get(), valueQuery_instance)){
            enablePeriodhtmlAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto enablePeriodtxtQuery = request.query().get("enable.txt");
    Pistache::Optional<bool> enablePeriodtxt;
    if(!enablePeriodtxtQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enablePeriodtxtQuery.get(), valueQuery_instance)){
            enablePeriodtxt = Pistache::Some(valueQuery_instance);
        }
    }
    auto enablePeriodtxtAtTypeHintQuery = request.query().get("enable.txt@TypeHint");
    Pistache::Optional<std::string> enablePeriodtxtAtTypeHint;
    if(!enablePeriodtxtAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(enablePeriodtxtAtTypeHintQuery.get(), valueQuery_instance)){
            enablePeriodtxtAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto enablePeriodxmlQuery = request.query().get("enable.xml");
    Pistache::Optional<bool> enablePeriodxml;
    if(!enablePeriodxmlQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enablePeriodxmlQuery.get(), valueQuery_instance)){
            enablePeriodxml = Pistache::Some(valueQuery_instance);
        }
    }
    auto enablePeriodxmlAtTypeHintQuery = request.query().get("enable.xml@TypeHint");
    Pistache::Optional<std::string> enablePeriodxmlAtTypeHint;
    if(!enablePeriodxmlAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(enablePeriodxmlAtTypeHintQuery.get(), valueQuery_instance)){
            enablePeriodxmlAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_config_apache_sling_get_servlet(jsonPeriodmaximumresults, jsonPeriodmaximumresultsAtTypeHint, enablePeriodhtml, enablePeriodhtmlAtTypeHint, enablePeriodtxt, enablePeriodtxtAtTypeHint, enablePeriodxml, enablePeriodxmlAtTypeHint, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_apache_sling_referrer_filter_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto allowPeriodemptyQuery = request.query().get("allow.empty");
    Pistache::Optional<bool> allowPeriodempty;
    if(!allowPeriodemptyQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(allowPeriodemptyQuery.get(), valueQuery_instance)){
            allowPeriodempty = Pistache::Some(valueQuery_instance);
        }
    }
    auto allowPeriodemptyAtTypeHintQuery = request.query().get("allow.empty@TypeHint");
    Pistache::Optional<std::string> allowPeriodemptyAtTypeHint;
    if(!allowPeriodemptyAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(allowPeriodemptyAtTypeHintQuery.get(), valueQuery_instance)){
            allowPeriodemptyAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto allowPeriodhostsQuery = request.query().get("allow.hosts");
    Pistache::Optional<std::string> allowPeriodhosts;
    if(!allowPeriodhostsQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(allowPeriodhostsQuery.get(), valueQuery_instance)){
            allowPeriodhosts = Pistache::Some(valueQuery_instance);
        }
    }
    auto allowPeriodhostsAtTypeHintQuery = request.query().get("allow.hosts@TypeHint");
    Pistache::Optional<std::string> allowPeriodhostsAtTypeHint;
    if(!allowPeriodhostsAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(allowPeriodhostsAtTypeHintQuery.get(), valueQuery_instance)){
            allowPeriodhostsAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto allowPeriodhostsPeriodregexpQuery = request.query().get("allow.hosts.regexp");
    Pistache::Optional<std::string> allowPeriodhostsPeriodregexp;
    if(!allowPeriodhostsPeriodregexpQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(allowPeriodhostsPeriodregexpQuery.get(), valueQuery_instance)){
            allowPeriodhostsPeriodregexp = Pistache::Some(valueQuery_instance);
        }
    }
    auto allowPeriodhostsPeriodregexpAtTypeHintQuery = request.query().get("allow.hosts.regexp@TypeHint");
    Pistache::Optional<std::string> allowPeriodhostsPeriodregexpAtTypeHint;
    if(!allowPeriodhostsPeriodregexpAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(allowPeriodhostsPeriodregexpAtTypeHintQuery.get(), valueQuery_instance)){
            allowPeriodhostsPeriodregexpAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    auto filterPeriodmethodsQuery = request.query().get("filter.methods");
    Pistache::Optional<std::string> filterPeriodmethods;
    if(!filterPeriodmethodsQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(filterPeriodmethodsQuery.get(), valueQuery_instance)){
            filterPeriodmethods = Pistache::Some(valueQuery_instance);
        }
    }
    auto filterPeriodmethodsAtTypeHintQuery = request.query().get("filter.methods@TypeHint");
    Pistache::Optional<std::string> filterPeriodmethodsAtTypeHint;
    if(!filterPeriodmethodsAtTypeHintQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(filterPeriodmethodsAtTypeHintQuery.get(), valueQuery_instance)){
            filterPeriodmethodsAtTypeHint = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_config_apache_sling_referrer_filter(allowPeriodempty, allowPeriodemptyAtTypeHint, allowPeriodhosts, allowPeriodhostsAtTypeHint, allowPeriodhostsPeriodregexp, allowPeriodhostsPeriodregexpAtTypeHint, filterPeriodmethods, filterPeriodmethodsAtTypeHint, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_config_property_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto configNodeName = request.param(":configNodeName").as<std::string>();
    
    try {
        this->post_config_property(configNodeName, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_node_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    try {
      this->post_node(request, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_node_rw_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto path = request.param(":path").as<std::string>();
    auto name = request.param(":name").as<std::string>();
    
    // Getting the query params
    auto addMembersQuery = request.query().get("addMembers");
    Pistache::Optional<std::string> addMembers;
    if(!addMembersQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(addMembersQuery.get(), valueQuery_instance)){
            addMembers = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_node_rw(path, name, addMembers, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_path_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto path = request.param(":path").as<std::string>();
    
    // Getting the query params
    auto jcrPrimaryTypeQuery = request.query().get("jcr:primaryType");
    Pistache::Optional<std::string> jcrPrimaryType;
    if(!jcrPrimaryTypeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(jcrPrimaryTypeQuery.get(), valueQuery_instance)){
            jcrPrimaryType = Pistache::Some(valueQuery_instance);
        }
    }
    auto nameQuery = request.query().get(":name");
    Pistache::Optional<std::string> name;
    if(!nameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(nameQuery.get(), valueQuery_instance)){
            name = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_path(path, jcrPrimaryType, name, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_query_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto pathQuery = request.query().get("path");
    Pistache::Optional<std::string> path;
    if(!pathQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(pathQuery.get(), valueQuery_instance)){
            path = Pistache::Some(valueQuery_instance);
        }
    }
    auto pPeriodlimitQuery = request.query().get("p.limit");
    Pistache::Optional<double> pPeriodlimit;
    if(!pPeriodlimitQuery.isEmpty()){
        double valueQuery_instance;
        if(fromStringValue(pPeriodlimitQuery.get(), valueQuery_instance)){
            pPeriodlimit = Pistache::Some(valueQuery_instance);
        }
    }
    auto r_1_propertyQuery = request.query().get("1_property");
    Pistache::Optional<std::string> r_1_property;
    if(!r_1_propertyQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(r_1_propertyQuery.get(), valueQuery_instance)){
            r_1_property = Pistache::Some(valueQuery_instance);
        }
    }
    auto r_1_property_valueQuery = request.query().get("1_property.value");
    Pistache::Optional<std::string> r_1_property_value;
    if(!r_1_property_valueQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(r_1_property_valueQuery.get(), valueQuery_instance)){
            r_1_property_value = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_query(path, pPeriodlimit, r_1_property, r_1_property_value, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_tree_activation_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto ignoredeactivatedQuery = request.query().get("ignoredeactivated");
    Pistache::Optional<bool> ignoredeactivated;
    if(!ignoredeactivatedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(ignoredeactivatedQuery.get(), valueQuery_instance)){
            ignoredeactivated = Pistache::Some(valueQuery_instance);
        }
    }
    auto onlymodifiedQuery = request.query().get("onlymodified");
    Pistache::Optional<bool> onlymodified;
    if(!onlymodifiedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(onlymodifiedQuery.get(), valueQuery_instance)){
            onlymodified = Pistache::Some(valueQuery_instance);
        }
    }
    auto pathQuery = request.query().get("path");
    Pistache::Optional<std::string> path;
    if(!pathQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(pathQuery.get(), valueQuery_instance)){
            path = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->post_tree_activation(ignoredeactivated, onlymodified, path, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_truststore_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    try {
      this->post_truststore(request, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void SlingApi::post_truststore_pkcs12_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    try {
      this->post_truststore_pkcs12(request, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}

void SlingApi::sling_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

