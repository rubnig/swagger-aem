<?php

/**
 * SlingController
 * PHP version 7.1.3
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * Adobe Experience Manager (AEM) API
 *
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\SlingApiInterface;
use OpenAPI\Server\Model\KeystoreInfo;
use OpenAPI\Server\Model\TruststoreInfo;

/**
 * SlingController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class SlingController extends Controller
{

    /**
     * Operation deleteAgent
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function deleteAgentAction(Request $request, $runmode, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $runmode = $this->deserialize($runmode, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->deleteAgent($runmode, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation deleteNode
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function deleteNodeAction(Request $request, $path, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->deleteNode($path, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAgent
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAgentAction(Request $request, $runmode, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $runmode = $this->deserialize($runmode, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->getAgent($runmode, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAgents
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAgentsAction(Request $request, $runmode)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $runmode = $this->deserialize($runmode, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getAgents($runmode, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAuthorizableKeystore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAuthorizableKeystoreAction(Request $request, $intermediatePath, $authorizableId)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
            $authorizableId = $this->deserialize($authorizableId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getAuthorizableKeystore($intermediatePath, $authorizableId, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieved Authorizable Keystore info';
                    break;
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getKeystore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getKeystoreAction(Request $request, $intermediatePath, $authorizableId)
    {
        // Figure out what data format to return to the client
        $produces = ['application/octet-stream'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
            $authorizableId = $this->deserialize($authorizableId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getKeystore($intermediatePath, $authorizableId, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getNode
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getNodeAction(Request $request, $path, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->getNode($path, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getPackage
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getPackageAction(Request $request, $group, $name, $version)
    {
        // Figure out what data format to return to the client
        $produces = ['application/octet-stream'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $group = $this->deserialize($group, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
            $version = $this->deserialize($version, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($group, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($version, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getPackage($group, $name, $version, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getPackageFilter
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getPackageFilterAction(Request $request, $group, $name, $version)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $group = $this->deserialize($group, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
            $version = $this->deserialize($version, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($group, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($version, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getPackageFilter($group, $name, $version, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getQuery
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getQueryAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $path = $request->query->get('path');
        $pLimit = $request->query->get('pLimit');
        $_1property = $request->query->get('_1property');
        $_1propertyValue = $request->query->get('_1propertyValue');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $pLimit = $this->deserialize($pLimit, 'float', 'string');
            $_1property = $this->deserialize($_1property, 'string', 'string');
            $_1propertyValue = $this->deserialize($_1propertyValue, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($pLimit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1property, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1propertyValue, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getQuery($path, $pLimit, $_1property, $_1propertyValue, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getTruststore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getTruststoreAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/octet-stream'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getTruststore($responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getTruststoreInfo
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getTruststoreInfoAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->getTruststoreInfo($responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieved AEM Truststore info';
                    break;
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postAgent
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postAgentAction(Request $request, $runmode, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jcrcontentCqdistribute = $request->query->get('jcrcontentCqdistribute');
        $jcrcontentCqdistributeTypeHint = $request->query->get('jcrcontentCqdistributeTypeHint');
        $jcrcontentCqname = $request->query->get('jcrcontentCqname');
        $jcrcontentCqtemplate = $request->query->get('jcrcontentCqtemplate');
        $jcrcontentEnabled = $request->query->get('jcrcontentEnabled');
        $jcrcontentJcrdescription = $request->query->get('jcrcontentJcrdescription');
        $jcrcontentJcrlastModified = $request->query->get('jcrcontentJcrlastModified');
        $jcrcontentJcrlastModifiedBy = $request->query->get('jcrcontentJcrlastModifiedBy');
        $jcrcontentJcrmixinTypes = $request->query->get('jcrcontentJcrmixinTypes');
        $jcrcontentJcrtitle = $request->query->get('jcrcontentJcrtitle');
        $jcrcontentLogLevel = $request->query->get('jcrcontentLogLevel');
        $jcrcontentNoStatusUpdate = $request->query->get('jcrcontentNoStatusUpdate');
        $jcrcontentNoVersioning = $request->query->get('jcrcontentNoVersioning');
        $jcrcontentProtocolConnectTimeout = $request->query->get('jcrcontentProtocolConnectTimeout');
        $jcrcontentProtocolHTTPConnectionClosed = $request->query->get('jcrcontentProtocolHTTPConnectionClosed');
        $jcrcontentProtocolHTTPExpired = $request->query->get('jcrcontentProtocolHTTPExpired');
        $jcrcontentProtocolHTTPHeaders = $request->query->get('jcrcontentProtocolHTTPHeaders');
        $jcrcontentProtocolHTTPHeadersTypeHint = $request->query->get('jcrcontentProtocolHTTPHeadersTypeHint');
        $jcrcontentProtocolHTTPMethod = $request->query->get('jcrcontentProtocolHTTPMethod');
        $jcrcontentProtocolHTTPSRelaxed = $request->query->get('jcrcontentProtocolHTTPSRelaxed');
        $jcrcontentProtocolInterface = $request->query->get('jcrcontentProtocolInterface');
        $jcrcontentProtocolSocketTimeout = $request->query->get('jcrcontentProtocolSocketTimeout');
        $jcrcontentProtocolVersion = $request->query->get('jcrcontentProtocolVersion');
        $jcrcontentProxyNTLMDomain = $request->query->get('jcrcontentProxyNTLMDomain');
        $jcrcontentProxyNTLMHost = $request->query->get('jcrcontentProxyNTLMHost');
        $jcrcontentProxyHost = $request->query->get('jcrcontentProxyHost');
        $jcrcontentProxyPassword = $request->query->get('jcrcontentProxyPassword');
        $jcrcontentProxyPort = $request->query->get('jcrcontentProxyPort');
        $jcrcontentProxyUser = $request->query->get('jcrcontentProxyUser');
        $jcrcontentQueueBatchMaxSize = $request->query->get('jcrcontentQueueBatchMaxSize');
        $jcrcontentQueueBatchMode = $request->query->get('jcrcontentQueueBatchMode');
        $jcrcontentQueueBatchWaitTime = $request->query->get('jcrcontentQueueBatchWaitTime');
        $jcrcontentRetryDelay = $request->query->get('jcrcontentRetryDelay');
        $jcrcontentReverseReplication = $request->query->get('jcrcontentReverseReplication');
        $jcrcontentSerializationType = $request->query->get('jcrcontentSerializationType');
        $jcrcontentSlingresourceType = $request->query->get('jcrcontentSlingresourceType');
        $jcrcontentSsl = $request->query->get('jcrcontentSsl');
        $jcrcontentTransportNTLMDomain = $request->query->get('jcrcontentTransportNTLMDomain');
        $jcrcontentTransportNTLMHost = $request->query->get('jcrcontentTransportNTLMHost');
        $jcrcontentTransportPassword = $request->query->get('jcrcontentTransportPassword');
        $jcrcontentTransportUri = $request->query->get('jcrcontentTransportUri');
        $jcrcontentTransportUser = $request->query->get('jcrcontentTransportUser');
        $jcrcontentTriggerDistribute = $request->query->get('jcrcontentTriggerDistribute');
        $jcrcontentTriggerModified = $request->query->get('jcrcontentTriggerModified');
        $jcrcontentTriggerOnOffTime = $request->query->get('jcrcontentTriggerOnOffTime');
        $jcrcontentTriggerReceive = $request->query->get('jcrcontentTriggerReceive');
        $jcrcontentTriggerSpecific = $request->query->get('jcrcontentTriggerSpecific');
        $jcrcontentUserId = $request->query->get('jcrcontentUserId');
        $jcrprimaryType = $request->query->get('jcrprimaryType');
        $operation = $request->query->get('operation');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $runmode = $this->deserialize($runmode, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
            $jcrcontentCqdistribute = $this->deserialize($jcrcontentCqdistribute, 'bool', 'string');
            $jcrcontentCqdistributeTypeHint = $this->deserialize($jcrcontentCqdistributeTypeHint, 'string', 'string');
            $jcrcontentCqname = $this->deserialize($jcrcontentCqname, 'string', 'string');
            $jcrcontentCqtemplate = $this->deserialize($jcrcontentCqtemplate, 'string', 'string');
            $jcrcontentEnabled = $this->deserialize($jcrcontentEnabled, 'bool', 'string');
            $jcrcontentJcrdescription = $this->deserialize($jcrcontentJcrdescription, 'string', 'string');
            $jcrcontentJcrlastModified = $this->deserialize($jcrcontentJcrlastModified, 'string', 'string');
            $jcrcontentJcrlastModifiedBy = $this->deserialize($jcrcontentJcrlastModifiedBy, 'string', 'string');
            $jcrcontentJcrmixinTypes = $this->deserialize($jcrcontentJcrmixinTypes, 'string', 'string');
            $jcrcontentJcrtitle = $this->deserialize($jcrcontentJcrtitle, 'string', 'string');
            $jcrcontentLogLevel = $this->deserialize($jcrcontentLogLevel, 'string', 'string');
            $jcrcontentNoStatusUpdate = $this->deserialize($jcrcontentNoStatusUpdate, 'bool', 'string');
            $jcrcontentNoVersioning = $this->deserialize($jcrcontentNoVersioning, 'bool', 'string');
            $jcrcontentProtocolConnectTimeout = $this->deserialize($jcrcontentProtocolConnectTimeout, 'float', 'string');
            $jcrcontentProtocolHTTPConnectionClosed = $this->deserialize($jcrcontentProtocolHTTPConnectionClosed, 'bool', 'string');
            $jcrcontentProtocolHTTPExpired = $this->deserialize($jcrcontentProtocolHTTPExpired, 'string', 'string');
            $jcrcontentProtocolHTTPHeaders = $this->deserialize($jcrcontentProtocolHTTPHeaders, 'array<multi,string>', 'string');
            $jcrcontentProtocolHTTPHeadersTypeHint = $this->deserialize($jcrcontentProtocolHTTPHeadersTypeHint, 'string', 'string');
            $jcrcontentProtocolHTTPMethod = $this->deserialize($jcrcontentProtocolHTTPMethod, 'string', 'string');
            $jcrcontentProtocolHTTPSRelaxed = $this->deserialize($jcrcontentProtocolHTTPSRelaxed, 'bool', 'string');
            $jcrcontentProtocolInterface = $this->deserialize($jcrcontentProtocolInterface, 'string', 'string');
            $jcrcontentProtocolSocketTimeout = $this->deserialize($jcrcontentProtocolSocketTimeout, 'float', 'string');
            $jcrcontentProtocolVersion = $this->deserialize($jcrcontentProtocolVersion, 'string', 'string');
            $jcrcontentProxyNTLMDomain = $this->deserialize($jcrcontentProxyNTLMDomain, 'string', 'string');
            $jcrcontentProxyNTLMHost = $this->deserialize($jcrcontentProxyNTLMHost, 'string', 'string');
            $jcrcontentProxyHost = $this->deserialize($jcrcontentProxyHost, 'string', 'string');
            $jcrcontentProxyPassword = $this->deserialize($jcrcontentProxyPassword, 'string', 'string');
            $jcrcontentProxyPort = $this->deserialize($jcrcontentProxyPort, 'float', 'string');
            $jcrcontentProxyUser = $this->deserialize($jcrcontentProxyUser, 'string', 'string');
            $jcrcontentQueueBatchMaxSize = $this->deserialize($jcrcontentQueueBatchMaxSize, 'float', 'string');
            $jcrcontentQueueBatchMode = $this->deserialize($jcrcontentQueueBatchMode, 'string', 'string');
            $jcrcontentQueueBatchWaitTime = $this->deserialize($jcrcontentQueueBatchWaitTime, 'float', 'string');
            $jcrcontentRetryDelay = $this->deserialize($jcrcontentRetryDelay, 'string', 'string');
            $jcrcontentReverseReplication = $this->deserialize($jcrcontentReverseReplication, 'bool', 'string');
            $jcrcontentSerializationType = $this->deserialize($jcrcontentSerializationType, 'string', 'string');
            $jcrcontentSlingresourceType = $this->deserialize($jcrcontentSlingresourceType, 'string', 'string');
            $jcrcontentSsl = $this->deserialize($jcrcontentSsl, 'string', 'string');
            $jcrcontentTransportNTLMDomain = $this->deserialize($jcrcontentTransportNTLMDomain, 'string', 'string');
            $jcrcontentTransportNTLMHost = $this->deserialize($jcrcontentTransportNTLMHost, 'string', 'string');
            $jcrcontentTransportPassword = $this->deserialize($jcrcontentTransportPassword, 'string', 'string');
            $jcrcontentTransportUri = $this->deserialize($jcrcontentTransportUri, 'string', 'string');
            $jcrcontentTransportUser = $this->deserialize($jcrcontentTransportUser, 'string', 'string');
            $jcrcontentTriggerDistribute = $this->deserialize($jcrcontentTriggerDistribute, 'bool', 'string');
            $jcrcontentTriggerModified = $this->deserialize($jcrcontentTriggerModified, 'bool', 'string');
            $jcrcontentTriggerOnOffTime = $this->deserialize($jcrcontentTriggerOnOffTime, 'bool', 'string');
            $jcrcontentTriggerReceive = $this->deserialize($jcrcontentTriggerReceive, 'bool', 'string');
            $jcrcontentTriggerSpecific = $this->deserialize($jcrcontentTriggerSpecific, 'bool', 'string');
            $jcrcontentUserId = $this->deserialize($jcrcontentUserId, 'string', 'string');
            $jcrprimaryType = $this->deserialize($jcrprimaryType, 'string', 'string');
            $operation = $this->deserialize($operation, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($runmode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentCqdistribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentCqdistributeTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentCqname, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentCqtemplate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentEnabled, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentJcrdescription, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentJcrlastModified, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentJcrlastModifiedBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentJcrmixinTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentJcrtitle, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentLogLevel, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentNoStatusUpdate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentNoVersioning, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentProtocolConnectTimeout, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentProtocolHTTPConnectionClosed, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProtocolHTTPExpired, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($jcrcontentProtocolHTTPHeaders, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProtocolHTTPHeadersTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProtocolHTTPMethod, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentProtocolHTTPSRelaxed, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProtocolInterface, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentProtocolSocketTimeout, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProtocolVersion, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProxyNTLMDomain, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProxyNTLMHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProxyHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProxyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentProxyPort, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentProxyUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentQueueBatchMaxSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentQueueBatchMode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($jcrcontentQueueBatchWaitTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentRetryDelay, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentReverseReplication, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentSerializationType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentSlingresourceType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentSsl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentTransportNTLMDomain, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentTransportNTLMHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentTransportPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentTransportUri, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentTransportUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentTriggerDistribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentTriggerModified, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentTriggerOnOffTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentTriggerReceive, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($jcrcontentTriggerSpecific, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrcontentUserId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrprimaryType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postAgent($runmode, $name, $jcrcontentCqdistribute, $jcrcontentCqdistributeTypeHint, $jcrcontentCqname, $jcrcontentCqtemplate, $jcrcontentEnabled, $jcrcontentJcrdescription, $jcrcontentJcrlastModified, $jcrcontentJcrlastModifiedBy, $jcrcontentJcrmixinTypes, $jcrcontentJcrtitle, $jcrcontentLogLevel, $jcrcontentNoStatusUpdate, $jcrcontentNoVersioning, $jcrcontentProtocolConnectTimeout, $jcrcontentProtocolHTTPConnectionClosed, $jcrcontentProtocolHTTPExpired, $jcrcontentProtocolHTTPHeaders, $jcrcontentProtocolHTTPHeadersTypeHint, $jcrcontentProtocolHTTPMethod, $jcrcontentProtocolHTTPSRelaxed, $jcrcontentProtocolInterface, $jcrcontentProtocolSocketTimeout, $jcrcontentProtocolVersion, $jcrcontentProxyNTLMDomain, $jcrcontentProxyNTLMHost, $jcrcontentProxyHost, $jcrcontentProxyPassword, $jcrcontentProxyPort, $jcrcontentProxyUser, $jcrcontentQueueBatchMaxSize, $jcrcontentQueueBatchMode, $jcrcontentQueueBatchWaitTime, $jcrcontentRetryDelay, $jcrcontentReverseReplication, $jcrcontentSerializationType, $jcrcontentSlingresourceType, $jcrcontentSsl, $jcrcontentTransportNTLMDomain, $jcrcontentTransportNTLMHost, $jcrcontentTransportPassword, $jcrcontentTransportUri, $jcrcontentTransportUser, $jcrcontentTriggerDistribute, $jcrcontentTriggerModified, $jcrcontentTriggerOnOffTime, $jcrcontentTriggerReceive, $jcrcontentTriggerSpecific, $jcrcontentUserId, $jcrprimaryType, $operation, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postAuthorizableKeystore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postAuthorizableKeystoreAction(Request $request, $intermediatePath, $authorizableId)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $operation = $request->query->get('operation');
        $currentPassword = $request->query->get('currentPassword');
        $newPassword = $request->query->get('newPassword');
        $rePassword = $request->query->get('rePassword');
        $keyPassword = $request->query->get('keyPassword');
        $keyStorePass = $request->query->get('keyStorePass');
        $alias = $request->query->get('alias');
        $newAlias = $request->query->get('newAlias');
        $removeAlias = $request->query->get('removeAlias');
        $certChain = $request->files->get('certChain');
        $pk = $request->files->get('pk');
        $keyStore = $request->files->get('keyStore');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
            $authorizableId = $this->deserialize($authorizableId, 'string', 'string');
            $operation = $this->deserialize($operation, 'string', 'string');
            $currentPassword = $this->deserialize($currentPassword, 'string', 'string');
            $newPassword = $this->deserialize($newPassword, 'string', 'string');
            $rePassword = $this->deserialize($rePassword, 'string', 'string');
            $keyPassword = $this->deserialize($keyPassword, 'string', 'string');
            $keyStorePass = $this->deserialize($keyStorePass, 'string', 'string');
            $alias = $this->deserialize($alias, 'string', 'string');
            $newAlias = $this->deserialize($newAlias, 'string', 'string');
            $removeAlias = $this->deserialize($removeAlias, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($currentPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($newPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($rePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStorePass, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($alias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($newAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($removeAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($certChain, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($pk, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($keyStore, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postAuthorizableKeystore($intermediatePath, $authorizableId, $operation, $currentPassword, $newPassword, $rePassword, $keyPassword, $keyStorePass, $alias, $newAlias, $removeAlias, $certChain, $pk, $keyStore, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieved Authorizable Keystore info';
                    break;
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postAuthorizables
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postAuthorizablesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['text/html'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $authorizableId = $request->query->get('authorizableId');
        $intermediatePath = $request->query->get('intermediatePath');
        $createUser = $request->query->get('createUser');
        $createGroup = $request->query->get('createGroup');
        $reppassword = $request->query->get('reppassword');
        $profileGivenName = $request->query->get('profileGivenName');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $authorizableId = $this->deserialize($authorizableId, 'string', 'string');
            $intermediatePath = $this->deserialize($intermediatePath, 'string', 'string');
            $createUser = $this->deserialize($createUser, 'string', 'string');
            $createGroup = $this->deserialize($createGroup, 'string', 'string');
            $reppassword = $this->deserialize($reppassword, 'string', 'string');
            $profileGivenName = $this->deserialize($profileGivenName, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($authorizableId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($intermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($createUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($createGroup, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($reppassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($profileGivenName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postAuthorizables($authorizableId, $intermediatePath, $createUser, $createGroup, $reppassword, $profileGivenName, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigAdobeGraniteSamlAuthenticationHandler
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigAdobeGraniteSamlAuthenticationHandlerAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $keyStorePassword = $request->query->get('keyStorePassword');
        $keyStorePasswordTypeHint = $request->query->get('keyStorePasswordTypeHint');
        $serviceRanking = $request->query->get('serviceRanking');
        $serviceRankingTypeHint = $request->query->get('serviceRankingTypeHint');
        $idpHttpRedirect = $request->query->get('idpHttpRedirect');
        $idpHttpRedirectTypeHint = $request->query->get('idpHttpRedirectTypeHint');
        $createUser = $request->query->get('createUser');
        $createUserTypeHint = $request->query->get('createUserTypeHint');
        $defaultRedirectUrl = $request->query->get('defaultRedirectUrl');
        $defaultRedirectUrlTypeHint = $request->query->get('defaultRedirectUrlTypeHint');
        $userIDAttribute = $request->query->get('userIDAttribute');
        $userIDAttributeTypeHint = $request->query->get('userIDAttributeTypeHint');
        $defaultGroups = $request->query->get('defaultGroups');
        $defaultGroupsTypeHint = $request->query->get('defaultGroupsTypeHint');
        $idpCertAlias = $request->query->get('idpCertAlias');
        $idpCertAliasTypeHint = $request->query->get('idpCertAliasTypeHint');
        $addGroupMemberships = $request->query->get('addGroupMemberships');
        $addGroupMembershipsTypeHint = $request->query->get('addGroupMembershipsTypeHint');
        $path = $request->query->get('path');
        $pathTypeHint = $request->query->get('pathTypeHint');
        $synchronizeAttributes = $request->query->get('synchronizeAttributes');
        $synchronizeAttributesTypeHint = $request->query->get('synchronizeAttributesTypeHint');
        $clockTolerance = $request->query->get('clockTolerance');
        $clockToleranceTypeHint = $request->query->get('clockToleranceTypeHint');
        $groupMembershipAttribute = $request->query->get('groupMembershipAttribute');
        $groupMembershipAttributeTypeHint = $request->query->get('groupMembershipAttributeTypeHint');
        $idpUrl = $request->query->get('idpUrl');
        $idpUrlTypeHint = $request->query->get('idpUrlTypeHint');
        $logoutUrl = $request->query->get('logoutUrl');
        $logoutUrlTypeHint = $request->query->get('logoutUrlTypeHint');
        $serviceProviderEntityId = $request->query->get('serviceProviderEntityId');
        $serviceProviderEntityIdTypeHint = $request->query->get('serviceProviderEntityIdTypeHint');
        $assertionConsumerServiceURL = $request->query->get('assertionConsumerServiceURL');
        $assertionConsumerServiceURLTypeHint = $request->query->get('assertionConsumerServiceURLTypeHint');
        $handleLogout = $request->query->get('handleLogout');
        $handleLogoutTypeHint = $request->query->get('handleLogoutTypeHint');
        $spPrivateKeyAlias = $request->query->get('spPrivateKeyAlias');
        $spPrivateKeyAliasTypeHint = $request->query->get('spPrivateKeyAliasTypeHint');
        $useEncryption = $request->query->get('useEncryption');
        $useEncryptionTypeHint = $request->query->get('useEncryptionTypeHint');
        $nameIdFormat = $request->query->get('nameIdFormat');
        $nameIdFormatTypeHint = $request->query->get('nameIdFormatTypeHint');
        $digestMethod = $request->query->get('digestMethod');
        $digestMethodTypeHint = $request->query->get('digestMethodTypeHint');
        $signatureMethod = $request->query->get('signatureMethod');
        $signatureMethodTypeHint = $request->query->get('signatureMethodTypeHint');
        $userIntermediatePath = $request->query->get('userIntermediatePath');
        $userIntermediatePathTypeHint = $request->query->get('userIntermediatePathTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $keyStorePassword = $this->deserialize($keyStorePassword, 'string', 'string');
            $keyStorePasswordTypeHint = $this->deserialize($keyStorePasswordTypeHint, 'string', 'string');
            $serviceRanking = $this->deserialize($serviceRanking, 'int', 'string');
            $serviceRankingTypeHint = $this->deserialize($serviceRankingTypeHint, 'string', 'string');
            $idpHttpRedirect = $this->deserialize($idpHttpRedirect, 'bool', 'string');
            $idpHttpRedirectTypeHint = $this->deserialize($idpHttpRedirectTypeHint, 'string', 'string');
            $createUser = $this->deserialize($createUser, 'bool', 'string');
            $createUserTypeHint = $this->deserialize($createUserTypeHint, 'string', 'string');
            $defaultRedirectUrl = $this->deserialize($defaultRedirectUrl, 'string', 'string');
            $defaultRedirectUrlTypeHint = $this->deserialize($defaultRedirectUrlTypeHint, 'string', 'string');
            $userIDAttribute = $this->deserialize($userIDAttribute, 'string', 'string');
            $userIDAttributeTypeHint = $this->deserialize($userIDAttributeTypeHint, 'string', 'string');
            $defaultGroups = $this->deserialize($defaultGroups, 'array<multi,string>', 'string');
            $defaultGroupsTypeHint = $this->deserialize($defaultGroupsTypeHint, 'string', 'string');
            $idpCertAlias = $this->deserialize($idpCertAlias, 'string', 'string');
            $idpCertAliasTypeHint = $this->deserialize($idpCertAliasTypeHint, 'string', 'string');
            $addGroupMemberships = $this->deserialize($addGroupMemberships, 'bool', 'string');
            $addGroupMembershipsTypeHint = $this->deserialize($addGroupMembershipsTypeHint, 'string', 'string');
            $path = $this->deserialize($path, 'array<multi,string>', 'string');
            $pathTypeHint = $this->deserialize($pathTypeHint, 'string', 'string');
            $synchronizeAttributes = $this->deserialize($synchronizeAttributes, 'array<multi,string>', 'string');
            $synchronizeAttributesTypeHint = $this->deserialize($synchronizeAttributesTypeHint, 'string', 'string');
            $clockTolerance = $this->deserialize($clockTolerance, 'int', 'string');
            $clockToleranceTypeHint = $this->deserialize($clockToleranceTypeHint, 'string', 'string');
            $groupMembershipAttribute = $this->deserialize($groupMembershipAttribute, 'string', 'string');
            $groupMembershipAttributeTypeHint = $this->deserialize($groupMembershipAttributeTypeHint, 'string', 'string');
            $idpUrl = $this->deserialize($idpUrl, 'string', 'string');
            $idpUrlTypeHint = $this->deserialize($idpUrlTypeHint, 'string', 'string');
            $logoutUrl = $this->deserialize($logoutUrl, 'string', 'string');
            $logoutUrlTypeHint = $this->deserialize($logoutUrlTypeHint, 'string', 'string');
            $serviceProviderEntityId = $this->deserialize($serviceProviderEntityId, 'string', 'string');
            $serviceProviderEntityIdTypeHint = $this->deserialize($serviceProviderEntityIdTypeHint, 'string', 'string');
            $assertionConsumerServiceURL = $this->deserialize($assertionConsumerServiceURL, 'string', 'string');
            $assertionConsumerServiceURLTypeHint = $this->deserialize($assertionConsumerServiceURLTypeHint, 'string', 'string');
            $handleLogout = $this->deserialize($handleLogout, 'bool', 'string');
            $handleLogoutTypeHint = $this->deserialize($handleLogoutTypeHint, 'string', 'string');
            $spPrivateKeyAlias = $this->deserialize($spPrivateKeyAlias, 'string', 'string');
            $spPrivateKeyAliasTypeHint = $this->deserialize($spPrivateKeyAliasTypeHint, 'string', 'string');
            $useEncryption = $this->deserialize($useEncryption, 'bool', 'string');
            $useEncryptionTypeHint = $this->deserialize($useEncryptionTypeHint, 'string', 'string');
            $nameIdFormat = $this->deserialize($nameIdFormat, 'string', 'string');
            $nameIdFormatTypeHint = $this->deserialize($nameIdFormatTypeHint, 'string', 'string');
            $digestMethod = $this->deserialize($digestMethod, 'string', 'string');
            $digestMethodTypeHint = $this->deserialize($digestMethodTypeHint, 'string', 'string');
            $signatureMethod = $this->deserialize($signatureMethod, 'string', 'string');
            $signatureMethodTypeHint = $this->deserialize($signatureMethodTypeHint, 'string', 'string');
            $userIntermediatePath = $this->deserialize($userIntermediatePath, 'string', 'string');
            $userIntermediatePathTypeHint = $this->deserialize($userIntermediatePathTypeHint, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStorePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStorePasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($serviceRanking, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($serviceRankingTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($idpHttpRedirect, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpHttpRedirectTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($createUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($createUserTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($defaultRedirectUrl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($defaultRedirectUrlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIDAttribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIDAttributeTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($defaultGroups, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($defaultGroupsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpCertAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpCertAliasTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($addGroupMemberships, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($addGroupMembershipsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($pathTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($synchronizeAttributes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($synchronizeAttributesTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($clockTolerance, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($clockToleranceTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($groupMembershipAttribute, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($groupMembershipAttributeTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpUrl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($idpUrlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($logoutUrl, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($logoutUrlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($serviceProviderEntityId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($serviceProviderEntityIdTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($assertionConsumerServiceURL, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($assertionConsumerServiceURLTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($handleLogout, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($handleLogoutTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($spPrivateKeyAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($spPrivateKeyAliasTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($useEncryption, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($useEncryptionTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($nameIdFormat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($nameIdFormatTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($digestMethod, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($digestMethodTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($signatureMethod, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($signatureMethodTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIntermediatePath, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($userIntermediatePathTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigAdobeGraniteSamlAuthenticationHandler($keyStorePassword, $keyStorePasswordTypeHint, $serviceRanking, $serviceRankingTypeHint, $idpHttpRedirect, $idpHttpRedirectTypeHint, $createUser, $createUserTypeHint, $defaultRedirectUrl, $defaultRedirectUrlTypeHint, $userIDAttribute, $userIDAttributeTypeHint, $defaultGroups, $defaultGroupsTypeHint, $idpCertAlias, $idpCertAliasTypeHint, $addGroupMemberships, $addGroupMembershipsTypeHint, $path, $pathTypeHint, $synchronizeAttributes, $synchronizeAttributesTypeHint, $clockTolerance, $clockToleranceTypeHint, $groupMembershipAttribute, $groupMembershipAttributeTypeHint, $idpUrl, $idpUrlTypeHint, $logoutUrl, $logoutUrlTypeHint, $serviceProviderEntityId, $serviceProviderEntityIdTypeHint, $assertionConsumerServiceURL, $assertionConsumerServiceURLTypeHint, $handleLogout, $handleLogoutTypeHint, $spPrivateKeyAlias, $spPrivateKeyAliasTypeHint, $useEncryption, $useEncryptionTypeHint, $nameIdFormat, $nameIdFormatTypeHint, $digestMethod, $digestMethodTypeHint, $signatureMethod, $signatureMethodTypeHint, $userIntermediatePath, $userIntermediatePathTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheFelixJettyBasedHttpService
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheFelixJettyBasedHttpServiceAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $orgApacheFelixHttpsNio = $request->query->get('orgApacheFelixHttpsNio');
        $orgApacheFelixHttpsNioTypeHint = $request->query->get('orgApacheFelixHttpsNioTypeHint');
        $orgApacheFelixHttpsKeystore = $request->query->get('orgApacheFelixHttpsKeystore');
        $orgApacheFelixHttpsKeystoreTypeHint = $request->query->get('orgApacheFelixHttpsKeystoreTypeHint');
        $orgApacheFelixHttpsKeystorePassword = $request->query->get('orgApacheFelixHttpsKeystorePassword');
        $orgApacheFelixHttpsKeystorePasswordTypeHint = $request->query->get('orgApacheFelixHttpsKeystorePasswordTypeHint');
        $orgApacheFelixHttpsKeystoreKey = $request->query->get('orgApacheFelixHttpsKeystoreKey');
        $orgApacheFelixHttpsKeystoreKeyTypeHint = $request->query->get('orgApacheFelixHttpsKeystoreKeyTypeHint');
        $orgApacheFelixHttpsKeystoreKeyPassword = $request->query->get('orgApacheFelixHttpsKeystoreKeyPassword');
        $orgApacheFelixHttpsKeystoreKeyPasswordTypeHint = $request->query->get('orgApacheFelixHttpsKeystoreKeyPasswordTypeHint');
        $orgApacheFelixHttpsTruststore = $request->query->get('orgApacheFelixHttpsTruststore');
        $orgApacheFelixHttpsTruststoreTypeHint = $request->query->get('orgApacheFelixHttpsTruststoreTypeHint');
        $orgApacheFelixHttpsTruststorePassword = $request->query->get('orgApacheFelixHttpsTruststorePassword');
        $orgApacheFelixHttpsTruststorePasswordTypeHint = $request->query->get('orgApacheFelixHttpsTruststorePasswordTypeHint');
        $orgApacheFelixHttpsClientcertificate = $request->query->get('orgApacheFelixHttpsClientcertificate');
        $orgApacheFelixHttpsClientcertificateTypeHint = $request->query->get('orgApacheFelixHttpsClientcertificateTypeHint');
        $orgApacheFelixHttpsEnable = $request->query->get('orgApacheFelixHttpsEnable');
        $orgApacheFelixHttpsEnableTypeHint = $request->query->get('orgApacheFelixHttpsEnableTypeHint');
        $orgOsgiServiceHttpPortSecure = $request->query->get('orgOsgiServiceHttpPortSecure');
        $orgOsgiServiceHttpPortSecureTypeHint = $request->query->get('orgOsgiServiceHttpPortSecureTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $orgApacheFelixHttpsNio = $this->deserialize($orgApacheFelixHttpsNio, 'bool', 'string');
            $orgApacheFelixHttpsNioTypeHint = $this->deserialize($orgApacheFelixHttpsNioTypeHint, 'string', 'string');
            $orgApacheFelixHttpsKeystore = $this->deserialize($orgApacheFelixHttpsKeystore, 'string', 'string');
            $orgApacheFelixHttpsKeystoreTypeHint = $this->deserialize($orgApacheFelixHttpsKeystoreTypeHint, 'string', 'string');
            $orgApacheFelixHttpsKeystorePassword = $this->deserialize($orgApacheFelixHttpsKeystorePassword, 'string', 'string');
            $orgApacheFelixHttpsKeystorePasswordTypeHint = $this->deserialize($orgApacheFelixHttpsKeystorePasswordTypeHint, 'string', 'string');
            $orgApacheFelixHttpsKeystoreKey = $this->deserialize($orgApacheFelixHttpsKeystoreKey, 'string', 'string');
            $orgApacheFelixHttpsKeystoreKeyTypeHint = $this->deserialize($orgApacheFelixHttpsKeystoreKeyTypeHint, 'string', 'string');
            $orgApacheFelixHttpsKeystoreKeyPassword = $this->deserialize($orgApacheFelixHttpsKeystoreKeyPassword, 'string', 'string');
            $orgApacheFelixHttpsKeystoreKeyPasswordTypeHint = $this->deserialize($orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, 'string', 'string');
            $orgApacheFelixHttpsTruststore = $this->deserialize($orgApacheFelixHttpsTruststore, 'string', 'string');
            $orgApacheFelixHttpsTruststoreTypeHint = $this->deserialize($orgApacheFelixHttpsTruststoreTypeHint, 'string', 'string');
            $orgApacheFelixHttpsTruststorePassword = $this->deserialize($orgApacheFelixHttpsTruststorePassword, 'string', 'string');
            $orgApacheFelixHttpsTruststorePasswordTypeHint = $this->deserialize($orgApacheFelixHttpsTruststorePasswordTypeHint, 'string', 'string');
            $orgApacheFelixHttpsClientcertificate = $this->deserialize($orgApacheFelixHttpsClientcertificate, 'string', 'string');
            $orgApacheFelixHttpsClientcertificateTypeHint = $this->deserialize($orgApacheFelixHttpsClientcertificateTypeHint, 'string', 'string');
            $orgApacheFelixHttpsEnable = $this->deserialize($orgApacheFelixHttpsEnable, 'bool', 'string');
            $orgApacheFelixHttpsEnableTypeHint = $this->deserialize($orgApacheFelixHttpsEnableTypeHint, 'string', 'string');
            $orgOsgiServiceHttpPortSecure = $this->deserialize($orgOsgiServiceHttpPortSecure, 'string', 'string');
            $orgOsgiServiceHttpPortSecureTypeHint = $this->deserialize($orgOsgiServiceHttpPortSecureTypeHint, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($orgApacheFelixHttpsNio, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsNioTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystore, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystorePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystorePasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKey, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKeyTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKeyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststore, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststoreTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststorePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsTruststorePasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsClientcertificate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsClientcertificateTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($orgApacheFelixHttpsEnable, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgApacheFelixHttpsEnableTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgOsgiServiceHttpPortSecure, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($orgOsgiServiceHttpPortSecureTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheFelixJettyBasedHttpService($orgApacheFelixHttpsNio, $orgApacheFelixHttpsNioTypeHint, $orgApacheFelixHttpsKeystore, $orgApacheFelixHttpsKeystoreTypeHint, $orgApacheFelixHttpsKeystorePassword, $orgApacheFelixHttpsKeystorePasswordTypeHint, $orgApacheFelixHttpsKeystoreKey, $orgApacheFelixHttpsKeystoreKeyTypeHint, $orgApacheFelixHttpsKeystoreKeyPassword, $orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, $orgApacheFelixHttpsTruststore, $orgApacheFelixHttpsTruststoreTypeHint, $orgApacheFelixHttpsTruststorePassword, $orgApacheFelixHttpsTruststorePasswordTypeHint, $orgApacheFelixHttpsClientcertificate, $orgApacheFelixHttpsClientcertificateTypeHint, $orgApacheFelixHttpsEnable, $orgApacheFelixHttpsEnableTypeHint, $orgOsgiServiceHttpPortSecure, $orgOsgiServiceHttpPortSecureTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheHttpComponentsProxyConfiguration
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheHttpComponentsProxyConfigurationAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $proxyHost = $request->query->get('proxyHost');
        $proxyHostTypeHint = $request->query->get('proxyHostTypeHint');
        $proxyPort = $request->query->get('proxyPort');
        $proxyPortTypeHint = $request->query->get('proxyPortTypeHint');
        $proxyExceptions = $request->query->get('proxyExceptions');
        $proxyExceptionsTypeHint = $request->query->get('proxyExceptionsTypeHint');
        $proxyEnabled = $request->query->get('proxyEnabled');
        $proxyEnabledTypeHint = $request->query->get('proxyEnabledTypeHint');
        $proxyUser = $request->query->get('proxyUser');
        $proxyUserTypeHint = $request->query->get('proxyUserTypeHint');
        $proxyPassword = $request->query->get('proxyPassword');
        $proxyPasswordTypeHint = $request->query->get('proxyPasswordTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $proxyHost = $this->deserialize($proxyHost, 'string', 'string');
            $proxyHostTypeHint = $this->deserialize($proxyHostTypeHint, 'string', 'string');
            $proxyPort = $this->deserialize($proxyPort, 'int', 'string');
            $proxyPortTypeHint = $this->deserialize($proxyPortTypeHint, 'string', 'string');
            $proxyExceptions = $this->deserialize($proxyExceptions, 'array<multi,string>', 'string');
            $proxyExceptionsTypeHint = $this->deserialize($proxyExceptionsTypeHint, 'string', 'string');
            $proxyEnabled = $this->deserialize($proxyEnabled, 'bool', 'string');
            $proxyEnabledTypeHint = $this->deserialize($proxyEnabledTypeHint, 'string', 'string');
            $proxyUser = $this->deserialize($proxyUser, 'string', 'string');
            $proxyUserTypeHint = $this->deserialize($proxyUserTypeHint, 'string', 'string');
            $proxyPassword = $this->deserialize($proxyPassword, 'string', 'string');
            $proxyPasswordTypeHint = $this->deserialize($proxyPasswordTypeHint, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyHost, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyHostTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($proxyPort, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyPortTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($proxyExceptions, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyExceptionsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($proxyEnabled, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyEnabledTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyUser, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyUserTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($proxyPasswordTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheHttpComponentsProxyConfiguration($proxyHost, $proxyHostTypeHint, $proxyPort, $proxyPortTypeHint, $proxyExceptions, $proxyExceptionsTypeHint, $proxyEnabled, $proxyEnabledTypeHint, $proxyUser, $proxyUserTypeHint, $proxyPassword, $proxyPasswordTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheSlingDavExServlet
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheSlingDavExServletAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $alias = $request->query->get('alias');
        $aliasTypeHint = $request->query->get('aliasTypeHint');
        $davCreateAbsoluteUri = $request->query->get('davCreateAbsoluteUri');
        $davCreateAbsoluteUriTypeHint = $request->query->get('davCreateAbsoluteUriTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $alias = $this->deserialize($alias, 'string', 'string');
            $aliasTypeHint = $this->deserialize($aliasTypeHint, 'string', 'string');
            $davCreateAbsoluteUri = $this->deserialize($davCreateAbsoluteUri, 'bool', 'string');
            $davCreateAbsoluteUriTypeHint = $this->deserialize($davCreateAbsoluteUriTypeHint, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($alias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($aliasTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($davCreateAbsoluteUri, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($davCreateAbsoluteUriTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheSlingDavExServlet($alias, $aliasTypeHint, $davCreateAbsoluteUri, $davCreateAbsoluteUriTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheSlingGetServlet
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheSlingGetServletAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jsonMaximumresults = $request->query->get('jsonMaximumresults');
        $jsonMaximumresultsTypeHint = $request->query->get('jsonMaximumresultsTypeHint');
        $enableHtml = $request->query->get('enableHtml');
        $enableHtmlTypeHint = $request->query->get('enableHtmlTypeHint');
        $enableTxt = $request->query->get('enableTxt');
        $enableTxtTypeHint = $request->query->get('enableTxtTypeHint');
        $enableXml = $request->query->get('enableXml');
        $enableXmlTypeHint = $request->query->get('enableXmlTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $jsonMaximumresults = $this->deserialize($jsonMaximumresults, 'string', 'string');
            $jsonMaximumresultsTypeHint = $this->deserialize($jsonMaximumresultsTypeHint, 'string', 'string');
            $enableHtml = $this->deserialize($enableHtml, 'bool', 'string');
            $enableHtmlTypeHint = $this->deserialize($enableHtmlTypeHint, 'string', 'string');
            $enableTxt = $this->deserialize($enableTxt, 'bool', 'string');
            $enableTxtTypeHint = $this->deserialize($enableTxtTypeHint, 'string', 'string');
            $enableXml = $this->deserialize($enableXml, 'bool', 'string');
            $enableXmlTypeHint = $this->deserialize($enableXmlTypeHint, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jsonMaximumresults, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jsonMaximumresultsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($enableHtml, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($enableHtmlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($enableTxt, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($enableTxtTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($enableXml, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($enableXmlTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheSlingGetServlet($jsonMaximumresults, $jsonMaximumresultsTypeHint, $enableHtml, $enableHtmlTypeHint, $enableTxt, $enableTxtTypeHint, $enableXml, $enableXmlTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigApacheSlingReferrerFilter
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigApacheSlingReferrerFilterAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $allowEmpty = $request->query->get('allowEmpty');
        $allowEmptyTypeHint = $request->query->get('allowEmptyTypeHint');
        $allowHosts = $request->query->get('allowHosts');
        $allowHostsTypeHint = $request->query->get('allowHostsTypeHint');
        $allowHostsRegexp = $request->query->get('allowHostsRegexp');
        $allowHostsRegexpTypeHint = $request->query->get('allowHostsRegexpTypeHint');
        $filterMethods = $request->query->get('filterMethods');
        $filterMethodsTypeHint = $request->query->get('filterMethodsTypeHint');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $allowEmpty = $this->deserialize($allowEmpty, 'bool', 'string');
            $allowEmptyTypeHint = $this->deserialize($allowEmptyTypeHint, 'string', 'string');
            $allowHosts = $this->deserialize($allowHosts, 'string', 'string');
            $allowHostsTypeHint = $this->deserialize($allowHostsTypeHint, 'string', 'string');
            $allowHostsRegexp = $this->deserialize($allowHostsRegexp, 'string', 'string');
            $allowHostsRegexpTypeHint = $this->deserialize($allowHostsRegexpTypeHint, 'string', 'string');
            $filterMethods = $this->deserialize($filterMethods, 'string', 'string');
            $filterMethodsTypeHint = $this->deserialize($filterMethodsTypeHint, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($allowEmpty, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowEmptyTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHosts, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHostsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHostsRegexp, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($allowHostsRegexpTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($filterMethods, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($filterMethodsTypeHint, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigApacheSlingReferrerFilter($allowEmpty, $allowEmptyTypeHint, $allowHosts, $allowHostsTypeHint, $allowHostsRegexp, $allowHostsRegexpTypeHint, $filterMethods, $filterMethodsTypeHint, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postConfigProperty
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postConfigPropertyAction(Request $request, $configNodeName)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $configNodeName = $this->deserialize($configNodeName, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($configNodeName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postConfigProperty($configNodeName, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postNode
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postNodeAction(Request $request, $path, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $operation = $request->query->get('operation');
        $deleteAuthorizable = $request->query->get('deleteAuthorizable');
        $file = $request->files->get('file');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
            $operation = $this->deserialize($operation, 'string', 'string');
            $deleteAuthorizable = $this->deserialize($deleteAuthorizable, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($deleteAuthorizable, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($file, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postNode($path, $name, $operation, $deleteAuthorizable, $file, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postNodeRw
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postNodeRwAction(Request $request, $path, $name)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $addMembers = $request->query->get('addMembers');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
            $addMembers = $this->deserialize($addMembers, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($addMembers, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postNodeRw($path, $name, $addMembers, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postPath
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postPathAction(Request $request, $path)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jcrprimaryType = $request->query->get('jcrprimaryType');
        $name = $request->query->get('name');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $jcrprimaryType = $this->deserialize($jcrprimaryType, 'string', 'string');
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jcrprimaryType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postPath($path, $jcrprimaryType, $name, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postQuery
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postQueryAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $path = $request->query->get('path');
        $pLimit = $request->query->get('pLimit');
        $_1property = $request->query->get('_1property');
        $_1propertyValue = $request->query->get('_1propertyValue');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $path = $this->deserialize($path, 'string', 'string');
            $pLimit = $this->deserialize($pLimit, 'float', 'string');
            $_1property = $this->deserialize($_1property, 'string', 'string');
            $_1propertyValue = $this->deserialize($_1propertyValue, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($pLimit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1property, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($_1propertyValue, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postQuery($path, $pLimit, $_1property, $_1propertyValue, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postTreeActivation
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postTreeActivationAction(Request $request)
    {
        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $ignoredeactivated = $request->query->get('ignoredeactivated');
        $onlymodified = $request->query->get('onlymodified');
        $path = $request->query->get('path');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $ignoredeactivated = $this->deserialize($ignoredeactivated, 'bool', 'string');
            $onlymodified = $this->deserialize($onlymodified, 'bool', 'string');
            $path = $this->deserialize($path, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($ignoredeactivated, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($onlymodified, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($path, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];
            $result = $handler->postTreeActivation($ignoredeactivated, $onlymodified, $path, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postTruststore
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postTruststoreAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $operation = $request->query->get('operation');
        $newPassword = $request->query->get('newPassword');
        $rePassword = $request->query->get('rePassword');
        $keyStoreType = $request->query->get('keyStoreType');
        $removeAlias = $request->query->get('removeAlias');
        $certificate = $request->files->get('certificate');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $operation = $this->deserialize($operation, 'string', 'string');
            $newPassword = $this->deserialize($newPassword, 'string', 'string');
            $rePassword = $this->deserialize($rePassword, 'string', 'string');
            $keyStoreType = $this->deserialize($keyStoreType, 'string', 'string');
            $removeAlias = $this->deserialize($removeAlias, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($operation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($newPassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($rePassword, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($keyStoreType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($removeAlias, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($certificate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postTruststore($operation, $newPassword, $rePassword, $keyStoreType, $removeAlias, $certificate, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postTruststorePKCS12
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postTruststorePKCS12Action(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['text/plain'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'aemAuth' required
        // HTTP basic authentication required
        $securityaemAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $truststoreP12 = $request->files->get('truststoreP12');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($truststoreP12, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'aemAuth'
            $handler->setaemAuth($securityaemAuth);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->postTruststorePKCS12($truststoreP12, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Default response';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 0:
                    $message = 'Default response';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return SlingApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('sling');
    }
}
