# Adobe Experience Manager (AEM) API
#
# Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
#
# The version of the OpenAPI document: 3.5.0-pre.0
# Contact: opensource@shinesolutions.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Sling operations
#' @description openapi.Sling
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ DeleteAgent } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } runmode character
#' \item \emph{ @param } name character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteNode } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } name character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAgent } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } runmode character
#' \item \emph{ @param } name character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAgents } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } runmode character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAuthorizableKeystore } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } intermediate.path character
#' \item \emph{ @param } authorizable.id character
#' \item \emph{ @returnType } \link{KeystoreInfo} \cr
#'
#'
#' \item status code : 200 | Retrieved Authorizable Keystore info
#'
#' \item return type : KeystoreInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetKeystore } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } intermediate.path character
#' \item \emph{ @param } authorizable.id character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetNode } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } name character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetPackage } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } group character
#' \item \emph{ @param } name character
#' \item \emph{ @param } version character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetPackageFilter } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } group character
#' \item \emph{ @param } name character
#' \item \emph{ @param } version character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetQuery } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } p.limit numeric
#' \item \emph{ @param } Var1.property character
#' \item \emph{ @param } Var1.property.value character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetTruststore } \emph{  }
#' 
#'
#' \itemize{
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetTruststoreInfo } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{TruststoreInfo} \cr
#'
#'
#' \item status code : 200 | Retrieved AEM Truststore info
#'
#' \item return type : TruststoreInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostAgent } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } runmode character
#' \item \emph{ @param } name character
#' \item \emph{ @param } jcrcontent.cqdistribute character
#' \item \emph{ @param } jcrcontent.cqdistribute.type.hint character
#' \item \emph{ @param } jcrcontent.cqname character
#' \item \emph{ @param } jcrcontent.cqtemplate character
#' \item \emph{ @param } jcrcontent.enabled character
#' \item \emph{ @param } jcrcontent.jcrdescription character
#' \item \emph{ @param } jcrcontent.jcrlast.modified character
#' \item \emph{ @param } jcrcontent.jcrlast.modified.by character
#' \item \emph{ @param } jcrcontent.jcrmixin.types character
#' \item \emph{ @param } jcrcontent.jcrtitle character
#' \item \emph{ @param } jcrcontent.log.level character
#' \item \emph{ @param } jcrcontent.no.status.update character
#' \item \emph{ @param } jcrcontent.no.versioning character
#' \item \emph{ @param } jcrcontent.protocol.connect.timeout numeric
#' \item \emph{ @param } jcrcontent.protocol.http.connection.closed character
#' \item \emph{ @param } jcrcontent.protocol.http.expired character
#' \item \emph{ @param } jcrcontent.protocol.http.headers list( character )
#' \item \emph{ @param } jcrcontent.protocol.http.headers.type.hint character
#' \item \emph{ @param } jcrcontent.protocol.http.method character
#' \item \emph{ @param } jcrcontent.protocol.https.relaxed character
#' \item \emph{ @param } jcrcontent.protocol.interface character
#' \item \emph{ @param } jcrcontent.protocol.socket.timeout numeric
#' \item \emph{ @param } jcrcontent.protocol.version character
#' \item \emph{ @param } jcrcontent.proxy.ntlm.domain character
#' \item \emph{ @param } jcrcontent.proxy.ntlm.host character
#' \item \emph{ @param } jcrcontent.proxy.host character
#' \item \emph{ @param } jcrcontent.proxy.password character
#' \item \emph{ @param } jcrcontent.proxy.port numeric
#' \item \emph{ @param } jcrcontent.proxy.user character
#' \item \emph{ @param } jcrcontent.queue.batch.max.size numeric
#' \item \emph{ @param } jcrcontent.queue.batch.mode character
#' \item \emph{ @param } jcrcontent.queue.batch.wait.time numeric
#' \item \emph{ @param } jcrcontent.retry.delay character
#' \item \emph{ @param } jcrcontent.reverse.replication character
#' \item \emph{ @param } jcrcontent.serialization.type character
#' \item \emph{ @param } jcrcontent.slingresource.type character
#' \item \emph{ @param } jcrcontent.ssl character
#' \item \emph{ @param } jcrcontent.transport.ntlm.domain character
#' \item \emph{ @param } jcrcontent.transport.ntlm.host character
#' \item \emph{ @param } jcrcontent.transport.password character
#' \item \emph{ @param } jcrcontent.transport.uri character
#' \item \emph{ @param } jcrcontent.transport.user character
#' \item \emph{ @param } jcrcontent.trigger.distribute character
#' \item \emph{ @param } jcrcontent.trigger.modified character
#' \item \emph{ @param } jcrcontent.trigger.on.off.time character
#' \item \emph{ @param } jcrcontent.trigger.receive character
#' \item \emph{ @param } jcrcontent.trigger.specific character
#' \item \emph{ @param } jcrcontent.user.id character
#' \item \emph{ @param } jcrprimary.type character
#' \item \emph{ @param } operation character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostAuthorizableKeystore } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } intermediate.path character
#' \item \emph{ @param } authorizable.id character
#' \item \emph{ @param } operation character
#' \item \emph{ @param } current.password character
#' \item \emph{ @param } new.password character
#' \item \emph{ @param } re.password character
#' \item \emph{ @param } key.password character
#' \item \emph{ @param } key.store.pass character
#' \item \emph{ @param } alias character
#' \item \emph{ @param } new.alias character
#' \item \emph{ @param } remove.alias character
#' \item \emph{ @param } cert.chain data.frame
#' \item \emph{ @param } pk data.frame
#' \item \emph{ @param } key.store data.frame
#' \item \emph{ @returnType } \link{KeystoreInfo} \cr
#'
#'
#' \item status code : 200 | Retrieved Authorizable Keystore info
#'
#' \item return type : KeystoreInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostAuthorizables } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } authorizable.id character
#' \item \emph{ @param } intermediate.path character
#' \item \emph{ @param } create.user character
#' \item \emph{ @param } create.group character
#' \item \emph{ @param } reppassword character
#' \item \emph{ @param } profile.given.name character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigAdobeGraniteSamlAuthenticationHandler } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } key.store.password character
#' \item \emph{ @param } key.store.password.type.hint character
#' \item \emph{ @param } service.ranking integer
#' \item \emph{ @param } service.ranking.type.hint character
#' \item \emph{ @param } idp.http.redirect character
#' \item \emph{ @param } idp.http.redirect.type.hint character
#' \item \emph{ @param } create.user character
#' \item \emph{ @param } create.user.type.hint character
#' \item \emph{ @param } default.redirect.url character
#' \item \emph{ @param } default.redirect.url.type.hint character
#' \item \emph{ @param } user.id.attribute character
#' \item \emph{ @param } user.id.attribute.type.hint character
#' \item \emph{ @param } default.groups list( character )
#' \item \emph{ @param } default.groups.type.hint character
#' \item \emph{ @param } idp.cert.alias character
#' \item \emph{ @param } idp.cert.alias.type.hint character
#' \item \emph{ @param } add.group.memberships character
#' \item \emph{ @param } add.group.memberships.type.hint character
#' \item \emph{ @param } path list( character )
#' \item \emph{ @param } path.type.hint character
#' \item \emph{ @param } synchronize.attributes list( character )
#' \item \emph{ @param } synchronize.attributes.type.hint character
#' \item \emph{ @param } clock.tolerance integer
#' \item \emph{ @param } clock.tolerance.type.hint character
#' \item \emph{ @param } group.membership.attribute character
#' \item \emph{ @param } group.membership.attribute.type.hint character
#' \item \emph{ @param } idp.url character
#' \item \emph{ @param } idp.url.type.hint character
#' \item \emph{ @param } logout.url character
#' \item \emph{ @param } logout.url.type.hint character
#' \item \emph{ @param } service.provider.entity.id character
#' \item \emph{ @param } service.provider.entity.id.type.hint character
#' \item \emph{ @param } assertion.consumer.service.url character
#' \item \emph{ @param } assertion.consumer.service.url.type.hint character
#' \item \emph{ @param } handle.logout character
#' \item \emph{ @param } handle.logout.type.hint character
#' \item \emph{ @param } sp.private.key.alias character
#' \item \emph{ @param } sp.private.key.alias.type.hint character
#' \item \emph{ @param } use.encryption character
#' \item \emph{ @param } use.encryption.type.hint character
#' \item \emph{ @param } name.id.format character
#' \item \emph{ @param } name.id.format.type.hint character
#' \item \emph{ @param } digest.method character
#' \item \emph{ @param } digest.method.type.hint character
#' \item \emph{ @param } signature.method character
#' \item \emph{ @param } signature.method.type.hint character
#' \item \emph{ @param } user.intermediate.path character
#' \item \emph{ @param } user.intermediate.path.type.hint character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigApacheFelixJettyBasedHttpService } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } org.apache.felix.https.nio character
#' \item \emph{ @param } org.apache.felix.https.nio.type.hint character
#' \item \emph{ @param } org.apache.felix.https.keystore character
#' \item \emph{ @param } org.apache.felix.https.keystore.type.hint character
#' \item \emph{ @param } org.apache.felix.https.keystore.password character
#' \item \emph{ @param } org.apache.felix.https.keystore.password.type.hint character
#' \item \emph{ @param } org.apache.felix.https.keystore.key character
#' \item \emph{ @param } org.apache.felix.https.keystore.key.type.hint character
#' \item \emph{ @param } org.apache.felix.https.keystore.key.password character
#' \item \emph{ @param } org.apache.felix.https.keystore.key.password.type.hint character
#' \item \emph{ @param } org.apache.felix.https.truststore character
#' \item \emph{ @param } org.apache.felix.https.truststore.type.hint character
#' \item \emph{ @param } org.apache.felix.https.truststore.password character
#' \item \emph{ @param } org.apache.felix.https.truststore.password.type.hint character
#' \item \emph{ @param } org.apache.felix.https.clientcertificate character
#' \item \emph{ @param } org.apache.felix.https.clientcertificate.type.hint character
#' \item \emph{ @param } org.apache.felix.https.enable character
#' \item \emph{ @param } org.apache.felix.https.enable.type.hint character
#' \item \emph{ @param } org.osgi.service.http.port.secure character
#' \item \emph{ @param } org.osgi.service.http.port.secure.type.hint character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigApacheHttpComponentsProxyConfiguration } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } proxy.host character
#' \item \emph{ @param } proxy.host.type.hint character
#' \item \emph{ @param } proxy.port integer
#' \item \emph{ @param } proxy.port.type.hint character
#' \item \emph{ @param } proxy.exceptions list( character )
#' \item \emph{ @param } proxy.exceptions.type.hint character
#' \item \emph{ @param } proxy.enabled character
#' \item \emph{ @param } proxy.enabled.type.hint character
#' \item \emph{ @param } proxy.user character
#' \item \emph{ @param } proxy.user.type.hint character
#' \item \emph{ @param } proxy.password character
#' \item \emph{ @param } proxy.password.type.hint character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigApacheSlingDavExServlet } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } alias character
#' \item \emph{ @param } alias.type.hint character
#' \item \emph{ @param } dav.create.absolute.uri character
#' \item \emph{ @param } dav.create.absolute.uri.type.hint character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigApacheSlingGetServlet } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } json.maximumresults character
#' \item \emph{ @param } json.maximumresults.type.hint character
#' \item \emph{ @param } enable.html character
#' \item \emph{ @param } enable.html.type.hint character
#' \item \emph{ @param } enable.txt character
#' \item \emph{ @param } enable.txt.type.hint character
#' \item \emph{ @param } enable.xml character
#' \item \emph{ @param } enable.xml.type.hint character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigApacheSlingReferrerFilter } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } allow.empty character
#' \item \emph{ @param } allow.empty.type.hint character
#' \item \emph{ @param } allow.hosts character
#' \item \emph{ @param } allow.hosts.type.hint character
#' \item \emph{ @param } allow.hosts.regexp character
#' \item \emph{ @param } allow.hosts.regexp.type.hint character
#' \item \emph{ @param } filter.methods character
#' \item \emph{ @param } filter.methods.type.hint character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostConfigProperty } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } config.node.name character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostNode } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } name character
#' \item \emph{ @param } operation character
#' \item \emph{ @param } delete.authorizable character
#' \item \emph{ @param } file data.frame
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostNodeRw } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } name character
#' \item \emph{ @param } add.members character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostPath } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } jcrprimary.type character
#' \item \emph{ @param } name character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostQuery } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } path character
#' \item \emph{ @param } p.limit numeric
#' \item \emph{ @param } Var1.property character
#' \item \emph{ @param } Var1.property.value character
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostTreeActivation } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } ignoredeactivated character
#' \item \emph{ @param } onlymodified character
#' \item \emph{ @param } path character
#'
#'
#' \item status code : 0 | Default response
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostTruststore } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } operation character
#' \item \emph{ @param } new.password character
#' \item \emph{ @param } re.password character
#' \item \emph{ @param } key.store.type character
#' \item \emph{ @param } remove.alias character
#' \item \emph{ @param } certificate data.frame
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PostTruststorePKCS12 } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } truststore.p12 data.frame
#'
#'
#' \item status code : 0 | Default response
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  DeleteAgent  ####################
#'
#' library(openapi)
#' var.runmode <- 'runmode_example' # character | 
#' var.name <- 'name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteAgent(var.runmode, var.name)
#'
#'
#' ####################  DeleteNode  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.name <- 'name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteNode(var.path, var.name)
#'
#'
#' ####################  GetAgent  ####################
#'
#' library(openapi)
#' var.runmode <- 'runmode_example' # character | 
#' var.name <- 'name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAgent(var.runmode, var.name)
#'
#'
#' ####################  GetAgents  ####################
#'
#' library(openapi)
#' var.runmode <- 'runmode_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAgents(var.runmode)
#'
#'
#' ####################  GetAuthorizableKeystore  ####################
#'
#' library(openapi)
#' var.intermediate.path <- 'intermediate.path_example' # character | 
#' var.authorizable.id <- 'authorizable.id_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAuthorizableKeystore(var.intermediate.path, var.authorizable.id)
#'
#'
#' ####################  GetKeystore  ####################
#'
#' library(openapi)
#' var.intermediate.path <- 'intermediate.path_example' # character | 
#' var.authorizable.id <- 'authorizable.id_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetKeystore(var.intermediate.path, var.authorizable.id)
#'
#'
#' ####################  GetNode  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.name <- 'name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetNode(var.path, var.name)
#'
#'
#' ####################  GetPackage  ####################
#'
#' library(openapi)
#' var.group <- 'group_example' # character | 
#' var.name <- 'name_example' # character | 
#' var.version <- 'version_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetPackage(var.group, var.name, var.version)
#'
#'
#' ####################  GetPackageFilter  ####################
#'
#' library(openapi)
#' var.group <- 'group_example' # character | 
#' var.name <- 'name_example' # character | 
#' var.version <- 'version_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetPackageFilter(var.group, var.name, var.version)
#'
#'
#' ####################  GetQuery  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.p.limit <- 3.4 # numeric | 
#' var.Var1.property <- 'Var1.property_example' # character | 
#' var.Var1.property.value <- 'Var1.property.value_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetQuery(var.path, var.p.limit, var.Var1.property, var.Var1.property.value)
#'
#'
#' ####################  GetTruststore  ####################
#'
#' library(openapi)
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetTruststore()
#'
#'
#' ####################  GetTruststoreInfo  ####################
#'
#' library(openapi)
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetTruststoreInfo()
#'
#'
#' ####################  PostAgent  ####################
#'
#' library(openapi)
#' var.runmode <- 'runmode_example' # character | 
#' var.name <- 'name_example' # character | 
#' var.jcrcontent.cqdistribute <- 'jcrcontent.cqdistribute_example' # character | 
#' var.jcrcontent.cqdistribute.type.hint <- 'jcrcontent.cqdistribute.type.hint_example' # character | 
#' var.jcrcontent.cqname <- 'jcrcontent.cqname_example' # character | 
#' var.jcrcontent.cqtemplate <- 'jcrcontent.cqtemplate_example' # character | 
#' var.jcrcontent.enabled <- 'jcrcontent.enabled_example' # character | 
#' var.jcrcontent.jcrdescription <- 'jcrcontent.jcrdescription_example' # character | 
#' var.jcrcontent.jcrlast.modified <- 'jcrcontent.jcrlast.modified_example' # character | 
#' var.jcrcontent.jcrlast.modified.by <- 'jcrcontent.jcrlast.modified.by_example' # character | 
#' var.jcrcontent.jcrmixin.types <- 'jcrcontent.jcrmixin.types_example' # character | 
#' var.jcrcontent.jcrtitle <- 'jcrcontent.jcrtitle_example' # character | 
#' var.jcrcontent.log.level <- 'jcrcontent.log.level_example' # character | 
#' var.jcrcontent.no.status.update <- 'jcrcontent.no.status.update_example' # character | 
#' var.jcrcontent.no.versioning <- 'jcrcontent.no.versioning_example' # character | 
#' var.jcrcontent.protocol.connect.timeout <- 3.4 # numeric | 
#' var.jcrcontent.protocol.http.connection.closed <- 'jcrcontent.protocol.http.connection.closed_example' # character | 
#' var.jcrcontent.protocol.http.expired <- 'jcrcontent.protocol.http.expired_example' # character | 
#' var.jcrcontent.protocol.http.headers <- ['jcrcontent.protocol.http.headers_example'] # array[character] | 
#' var.jcrcontent.protocol.http.headers.type.hint <- 'jcrcontent.protocol.http.headers.type.hint_example' # character | 
#' var.jcrcontent.protocol.http.method <- 'jcrcontent.protocol.http.method_example' # character | 
#' var.jcrcontent.protocol.https.relaxed <- 'jcrcontent.protocol.https.relaxed_example' # character | 
#' var.jcrcontent.protocol.interface <- 'jcrcontent.protocol.interface_example' # character | 
#' var.jcrcontent.protocol.socket.timeout <- 3.4 # numeric | 
#' var.jcrcontent.protocol.version <- 'jcrcontent.protocol.version_example' # character | 
#' var.jcrcontent.proxy.ntlm.domain <- 'jcrcontent.proxy.ntlm.domain_example' # character | 
#' var.jcrcontent.proxy.ntlm.host <- 'jcrcontent.proxy.ntlm.host_example' # character | 
#' var.jcrcontent.proxy.host <- 'jcrcontent.proxy.host_example' # character | 
#' var.jcrcontent.proxy.password <- 'jcrcontent.proxy.password_example' # character | 
#' var.jcrcontent.proxy.port <- 3.4 # numeric | 
#' var.jcrcontent.proxy.user <- 'jcrcontent.proxy.user_example' # character | 
#' var.jcrcontent.queue.batch.max.size <- 3.4 # numeric | 
#' var.jcrcontent.queue.batch.mode <- 'jcrcontent.queue.batch.mode_example' # character | 
#' var.jcrcontent.queue.batch.wait.time <- 3.4 # numeric | 
#' var.jcrcontent.retry.delay <- 'jcrcontent.retry.delay_example' # character | 
#' var.jcrcontent.reverse.replication <- 'jcrcontent.reverse.replication_example' # character | 
#' var.jcrcontent.serialization.type <- 'jcrcontent.serialization.type_example' # character | 
#' var.jcrcontent.slingresource.type <- 'jcrcontent.slingresource.type_example' # character | 
#' var.jcrcontent.ssl <- 'jcrcontent.ssl_example' # character | 
#' var.jcrcontent.transport.ntlm.domain <- 'jcrcontent.transport.ntlm.domain_example' # character | 
#' var.jcrcontent.transport.ntlm.host <- 'jcrcontent.transport.ntlm.host_example' # character | 
#' var.jcrcontent.transport.password <- 'jcrcontent.transport.password_example' # character | 
#' var.jcrcontent.transport.uri <- 'jcrcontent.transport.uri_example' # character | 
#' var.jcrcontent.transport.user <- 'jcrcontent.transport.user_example' # character | 
#' var.jcrcontent.trigger.distribute <- 'jcrcontent.trigger.distribute_example' # character | 
#' var.jcrcontent.trigger.modified <- 'jcrcontent.trigger.modified_example' # character | 
#' var.jcrcontent.trigger.on.off.time <- 'jcrcontent.trigger.on.off.time_example' # character | 
#' var.jcrcontent.trigger.receive <- 'jcrcontent.trigger.receive_example' # character | 
#' var.jcrcontent.trigger.specific <- 'jcrcontent.trigger.specific_example' # character | 
#' var.jcrcontent.user.id <- 'jcrcontent.user.id_example' # character | 
#' var.jcrprimary.type <- 'jcrprimary.type_example' # character | 
#' var.operation <- 'operation_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostAgent(var.runmode, var.name, jcrcontent.cqdistribute=var.jcrcontent.cqdistribute, jcrcontent.cqdistribute.type.hint=var.jcrcontent.cqdistribute.type.hint, jcrcontent.cqname=var.jcrcontent.cqname, jcrcontent.cqtemplate=var.jcrcontent.cqtemplate, jcrcontent.enabled=var.jcrcontent.enabled, jcrcontent.jcrdescription=var.jcrcontent.jcrdescription, jcrcontent.jcrlast.modified=var.jcrcontent.jcrlast.modified, jcrcontent.jcrlast.modified.by=var.jcrcontent.jcrlast.modified.by, jcrcontent.jcrmixin.types=var.jcrcontent.jcrmixin.types, jcrcontent.jcrtitle=var.jcrcontent.jcrtitle, jcrcontent.log.level=var.jcrcontent.log.level, jcrcontent.no.status.update=var.jcrcontent.no.status.update, jcrcontent.no.versioning=var.jcrcontent.no.versioning, jcrcontent.protocol.connect.timeout=var.jcrcontent.protocol.connect.timeout, jcrcontent.protocol.http.connection.closed=var.jcrcontent.protocol.http.connection.closed, jcrcontent.protocol.http.expired=var.jcrcontent.protocol.http.expired, jcrcontent.protocol.http.headers=var.jcrcontent.protocol.http.headers, jcrcontent.protocol.http.headers.type.hint=var.jcrcontent.protocol.http.headers.type.hint, jcrcontent.protocol.http.method=var.jcrcontent.protocol.http.method, jcrcontent.protocol.https.relaxed=var.jcrcontent.protocol.https.relaxed, jcrcontent.protocol.interface=var.jcrcontent.protocol.interface, jcrcontent.protocol.socket.timeout=var.jcrcontent.protocol.socket.timeout, jcrcontent.protocol.version=var.jcrcontent.protocol.version, jcrcontent.proxy.ntlm.domain=var.jcrcontent.proxy.ntlm.domain, jcrcontent.proxy.ntlm.host=var.jcrcontent.proxy.ntlm.host, jcrcontent.proxy.host=var.jcrcontent.proxy.host, jcrcontent.proxy.password=var.jcrcontent.proxy.password, jcrcontent.proxy.port=var.jcrcontent.proxy.port, jcrcontent.proxy.user=var.jcrcontent.proxy.user, jcrcontent.queue.batch.max.size=var.jcrcontent.queue.batch.max.size, jcrcontent.queue.batch.mode=var.jcrcontent.queue.batch.mode, jcrcontent.queue.batch.wait.time=var.jcrcontent.queue.batch.wait.time, jcrcontent.retry.delay=var.jcrcontent.retry.delay, jcrcontent.reverse.replication=var.jcrcontent.reverse.replication, jcrcontent.serialization.type=var.jcrcontent.serialization.type, jcrcontent.slingresource.type=var.jcrcontent.slingresource.type, jcrcontent.ssl=var.jcrcontent.ssl, jcrcontent.transport.ntlm.domain=var.jcrcontent.transport.ntlm.domain, jcrcontent.transport.ntlm.host=var.jcrcontent.transport.ntlm.host, jcrcontent.transport.password=var.jcrcontent.transport.password, jcrcontent.transport.uri=var.jcrcontent.transport.uri, jcrcontent.transport.user=var.jcrcontent.transport.user, jcrcontent.trigger.distribute=var.jcrcontent.trigger.distribute, jcrcontent.trigger.modified=var.jcrcontent.trigger.modified, jcrcontent.trigger.on.off.time=var.jcrcontent.trigger.on.off.time, jcrcontent.trigger.receive=var.jcrcontent.trigger.receive, jcrcontent.trigger.specific=var.jcrcontent.trigger.specific, jcrcontent.user.id=var.jcrcontent.user.id, jcrprimary.type=var.jcrprimary.type, operation=var.operation)
#'
#'
#' ####################  PostAuthorizableKeystore  ####################
#'
#' library(openapi)
#' var.intermediate.path <- 'intermediate.path_example' # character | 
#' var.authorizable.id <- 'authorizable.id_example' # character | 
#' var.operation <- 'operation_example' # character | 
#' var.current.password <- 'current.password_example' # character | 
#' var.new.password <- 'new.password_example' # character | 
#' var.re.password <- 're.password_example' # character | 
#' var.key.password <- 'key.password_example' # character | 
#' var.key.store.pass <- 'key.store.pass_example' # character | 
#' var.alias <- 'alias_example' # character | 
#' var.new.alias <- 'new.alias_example' # character | 
#' var.remove.alias <- 'remove.alias_example' # character | 
#' var.cert.chain <- File.new('/path/to/file') # data.frame | 
#' var.pk <- File.new('/path/to/file') # data.frame | 
#' var.key.store <- File.new('/path/to/file') # data.frame | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostAuthorizableKeystore(var.intermediate.path, var.authorizable.id, operation=var.operation, current.password=var.current.password, new.password=var.new.password, re.password=var.re.password, key.password=var.key.password, key.store.pass=var.key.store.pass, alias=var.alias, new.alias=var.new.alias, remove.alias=var.remove.alias, cert.chain=var.cert.chain, pk=var.pk, key.store=var.key.store)
#'
#'
#' ####################  PostAuthorizables  ####################
#'
#' library(openapi)
#' var.authorizable.id <- 'authorizable.id_example' # character | 
#' var.intermediate.path <- 'intermediate.path_example' # character | 
#' var.create.user <- 'create.user_example' # character | 
#' var.create.group <- 'create.group_example' # character | 
#' var.reppassword <- 'reppassword_example' # character | 
#' var.profile.given.name <- 'profile.given.name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostAuthorizables(var.authorizable.id, var.intermediate.path, create.user=var.create.user, create.group=var.create.group, reppassword=var.reppassword, profile.given.name=var.profile.given.name)
#'
#'
#' ####################  PostConfigAdobeGraniteSamlAuthenticationHandler  ####################
#'
#' library(openapi)
#' var.key.store.password <- 'key.store.password_example' # character | 
#' var.key.store.password.type.hint <- 'key.store.password.type.hint_example' # character | 
#' var.service.ranking <- 56 # integer | 
#' var.service.ranking.type.hint <- 'service.ranking.type.hint_example' # character | 
#' var.idp.http.redirect <- 'idp.http.redirect_example' # character | 
#' var.idp.http.redirect.type.hint <- 'idp.http.redirect.type.hint_example' # character | 
#' var.create.user <- 'create.user_example' # character | 
#' var.create.user.type.hint <- 'create.user.type.hint_example' # character | 
#' var.default.redirect.url <- 'default.redirect.url_example' # character | 
#' var.default.redirect.url.type.hint <- 'default.redirect.url.type.hint_example' # character | 
#' var.user.id.attribute <- 'user.id.attribute_example' # character | 
#' var.user.id.attribute.type.hint <- 'user.id.attribute.type.hint_example' # character | 
#' var.default.groups <- ['default.groups_example'] # array[character] | 
#' var.default.groups.type.hint <- 'default.groups.type.hint_example' # character | 
#' var.idp.cert.alias <- 'idp.cert.alias_example' # character | 
#' var.idp.cert.alias.type.hint <- 'idp.cert.alias.type.hint_example' # character | 
#' var.add.group.memberships <- 'add.group.memberships_example' # character | 
#' var.add.group.memberships.type.hint <- 'add.group.memberships.type.hint_example' # character | 
#' var.path <- ['path_example'] # array[character] | 
#' var.path.type.hint <- 'path.type.hint_example' # character | 
#' var.synchronize.attributes <- ['synchronize.attributes_example'] # array[character] | 
#' var.synchronize.attributes.type.hint <- 'synchronize.attributes.type.hint_example' # character | 
#' var.clock.tolerance <- 56 # integer | 
#' var.clock.tolerance.type.hint <- 'clock.tolerance.type.hint_example' # character | 
#' var.group.membership.attribute <- 'group.membership.attribute_example' # character | 
#' var.group.membership.attribute.type.hint <- 'group.membership.attribute.type.hint_example' # character | 
#' var.idp.url <- 'idp.url_example' # character | 
#' var.idp.url.type.hint <- 'idp.url.type.hint_example' # character | 
#' var.logout.url <- 'logout.url_example' # character | 
#' var.logout.url.type.hint <- 'logout.url.type.hint_example' # character | 
#' var.service.provider.entity.id <- 'service.provider.entity.id_example' # character | 
#' var.service.provider.entity.id.type.hint <- 'service.provider.entity.id.type.hint_example' # character | 
#' var.assertion.consumer.service.url <- 'assertion.consumer.service.url_example' # character | 
#' var.assertion.consumer.service.url.type.hint <- 'assertion.consumer.service.url.type.hint_example' # character | 
#' var.handle.logout <- 'handle.logout_example' # character | 
#' var.handle.logout.type.hint <- 'handle.logout.type.hint_example' # character | 
#' var.sp.private.key.alias <- 'sp.private.key.alias_example' # character | 
#' var.sp.private.key.alias.type.hint <- 'sp.private.key.alias.type.hint_example' # character | 
#' var.use.encryption <- 'use.encryption_example' # character | 
#' var.use.encryption.type.hint <- 'use.encryption.type.hint_example' # character | 
#' var.name.id.format <- 'name.id.format_example' # character | 
#' var.name.id.format.type.hint <- 'name.id.format.type.hint_example' # character | 
#' var.digest.method <- 'digest.method_example' # character | 
#' var.digest.method.type.hint <- 'digest.method.type.hint_example' # character | 
#' var.signature.method <- 'signature.method_example' # character | 
#' var.signature.method.type.hint <- 'signature.method.type.hint_example' # character | 
#' var.user.intermediate.path <- 'user.intermediate.path_example' # character | 
#' var.user.intermediate.path.type.hint <- 'user.intermediate.path.type.hint_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigAdobeGraniteSamlAuthenticationHandler(key.store.password=var.key.store.password, key.store.password.type.hint=var.key.store.password.type.hint, service.ranking=var.service.ranking, service.ranking.type.hint=var.service.ranking.type.hint, idp.http.redirect=var.idp.http.redirect, idp.http.redirect.type.hint=var.idp.http.redirect.type.hint, create.user=var.create.user, create.user.type.hint=var.create.user.type.hint, default.redirect.url=var.default.redirect.url, default.redirect.url.type.hint=var.default.redirect.url.type.hint, user.id.attribute=var.user.id.attribute, user.id.attribute.type.hint=var.user.id.attribute.type.hint, default.groups=var.default.groups, default.groups.type.hint=var.default.groups.type.hint, idp.cert.alias=var.idp.cert.alias, idp.cert.alias.type.hint=var.idp.cert.alias.type.hint, add.group.memberships=var.add.group.memberships, add.group.memberships.type.hint=var.add.group.memberships.type.hint, path=var.path, path.type.hint=var.path.type.hint, synchronize.attributes=var.synchronize.attributes, synchronize.attributes.type.hint=var.synchronize.attributes.type.hint, clock.tolerance=var.clock.tolerance, clock.tolerance.type.hint=var.clock.tolerance.type.hint, group.membership.attribute=var.group.membership.attribute, group.membership.attribute.type.hint=var.group.membership.attribute.type.hint, idp.url=var.idp.url, idp.url.type.hint=var.idp.url.type.hint, logout.url=var.logout.url, logout.url.type.hint=var.logout.url.type.hint, service.provider.entity.id=var.service.provider.entity.id, service.provider.entity.id.type.hint=var.service.provider.entity.id.type.hint, assertion.consumer.service.url=var.assertion.consumer.service.url, assertion.consumer.service.url.type.hint=var.assertion.consumer.service.url.type.hint, handle.logout=var.handle.logout, handle.logout.type.hint=var.handle.logout.type.hint, sp.private.key.alias=var.sp.private.key.alias, sp.private.key.alias.type.hint=var.sp.private.key.alias.type.hint, use.encryption=var.use.encryption, use.encryption.type.hint=var.use.encryption.type.hint, name.id.format=var.name.id.format, name.id.format.type.hint=var.name.id.format.type.hint, digest.method=var.digest.method, digest.method.type.hint=var.digest.method.type.hint, signature.method=var.signature.method, signature.method.type.hint=var.signature.method.type.hint, user.intermediate.path=var.user.intermediate.path, user.intermediate.path.type.hint=var.user.intermediate.path.type.hint)
#'
#'
#' ####################  PostConfigApacheFelixJettyBasedHttpService  ####################
#'
#' library(openapi)
#' var.org.apache.felix.https.nio <- 'org.apache.felix.https.nio_example' # character | 
#' var.org.apache.felix.https.nio.type.hint <- 'org.apache.felix.https.nio.type.hint_example' # character | 
#' var.org.apache.felix.https.keystore <- 'org.apache.felix.https.keystore_example' # character | 
#' var.org.apache.felix.https.keystore.type.hint <- 'org.apache.felix.https.keystore.type.hint_example' # character | 
#' var.org.apache.felix.https.keystore.password <- 'org.apache.felix.https.keystore.password_example' # character | 
#' var.org.apache.felix.https.keystore.password.type.hint <- 'org.apache.felix.https.keystore.password.type.hint_example' # character | 
#' var.org.apache.felix.https.keystore.key <- 'org.apache.felix.https.keystore.key_example' # character | 
#' var.org.apache.felix.https.keystore.key.type.hint <- 'org.apache.felix.https.keystore.key.type.hint_example' # character | 
#' var.org.apache.felix.https.keystore.key.password <- 'org.apache.felix.https.keystore.key.password_example' # character | 
#' var.org.apache.felix.https.keystore.key.password.type.hint <- 'org.apache.felix.https.keystore.key.password.type.hint_example' # character | 
#' var.org.apache.felix.https.truststore <- 'org.apache.felix.https.truststore_example' # character | 
#' var.org.apache.felix.https.truststore.type.hint <- 'org.apache.felix.https.truststore.type.hint_example' # character | 
#' var.org.apache.felix.https.truststore.password <- 'org.apache.felix.https.truststore.password_example' # character | 
#' var.org.apache.felix.https.truststore.password.type.hint <- 'org.apache.felix.https.truststore.password.type.hint_example' # character | 
#' var.org.apache.felix.https.clientcertificate <- 'org.apache.felix.https.clientcertificate_example' # character | 
#' var.org.apache.felix.https.clientcertificate.type.hint <- 'org.apache.felix.https.clientcertificate.type.hint_example' # character | 
#' var.org.apache.felix.https.enable <- 'org.apache.felix.https.enable_example' # character | 
#' var.org.apache.felix.https.enable.type.hint <- 'org.apache.felix.https.enable.type.hint_example' # character | 
#' var.org.osgi.service.http.port.secure <- 'org.osgi.service.http.port.secure_example' # character | 
#' var.org.osgi.service.http.port.secure.type.hint <- 'org.osgi.service.http.port.secure.type.hint_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigApacheFelixJettyBasedHttpService(org.apache.felix.https.nio=var.org.apache.felix.https.nio, org.apache.felix.https.nio.type.hint=var.org.apache.felix.https.nio.type.hint, org.apache.felix.https.keystore=var.org.apache.felix.https.keystore, org.apache.felix.https.keystore.type.hint=var.org.apache.felix.https.keystore.type.hint, org.apache.felix.https.keystore.password=var.org.apache.felix.https.keystore.password, org.apache.felix.https.keystore.password.type.hint=var.org.apache.felix.https.keystore.password.type.hint, org.apache.felix.https.keystore.key=var.org.apache.felix.https.keystore.key, org.apache.felix.https.keystore.key.type.hint=var.org.apache.felix.https.keystore.key.type.hint, org.apache.felix.https.keystore.key.password=var.org.apache.felix.https.keystore.key.password, org.apache.felix.https.keystore.key.password.type.hint=var.org.apache.felix.https.keystore.key.password.type.hint, org.apache.felix.https.truststore=var.org.apache.felix.https.truststore, org.apache.felix.https.truststore.type.hint=var.org.apache.felix.https.truststore.type.hint, org.apache.felix.https.truststore.password=var.org.apache.felix.https.truststore.password, org.apache.felix.https.truststore.password.type.hint=var.org.apache.felix.https.truststore.password.type.hint, org.apache.felix.https.clientcertificate=var.org.apache.felix.https.clientcertificate, org.apache.felix.https.clientcertificate.type.hint=var.org.apache.felix.https.clientcertificate.type.hint, org.apache.felix.https.enable=var.org.apache.felix.https.enable, org.apache.felix.https.enable.type.hint=var.org.apache.felix.https.enable.type.hint, org.osgi.service.http.port.secure=var.org.osgi.service.http.port.secure, org.osgi.service.http.port.secure.type.hint=var.org.osgi.service.http.port.secure.type.hint)
#'
#'
#' ####################  PostConfigApacheHttpComponentsProxyConfiguration  ####################
#'
#' library(openapi)
#' var.proxy.host <- 'proxy.host_example' # character | 
#' var.proxy.host.type.hint <- 'proxy.host.type.hint_example' # character | 
#' var.proxy.port <- 56 # integer | 
#' var.proxy.port.type.hint <- 'proxy.port.type.hint_example' # character | 
#' var.proxy.exceptions <- ['proxy.exceptions_example'] # array[character] | 
#' var.proxy.exceptions.type.hint <- 'proxy.exceptions.type.hint_example' # character | 
#' var.proxy.enabled <- 'proxy.enabled_example' # character | 
#' var.proxy.enabled.type.hint <- 'proxy.enabled.type.hint_example' # character | 
#' var.proxy.user <- 'proxy.user_example' # character | 
#' var.proxy.user.type.hint <- 'proxy.user.type.hint_example' # character | 
#' var.proxy.password <- 'proxy.password_example' # character | 
#' var.proxy.password.type.hint <- 'proxy.password.type.hint_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigApacheHttpComponentsProxyConfiguration(proxy.host=var.proxy.host, proxy.host.type.hint=var.proxy.host.type.hint, proxy.port=var.proxy.port, proxy.port.type.hint=var.proxy.port.type.hint, proxy.exceptions=var.proxy.exceptions, proxy.exceptions.type.hint=var.proxy.exceptions.type.hint, proxy.enabled=var.proxy.enabled, proxy.enabled.type.hint=var.proxy.enabled.type.hint, proxy.user=var.proxy.user, proxy.user.type.hint=var.proxy.user.type.hint, proxy.password=var.proxy.password, proxy.password.type.hint=var.proxy.password.type.hint)
#'
#'
#' ####################  PostConfigApacheSlingDavExServlet  ####################
#'
#' library(openapi)
#' var.alias <- 'alias_example' # character | 
#' var.alias.type.hint <- 'alias.type.hint_example' # character | 
#' var.dav.create.absolute.uri <- 'dav.create.absolute.uri_example' # character | 
#' var.dav.create.absolute.uri.type.hint <- 'dav.create.absolute.uri.type.hint_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigApacheSlingDavExServlet(alias=var.alias, alias.type.hint=var.alias.type.hint, dav.create.absolute.uri=var.dav.create.absolute.uri, dav.create.absolute.uri.type.hint=var.dav.create.absolute.uri.type.hint)
#'
#'
#' ####################  PostConfigApacheSlingGetServlet  ####################
#'
#' library(openapi)
#' var.json.maximumresults <- 'json.maximumresults_example' # character | 
#' var.json.maximumresults.type.hint <- 'json.maximumresults.type.hint_example' # character | 
#' var.enable.html <- 'enable.html_example' # character | 
#' var.enable.html.type.hint <- 'enable.html.type.hint_example' # character | 
#' var.enable.txt <- 'enable.txt_example' # character | 
#' var.enable.txt.type.hint <- 'enable.txt.type.hint_example' # character | 
#' var.enable.xml <- 'enable.xml_example' # character | 
#' var.enable.xml.type.hint <- 'enable.xml.type.hint_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigApacheSlingGetServlet(json.maximumresults=var.json.maximumresults, json.maximumresults.type.hint=var.json.maximumresults.type.hint, enable.html=var.enable.html, enable.html.type.hint=var.enable.html.type.hint, enable.txt=var.enable.txt, enable.txt.type.hint=var.enable.txt.type.hint, enable.xml=var.enable.xml, enable.xml.type.hint=var.enable.xml.type.hint)
#'
#'
#' ####################  PostConfigApacheSlingReferrerFilter  ####################
#'
#' library(openapi)
#' var.allow.empty <- 'allow.empty_example' # character | 
#' var.allow.empty.type.hint <- 'allow.empty.type.hint_example' # character | 
#' var.allow.hosts <- 'allow.hosts_example' # character | 
#' var.allow.hosts.type.hint <- 'allow.hosts.type.hint_example' # character | 
#' var.allow.hosts.regexp <- 'allow.hosts.regexp_example' # character | 
#' var.allow.hosts.regexp.type.hint <- 'allow.hosts.regexp.type.hint_example' # character | 
#' var.filter.methods <- 'filter.methods_example' # character | 
#' var.filter.methods.type.hint <- 'filter.methods.type.hint_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigApacheSlingReferrerFilter(allow.empty=var.allow.empty, allow.empty.type.hint=var.allow.empty.type.hint, allow.hosts=var.allow.hosts, allow.hosts.type.hint=var.allow.hosts.type.hint, allow.hosts.regexp=var.allow.hosts.regexp, allow.hosts.regexp.type.hint=var.allow.hosts.regexp.type.hint, filter.methods=var.filter.methods, filter.methods.type.hint=var.filter.methods.type.hint)
#'
#'
#' ####################  PostConfigProperty  ####################
#'
#' library(openapi)
#' var.config.node.name <- 'config.node.name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostConfigProperty(var.config.node.name)
#'
#'
#' ####################  PostNode  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.name <- 'name_example' # character | 
#' var.operation <- 'operation_example' # character | 
#' var.delete.authorizable <- 'delete.authorizable_example' # character | 
#' var.file <- File.new('/path/to/file') # data.frame | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostNode(var.path, var.name, operation=var.operation, delete.authorizable=var.delete.authorizable, file=var.file)
#'
#'
#' ####################  PostNodeRw  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.name <- 'name_example' # character | 
#' var.add.members <- 'add.members_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostNodeRw(var.path, var.name, add.members=var.add.members)
#'
#'
#' ####################  PostPath  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.jcrprimary.type <- 'jcrprimary.type_example' # character | 
#' var.name <- 'name_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostPath(var.path, var.jcrprimary.type, var.name)
#'
#'
#' ####################  PostQuery  ####################
#'
#' library(openapi)
#' var.path <- 'path_example' # character | 
#' var.p.limit <- 3.4 # numeric | 
#' var.Var1.property <- 'Var1.property_example' # character | 
#' var.Var1.property.value <- 'Var1.property.value_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostQuery(var.path, var.p.limit, var.Var1.property, var.Var1.property.value)
#'
#'
#' ####################  PostTreeActivation  ####################
#'
#' library(openapi)
#' var.ignoredeactivated <- 'ignoredeactivated_example' # character | 
#' var.onlymodified <- 'onlymodified_example' # character | 
#' var.path <- 'path_example' # character | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostTreeActivation(var.ignoredeactivated, var.onlymodified, var.path)
#'
#'
#' ####################  PostTruststore  ####################
#'
#' library(openapi)
#' var.operation <- 'operation_example' # character | 
#' var.new.password <- 'new.password_example' # character | 
#' var.re.password <- 're.password_example' # character | 
#' var.key.store.type <- 'key.store.type_example' # character | 
#' var.remove.alias <- 'remove.alias_example' # character | 
#' var.certificate <- File.new('/path/to/file') # data.frame | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostTruststore(operation=var.operation, new.password=var.new.password, re.password=var.re.password, key.store.type=var.key.store.type, remove.alias=var.remove.alias, certificate=var.certificate)
#'
#'
#' ####################  PostTruststorePKCS12  ####################
#'
#' library(openapi)
#' var.truststore.p12 <- File.new('/path/to/file') # data.frame | 
#'
#' api.instance <- SlingApi$new()
#'
#' #Configure HTTP basic authorization: aemAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$PostTruststorePKCS12(truststore.p12=var.truststore.p12)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
SlingApi <- R6::R6Class(
  'SlingApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    DeleteAgent = function(runmode, name, ...){
      apiResponse <- self$DeleteAgentWithHttpInfo(runmode, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteAgentWithHttpInfo = function(runmode, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`runmode`)) {
        stop("Missing required parameter `runmode`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      body <- NULL
      urlPath <- "/etc/replication/agents.{runmode}/{name}"
      if (!missing(`runmode`)) {
        urlPath <- gsub(paste0("\\{", "runmode", "\\}"), URLencode(as.character(`runmode`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteNode = function(path, name, ...){
      apiResponse <- self$DeleteNodeWithHttpInfo(path, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteNodeWithHttpInfo = function(path, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      body <- NULL
      urlPath <- "/{path}/{name}"
      if (!missing(`path`)) {
        urlPath <- gsub(paste0("\\{", "path", "\\}"), URLencode(as.character(`path`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAgent = function(runmode, name, ...){
      apiResponse <- self$GetAgentWithHttpInfo(runmode, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAgentWithHttpInfo = function(runmode, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`runmode`)) {
        stop("Missing required parameter `runmode`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      body <- NULL
      urlPath <- "/etc/replication/agents.{runmode}/{name}"
      if (!missing(`runmode`)) {
        urlPath <- gsub(paste0("\\{", "runmode", "\\}"), URLencode(as.character(`runmode`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAgents = function(runmode, ...){
      apiResponse <- self$GetAgentsWithHttpInfo(runmode, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAgentsWithHttpInfo = function(runmode, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`runmode`)) {
        stop("Missing required parameter `runmode`.")
      }

      body <- NULL
      urlPath <- "/etc/replication/agents.{runmode}.-1.json"
      if (!missing(`runmode`)) {
        urlPath <- gsub(paste0("\\{", "runmode", "\\}"), URLencode(as.character(`runmode`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAuthorizableKeystore = function(intermediate.path, authorizable.id, ...){
      apiResponse <- self$GetAuthorizableKeystoreWithHttpInfo(intermediate.path, authorizable.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAuthorizableKeystoreWithHttpInfo = function(intermediate.path, authorizable.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`intermediate.path`)) {
        stop("Missing required parameter `intermediate.path`.")
      }

      if (missing(`authorizable.id`)) {
        stop("Missing required parameter `authorizable.id`.")
      }

      body <- NULL
      urlPath <- "/{intermediatePath}/{authorizableId}.ks.json"
      if (!missing(`intermediate.path`)) {
        urlPath <- gsub(paste0("\\{", "intermediatePath", "\\}"), URLencode(as.character(`intermediate.path`), reserved = TRUE), urlPath)
      }

      if (!missing(`authorizable.id`)) {
        urlPath <- gsub(paste0("\\{", "authorizableId", "\\}"), URLencode(as.character(`authorizable.id`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "KeystoreInfo", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetKeystore = function(intermediate.path, authorizable.id, ...){
      apiResponse <- self$GetKeystoreWithHttpInfo(intermediate.path, authorizable.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetKeystoreWithHttpInfo = function(intermediate.path, authorizable.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`intermediate.path`)) {
        stop("Missing required parameter `intermediate.path`.")
      }

      if (missing(`authorizable.id`)) {
        stop("Missing required parameter `authorizable.id`.")
      }

      body <- NULL
      urlPath <- "/{intermediatePath}/{authorizableId}/keystore/store.p12"
      if (!missing(`intermediate.path`)) {
        urlPath <- gsub(paste0("\\{", "intermediatePath", "\\}"), URLencode(as.character(`intermediate.path`), reserved = TRUE), urlPath)
      }

      if (!missing(`authorizable.id`)) {
        urlPath <- gsub(paste0("\\{", "authorizableId", "\\}"), URLencode(as.character(`authorizable.id`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetNode = function(path, name, ...){
      apiResponse <- self$GetNodeWithHttpInfo(path, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetNodeWithHttpInfo = function(path, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      body <- NULL
      urlPath <- "/{path}/{name}"
      if (!missing(`path`)) {
        urlPath <- gsub(paste0("\\{", "path", "\\}"), URLencode(as.character(`path`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetPackage = function(group, name, version, ...){
      apiResponse <- self$GetPackageWithHttpInfo(group, name, version, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetPackageWithHttpInfo = function(group, name, version, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group`)) {
        stop("Missing required parameter `group`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      body <- NULL
      urlPath <- "/etc/packages/{group}/{name}-{version}.zip"
      if (!missing(`group`)) {
        urlPath <- gsub(paste0("\\{", "group", "\\}"), URLencode(as.character(`group`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      if (!missing(`version`)) {
        urlPath <- gsub(paste0("\\{", "version", "\\}"), URLencode(as.character(`version`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetPackageFilter = function(group, name, version, ...){
      apiResponse <- self$GetPackageFilterWithHttpInfo(group, name, version, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetPackageFilterWithHttpInfo = function(group, name, version, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group`)) {
        stop("Missing required parameter `group`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      body <- NULL
      urlPath <- "/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json"
      if (!missing(`group`)) {
        urlPath <- gsub(paste0("\\{", "group", "\\}"), URLencode(as.character(`group`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      if (!missing(`version`)) {
        urlPath <- gsub(paste0("\\{", "version", "\\}"), URLencode(as.character(`version`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetQuery = function(path, p.limit, Var1.property, Var1.property.value, ...){
      apiResponse <- self$GetQueryWithHttpInfo(path, p.limit, Var1.property, Var1.property.value, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetQueryWithHttpInfo = function(path, p.limit, Var1.property, Var1.property.value, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`p.limit`)) {
        stop("Missing required parameter `p.limit`.")
      }

      if (missing(`Var1.property`)) {
        stop("Missing required parameter `Var1.property`.")
      }

      if (missing(`Var1.property.value`)) {
        stop("Missing required parameter `Var1.property.value`.")
      }

      queryParams['path'] <- path

      queryParams['p.limit'] <- p.limit

      queryParams['1_property'] <- Var1.property

      queryParams['1_property.value'] <- Var1.property.value

      body <- NULL
      urlPath <- "/bin/querybuilder.json"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetTruststore = function(...){
      apiResponse <- self$GetTruststoreWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetTruststoreWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/etc/truststore/truststore.p12"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetTruststoreInfo = function(...){
      apiResponse <- self$GetTruststoreInfoWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetTruststoreInfoWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/libs/granite/security/truststore.json"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TruststoreInfo", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostAgent = function(runmode, name, jcrcontent.cqdistribute=NULL, jcrcontent.cqdistribute.type.hint=NULL, jcrcontent.cqname=NULL, jcrcontent.cqtemplate=NULL, jcrcontent.enabled=NULL, jcrcontent.jcrdescription=NULL, jcrcontent.jcrlast.modified=NULL, jcrcontent.jcrlast.modified.by=NULL, jcrcontent.jcrmixin.types=NULL, jcrcontent.jcrtitle=NULL, jcrcontent.log.level=NULL, jcrcontent.no.status.update=NULL, jcrcontent.no.versioning=NULL, jcrcontent.protocol.connect.timeout=NULL, jcrcontent.protocol.http.connection.closed=NULL, jcrcontent.protocol.http.expired=NULL, jcrcontent.protocol.http.headers=NULL, jcrcontent.protocol.http.headers.type.hint=NULL, jcrcontent.protocol.http.method=NULL, jcrcontent.protocol.https.relaxed=NULL, jcrcontent.protocol.interface=NULL, jcrcontent.protocol.socket.timeout=NULL, jcrcontent.protocol.version=NULL, jcrcontent.proxy.ntlm.domain=NULL, jcrcontent.proxy.ntlm.host=NULL, jcrcontent.proxy.host=NULL, jcrcontent.proxy.password=NULL, jcrcontent.proxy.port=NULL, jcrcontent.proxy.user=NULL, jcrcontent.queue.batch.max.size=NULL, jcrcontent.queue.batch.mode=NULL, jcrcontent.queue.batch.wait.time=NULL, jcrcontent.retry.delay=NULL, jcrcontent.reverse.replication=NULL, jcrcontent.serialization.type=NULL, jcrcontent.slingresource.type=NULL, jcrcontent.ssl=NULL, jcrcontent.transport.ntlm.domain=NULL, jcrcontent.transport.ntlm.host=NULL, jcrcontent.transport.password=NULL, jcrcontent.transport.uri=NULL, jcrcontent.transport.user=NULL, jcrcontent.trigger.distribute=NULL, jcrcontent.trigger.modified=NULL, jcrcontent.trigger.on.off.time=NULL, jcrcontent.trigger.receive=NULL, jcrcontent.trigger.specific=NULL, jcrcontent.user.id=NULL, jcrprimary.type=NULL, operation=NULL, ...){
      apiResponse <- self$PostAgentWithHttpInfo(runmode, name, jcrcontent.cqdistribute, jcrcontent.cqdistribute.type.hint, jcrcontent.cqname, jcrcontent.cqtemplate, jcrcontent.enabled, jcrcontent.jcrdescription, jcrcontent.jcrlast.modified, jcrcontent.jcrlast.modified.by, jcrcontent.jcrmixin.types, jcrcontent.jcrtitle, jcrcontent.log.level, jcrcontent.no.status.update, jcrcontent.no.versioning, jcrcontent.protocol.connect.timeout, jcrcontent.protocol.http.connection.closed, jcrcontent.protocol.http.expired, jcrcontent.protocol.http.headers, jcrcontent.protocol.http.headers.type.hint, jcrcontent.protocol.http.method, jcrcontent.protocol.https.relaxed, jcrcontent.protocol.interface, jcrcontent.protocol.socket.timeout, jcrcontent.protocol.version, jcrcontent.proxy.ntlm.domain, jcrcontent.proxy.ntlm.host, jcrcontent.proxy.host, jcrcontent.proxy.password, jcrcontent.proxy.port, jcrcontent.proxy.user, jcrcontent.queue.batch.max.size, jcrcontent.queue.batch.mode, jcrcontent.queue.batch.wait.time, jcrcontent.retry.delay, jcrcontent.reverse.replication, jcrcontent.serialization.type, jcrcontent.slingresource.type, jcrcontent.ssl, jcrcontent.transport.ntlm.domain, jcrcontent.transport.ntlm.host, jcrcontent.transport.password, jcrcontent.transport.uri, jcrcontent.transport.user, jcrcontent.trigger.distribute, jcrcontent.trigger.modified, jcrcontent.trigger.on.off.time, jcrcontent.trigger.receive, jcrcontent.trigger.specific, jcrcontent.user.id, jcrprimary.type, operation, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostAgentWithHttpInfo = function(runmode, name, jcrcontent.cqdistribute=NULL, jcrcontent.cqdistribute.type.hint=NULL, jcrcontent.cqname=NULL, jcrcontent.cqtemplate=NULL, jcrcontent.enabled=NULL, jcrcontent.jcrdescription=NULL, jcrcontent.jcrlast.modified=NULL, jcrcontent.jcrlast.modified.by=NULL, jcrcontent.jcrmixin.types=NULL, jcrcontent.jcrtitle=NULL, jcrcontent.log.level=NULL, jcrcontent.no.status.update=NULL, jcrcontent.no.versioning=NULL, jcrcontent.protocol.connect.timeout=NULL, jcrcontent.protocol.http.connection.closed=NULL, jcrcontent.protocol.http.expired=NULL, jcrcontent.protocol.http.headers=NULL, jcrcontent.protocol.http.headers.type.hint=NULL, jcrcontent.protocol.http.method=NULL, jcrcontent.protocol.https.relaxed=NULL, jcrcontent.protocol.interface=NULL, jcrcontent.protocol.socket.timeout=NULL, jcrcontent.protocol.version=NULL, jcrcontent.proxy.ntlm.domain=NULL, jcrcontent.proxy.ntlm.host=NULL, jcrcontent.proxy.host=NULL, jcrcontent.proxy.password=NULL, jcrcontent.proxy.port=NULL, jcrcontent.proxy.user=NULL, jcrcontent.queue.batch.max.size=NULL, jcrcontent.queue.batch.mode=NULL, jcrcontent.queue.batch.wait.time=NULL, jcrcontent.retry.delay=NULL, jcrcontent.reverse.replication=NULL, jcrcontent.serialization.type=NULL, jcrcontent.slingresource.type=NULL, jcrcontent.ssl=NULL, jcrcontent.transport.ntlm.domain=NULL, jcrcontent.transport.ntlm.host=NULL, jcrcontent.transport.password=NULL, jcrcontent.transport.uri=NULL, jcrcontent.transport.user=NULL, jcrcontent.trigger.distribute=NULL, jcrcontent.trigger.modified=NULL, jcrcontent.trigger.on.off.time=NULL, jcrcontent.trigger.receive=NULL, jcrcontent.trigger.specific=NULL, jcrcontent.user.id=NULL, jcrprimary.type=NULL, operation=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`runmode`)) {
        stop("Missing required parameter `runmode`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      queryParams['jcr:content/cq:distribute'] <- jcrcontent.cqdistribute

      queryParams['jcr:content/cq:distribute@TypeHint'] <- jcrcontent.cqdistribute.type.hint

      queryParams['jcr:content/cq:name'] <- jcrcontent.cqname

      queryParams['jcr:content/cq:template'] <- jcrcontent.cqtemplate

      queryParams['jcr:content/enabled'] <- jcrcontent.enabled

      queryParams['jcr:content/jcr:description'] <- jcrcontent.jcrdescription

      queryParams['jcr:content/jcr:lastModified'] <- jcrcontent.jcrlast.modified

      queryParams['jcr:content/jcr:lastModifiedBy'] <- jcrcontent.jcrlast.modified.by

      queryParams['jcr:content/jcr:mixinTypes'] <- jcrcontent.jcrmixin.types

      queryParams['jcr:content/jcr:title'] <- jcrcontent.jcrtitle

      queryParams['jcr:content/logLevel'] <- jcrcontent.log.level

      queryParams['jcr:content/noStatusUpdate'] <- jcrcontent.no.status.update

      queryParams['jcr:content/noVersioning'] <- jcrcontent.no.versioning

      queryParams['jcr:content/protocolConnectTimeout'] <- jcrcontent.protocol.connect.timeout

      queryParams['jcr:content/protocolHTTPConnectionClosed'] <- jcrcontent.protocol.http.connection.closed

      queryParams['jcr:content/protocolHTTPExpired'] <- jcrcontent.protocol.http.expired

      queryParams['jcr:content/protocolHTTPHeaders'] <- jcrcontent.protocol.http.headers

      queryParams['jcr:content/protocolHTTPHeaders@TypeHint'] <- jcrcontent.protocol.http.headers.type.hint

      queryParams['jcr:content/protocolHTTPMethod'] <- jcrcontent.protocol.http.method

      queryParams['jcr:content/protocolHTTPSRelaxed'] <- jcrcontent.protocol.https.relaxed

      queryParams['jcr:content/protocolInterface'] <- jcrcontent.protocol.interface

      queryParams['jcr:content/protocolSocketTimeout'] <- jcrcontent.protocol.socket.timeout

      queryParams['jcr:content/protocolVersion'] <- jcrcontent.protocol.version

      queryParams['jcr:content/proxyNTLMDomain'] <- jcrcontent.proxy.ntlm.domain

      queryParams['jcr:content/proxyNTLMHost'] <- jcrcontent.proxy.ntlm.host

      queryParams['jcr:content/proxyHost'] <- jcrcontent.proxy.host

      queryParams['jcr:content/proxyPassword'] <- jcrcontent.proxy.password

      queryParams['jcr:content/proxyPort'] <- jcrcontent.proxy.port

      queryParams['jcr:content/proxyUser'] <- jcrcontent.proxy.user

      queryParams['jcr:content/queueBatchMaxSize'] <- jcrcontent.queue.batch.max.size

      queryParams['jcr:content/queueBatchMode'] <- jcrcontent.queue.batch.mode

      queryParams['jcr:content/queueBatchWaitTime'] <- jcrcontent.queue.batch.wait.time

      queryParams['jcr:content/retryDelay'] <- jcrcontent.retry.delay

      queryParams['jcr:content/reverseReplication'] <- jcrcontent.reverse.replication

      queryParams['jcr:content/serializationType'] <- jcrcontent.serialization.type

      queryParams['jcr:content/sling:resourceType'] <- jcrcontent.slingresource.type

      queryParams['jcr:content/ssl'] <- jcrcontent.ssl

      queryParams['jcr:content/transportNTLMDomain'] <- jcrcontent.transport.ntlm.domain

      queryParams['jcr:content/transportNTLMHost'] <- jcrcontent.transport.ntlm.host

      queryParams['jcr:content/transportPassword'] <- jcrcontent.transport.password

      queryParams['jcr:content/transportUri'] <- jcrcontent.transport.uri

      queryParams['jcr:content/transportUser'] <- jcrcontent.transport.user

      queryParams['jcr:content/triggerDistribute'] <- jcrcontent.trigger.distribute

      queryParams['jcr:content/triggerModified'] <- jcrcontent.trigger.modified

      queryParams['jcr:content/triggerOnOffTime'] <- jcrcontent.trigger.on.off.time

      queryParams['jcr:content/triggerReceive'] <- jcrcontent.trigger.receive

      queryParams['jcr:content/triggerSpecific'] <- jcrcontent.trigger.specific

      queryParams['jcr:content/userId'] <- jcrcontent.user.id

      queryParams['jcr:primaryType'] <- jcrprimary.type

      queryParams[':operation'] <- operation

      body <- NULL
      urlPath <- "/etc/replication/agents.{runmode}/{name}"
      if (!missing(`runmode`)) {
        urlPath <- gsub(paste0("\\{", "runmode", "\\}"), URLencode(as.character(`runmode`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostAuthorizableKeystore = function(intermediate.path, authorizable.id, operation=NULL, current.password=NULL, new.password=NULL, re.password=NULL, key.password=NULL, key.store.pass=NULL, alias=NULL, new.alias=NULL, remove.alias=NULL, cert.chain=NULL, pk=NULL, key.store=NULL, ...){
      apiResponse <- self$PostAuthorizableKeystoreWithHttpInfo(intermediate.path, authorizable.id, operation, current.password, new.password, re.password, key.password, key.store.pass, alias, new.alias, remove.alias, cert.chain, pk, key.store, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostAuthorizableKeystoreWithHttpInfo = function(intermediate.path, authorizable.id, operation=NULL, current.password=NULL, new.password=NULL, re.password=NULL, key.password=NULL, key.store.pass=NULL, alias=NULL, new.alias=NULL, remove.alias=NULL, cert.chain=NULL, pk=NULL, key.store=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`intermediate.path`)) {
        stop("Missing required parameter `intermediate.path`.")
      }

      if (missing(`authorizable.id`)) {
        stop("Missing required parameter `authorizable.id`.")
      }

      queryParams[':operation'] <- operation

      queryParams['currentPassword'] <- current.password

      queryParams['newPassword'] <- new.password

      queryParams['rePassword'] <- re.password

      queryParams['keyPassword'] <- key.password

      queryParams['keyStorePass'] <- key.store.pass

      queryParams['alias'] <- alias

      queryParams['newAlias'] <- new.alias

      queryParams['removeAlias'] <- remove.alias

      body <- list(
        "cert-chain" = httr::upload_file(cert.chain),
        "pk" = httr::upload_file(pk),
        "keyStore" = httr::upload_file(key.store)
      )

      urlPath <- "/{intermediatePath}/{authorizableId}.ks.html"
      if (!missing(`intermediate.path`)) {
        urlPath <- gsub(paste0("\\{", "intermediatePath", "\\}"), URLencode(as.character(`intermediate.path`), reserved = TRUE), urlPath)
      }

      if (!missing(`authorizable.id`)) {
        urlPath <- gsub(paste0("\\{", "authorizableId", "\\}"), URLencode(as.character(`authorizable.id`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "KeystoreInfo", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostAuthorizables = function(authorizable.id, intermediate.path, create.user=NULL, create.group=NULL, reppassword=NULL, profile.given.name=NULL, ...){
      apiResponse <- self$PostAuthorizablesWithHttpInfo(authorizable.id, intermediate.path, create.user, create.group, reppassword, profile.given.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostAuthorizablesWithHttpInfo = function(authorizable.id, intermediate.path, create.user=NULL, create.group=NULL, reppassword=NULL, profile.given.name=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`authorizable.id`)) {
        stop("Missing required parameter `authorizable.id`.")
      }

      if (missing(`intermediate.path`)) {
        stop("Missing required parameter `intermediate.path`.")
      }

      queryParams['authorizableId'] <- authorizable.id

      queryParams['intermediatePath'] <- intermediate.path

      queryParams['createUser'] <- create.user

      queryParams['createGroup'] <- create.group

      queryParams['rep:password'] <- reppassword

      queryParams['profile/givenName'] <- profile.given.name

      body <- NULL
      urlPath <- "/libs/granite/security/post/authorizables"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigAdobeGraniteSamlAuthenticationHandler = function(key.store.password=NULL, key.store.password.type.hint=NULL, service.ranking=NULL, service.ranking.type.hint=NULL, idp.http.redirect=NULL, idp.http.redirect.type.hint=NULL, create.user=NULL, create.user.type.hint=NULL, default.redirect.url=NULL, default.redirect.url.type.hint=NULL, user.id.attribute=NULL, user.id.attribute.type.hint=NULL, default.groups=NULL, default.groups.type.hint=NULL, idp.cert.alias=NULL, idp.cert.alias.type.hint=NULL, add.group.memberships=NULL, add.group.memberships.type.hint=NULL, path=NULL, path.type.hint=NULL, synchronize.attributes=NULL, synchronize.attributes.type.hint=NULL, clock.tolerance=NULL, clock.tolerance.type.hint=NULL, group.membership.attribute=NULL, group.membership.attribute.type.hint=NULL, idp.url=NULL, idp.url.type.hint=NULL, logout.url=NULL, logout.url.type.hint=NULL, service.provider.entity.id=NULL, service.provider.entity.id.type.hint=NULL, assertion.consumer.service.url=NULL, assertion.consumer.service.url.type.hint=NULL, handle.logout=NULL, handle.logout.type.hint=NULL, sp.private.key.alias=NULL, sp.private.key.alias.type.hint=NULL, use.encryption=NULL, use.encryption.type.hint=NULL, name.id.format=NULL, name.id.format.type.hint=NULL, digest.method=NULL, digest.method.type.hint=NULL, signature.method=NULL, signature.method.type.hint=NULL, user.intermediate.path=NULL, user.intermediate.path.type.hint=NULL, ...){
      apiResponse <- self$PostConfigAdobeGraniteSamlAuthenticationHandlerWithHttpInfo(key.store.password, key.store.password.type.hint, service.ranking, service.ranking.type.hint, idp.http.redirect, idp.http.redirect.type.hint, create.user, create.user.type.hint, default.redirect.url, default.redirect.url.type.hint, user.id.attribute, user.id.attribute.type.hint, default.groups, default.groups.type.hint, idp.cert.alias, idp.cert.alias.type.hint, add.group.memberships, add.group.memberships.type.hint, path, path.type.hint, synchronize.attributes, synchronize.attributes.type.hint, clock.tolerance, clock.tolerance.type.hint, group.membership.attribute, group.membership.attribute.type.hint, idp.url, idp.url.type.hint, logout.url, logout.url.type.hint, service.provider.entity.id, service.provider.entity.id.type.hint, assertion.consumer.service.url, assertion.consumer.service.url.type.hint, handle.logout, handle.logout.type.hint, sp.private.key.alias, sp.private.key.alias.type.hint, use.encryption, use.encryption.type.hint, name.id.format, name.id.format.type.hint, digest.method, digest.method.type.hint, signature.method, signature.method.type.hint, user.intermediate.path, user.intermediate.path.type.hint, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigAdobeGraniteSamlAuthenticationHandlerWithHttpInfo = function(key.store.password=NULL, key.store.password.type.hint=NULL, service.ranking=NULL, service.ranking.type.hint=NULL, idp.http.redirect=NULL, idp.http.redirect.type.hint=NULL, create.user=NULL, create.user.type.hint=NULL, default.redirect.url=NULL, default.redirect.url.type.hint=NULL, user.id.attribute=NULL, user.id.attribute.type.hint=NULL, default.groups=NULL, default.groups.type.hint=NULL, idp.cert.alias=NULL, idp.cert.alias.type.hint=NULL, add.group.memberships=NULL, add.group.memberships.type.hint=NULL, path=NULL, path.type.hint=NULL, synchronize.attributes=NULL, synchronize.attributes.type.hint=NULL, clock.tolerance=NULL, clock.tolerance.type.hint=NULL, group.membership.attribute=NULL, group.membership.attribute.type.hint=NULL, idp.url=NULL, idp.url.type.hint=NULL, logout.url=NULL, logout.url.type.hint=NULL, service.provider.entity.id=NULL, service.provider.entity.id.type.hint=NULL, assertion.consumer.service.url=NULL, assertion.consumer.service.url.type.hint=NULL, handle.logout=NULL, handle.logout.type.hint=NULL, sp.private.key.alias=NULL, sp.private.key.alias.type.hint=NULL, use.encryption=NULL, use.encryption.type.hint=NULL, name.id.format=NULL, name.id.format.type.hint=NULL, digest.method=NULL, digest.method.type.hint=NULL, signature.method=NULL, signature.method.type.hint=NULL, user.intermediate.path=NULL, user.intermediate.path.type.hint=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['keyStorePassword'] <- key.store.password

      queryParams['keyStorePassword@TypeHint'] <- key.store.password.type.hint

      queryParams['service.ranking'] <- service.ranking

      queryParams['service.ranking@TypeHint'] <- service.ranking.type.hint

      queryParams['idpHttpRedirect'] <- idp.http.redirect

      queryParams['idpHttpRedirect@TypeHint'] <- idp.http.redirect.type.hint

      queryParams['createUser'] <- create.user

      queryParams['createUser@TypeHint'] <- create.user.type.hint

      queryParams['defaultRedirectUrl'] <- default.redirect.url

      queryParams['defaultRedirectUrl@TypeHint'] <- default.redirect.url.type.hint

      queryParams['userIDAttribute'] <- user.id.attribute

      queryParams['userIDAttribute@TypeHint'] <- user.id.attribute.type.hint

      queryParams['defaultGroups'] <- default.groups

      queryParams['defaultGroups@TypeHint'] <- default.groups.type.hint

      queryParams['idpCertAlias'] <- idp.cert.alias

      queryParams['idpCertAlias@TypeHint'] <- idp.cert.alias.type.hint

      queryParams['addGroupMemberships'] <- add.group.memberships

      queryParams['addGroupMemberships@TypeHint'] <- add.group.memberships.type.hint

      queryParams['path'] <- path

      queryParams['path@TypeHint'] <- path.type.hint

      queryParams['synchronizeAttributes'] <- synchronize.attributes

      queryParams['synchronizeAttributes@TypeHint'] <- synchronize.attributes.type.hint

      queryParams['clockTolerance'] <- clock.tolerance

      queryParams['clockTolerance@TypeHint'] <- clock.tolerance.type.hint

      queryParams['groupMembershipAttribute'] <- group.membership.attribute

      queryParams['groupMembershipAttribute@TypeHint'] <- group.membership.attribute.type.hint

      queryParams['idpUrl'] <- idp.url

      queryParams['idpUrl@TypeHint'] <- idp.url.type.hint

      queryParams['logoutUrl'] <- logout.url

      queryParams['logoutUrl@TypeHint'] <- logout.url.type.hint

      queryParams['serviceProviderEntityId'] <- service.provider.entity.id

      queryParams['serviceProviderEntityId@TypeHint'] <- service.provider.entity.id.type.hint

      queryParams['assertionConsumerServiceURL'] <- assertion.consumer.service.url

      queryParams['assertionConsumerServiceURL@TypeHint'] <- assertion.consumer.service.url.type.hint

      queryParams['handleLogout'] <- handle.logout

      queryParams['handleLogout@TypeHint'] <- handle.logout.type.hint

      queryParams['spPrivateKeyAlias'] <- sp.private.key.alias

      queryParams['spPrivateKeyAlias@TypeHint'] <- sp.private.key.alias.type.hint

      queryParams['useEncryption'] <- use.encryption

      queryParams['useEncryption@TypeHint'] <- use.encryption.type.hint

      queryParams['nameIdFormat'] <- name.id.format

      queryParams['nameIdFormat@TypeHint'] <- name.id.format.type.hint

      queryParams['digestMethod'] <- digest.method

      queryParams['digestMethod@TypeHint'] <- digest.method.type.hint

      queryParams['signatureMethod'] <- signature.method

      queryParams['signatureMethod@TypeHint'] <- signature.method.type.hint

      queryParams['userIntermediatePath'] <- user.intermediate.path

      queryParams['userIntermediatePath@TypeHint'] <- user.intermediate.path.type.hint

      body <- NULL
      urlPath <- "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigApacheFelixJettyBasedHttpService = function(org.apache.felix.https.nio=NULL, org.apache.felix.https.nio.type.hint=NULL, org.apache.felix.https.keystore=NULL, org.apache.felix.https.keystore.type.hint=NULL, org.apache.felix.https.keystore.password=NULL, org.apache.felix.https.keystore.password.type.hint=NULL, org.apache.felix.https.keystore.key=NULL, org.apache.felix.https.keystore.key.type.hint=NULL, org.apache.felix.https.keystore.key.password=NULL, org.apache.felix.https.keystore.key.password.type.hint=NULL, org.apache.felix.https.truststore=NULL, org.apache.felix.https.truststore.type.hint=NULL, org.apache.felix.https.truststore.password=NULL, org.apache.felix.https.truststore.password.type.hint=NULL, org.apache.felix.https.clientcertificate=NULL, org.apache.felix.https.clientcertificate.type.hint=NULL, org.apache.felix.https.enable=NULL, org.apache.felix.https.enable.type.hint=NULL, org.osgi.service.http.port.secure=NULL, org.osgi.service.http.port.secure.type.hint=NULL, ...){
      apiResponse <- self$PostConfigApacheFelixJettyBasedHttpServiceWithHttpInfo(org.apache.felix.https.nio, org.apache.felix.https.nio.type.hint, org.apache.felix.https.keystore, org.apache.felix.https.keystore.type.hint, org.apache.felix.https.keystore.password, org.apache.felix.https.keystore.password.type.hint, org.apache.felix.https.keystore.key, org.apache.felix.https.keystore.key.type.hint, org.apache.felix.https.keystore.key.password, org.apache.felix.https.keystore.key.password.type.hint, org.apache.felix.https.truststore, org.apache.felix.https.truststore.type.hint, org.apache.felix.https.truststore.password, org.apache.felix.https.truststore.password.type.hint, org.apache.felix.https.clientcertificate, org.apache.felix.https.clientcertificate.type.hint, org.apache.felix.https.enable, org.apache.felix.https.enable.type.hint, org.osgi.service.http.port.secure, org.osgi.service.http.port.secure.type.hint, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigApacheFelixJettyBasedHttpServiceWithHttpInfo = function(org.apache.felix.https.nio=NULL, org.apache.felix.https.nio.type.hint=NULL, org.apache.felix.https.keystore=NULL, org.apache.felix.https.keystore.type.hint=NULL, org.apache.felix.https.keystore.password=NULL, org.apache.felix.https.keystore.password.type.hint=NULL, org.apache.felix.https.keystore.key=NULL, org.apache.felix.https.keystore.key.type.hint=NULL, org.apache.felix.https.keystore.key.password=NULL, org.apache.felix.https.keystore.key.password.type.hint=NULL, org.apache.felix.https.truststore=NULL, org.apache.felix.https.truststore.type.hint=NULL, org.apache.felix.https.truststore.password=NULL, org.apache.felix.https.truststore.password.type.hint=NULL, org.apache.felix.https.clientcertificate=NULL, org.apache.felix.https.clientcertificate.type.hint=NULL, org.apache.felix.https.enable=NULL, org.apache.felix.https.enable.type.hint=NULL, org.osgi.service.http.port.secure=NULL, org.osgi.service.http.port.secure.type.hint=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['org.apache.felix.https.nio'] <- org.apache.felix.https.nio

      queryParams['org.apache.felix.https.nio@TypeHint'] <- org.apache.felix.https.nio.type.hint

      queryParams['org.apache.felix.https.keystore'] <- org.apache.felix.https.keystore

      queryParams['org.apache.felix.https.keystore@TypeHint'] <- org.apache.felix.https.keystore.type.hint

      queryParams['org.apache.felix.https.keystore.password'] <- org.apache.felix.https.keystore.password

      queryParams['org.apache.felix.https.keystore.password@TypeHint'] <- org.apache.felix.https.keystore.password.type.hint

      queryParams['org.apache.felix.https.keystore.key'] <- org.apache.felix.https.keystore.key

      queryParams['org.apache.felix.https.keystore.key@TypeHint'] <- org.apache.felix.https.keystore.key.type.hint

      queryParams['org.apache.felix.https.keystore.key.password'] <- org.apache.felix.https.keystore.key.password

      queryParams['org.apache.felix.https.keystore.key.password@TypeHint'] <- org.apache.felix.https.keystore.key.password.type.hint

      queryParams['org.apache.felix.https.truststore'] <- org.apache.felix.https.truststore

      queryParams['org.apache.felix.https.truststore@TypeHint'] <- org.apache.felix.https.truststore.type.hint

      queryParams['org.apache.felix.https.truststore.password'] <- org.apache.felix.https.truststore.password

      queryParams['org.apache.felix.https.truststore.password@TypeHint'] <- org.apache.felix.https.truststore.password.type.hint

      queryParams['org.apache.felix.https.clientcertificate'] <- org.apache.felix.https.clientcertificate

      queryParams['org.apache.felix.https.clientcertificate@TypeHint'] <- org.apache.felix.https.clientcertificate.type.hint

      queryParams['org.apache.felix.https.enable'] <- org.apache.felix.https.enable

      queryParams['org.apache.felix.https.enable@TypeHint'] <- org.apache.felix.https.enable.type.hint

      queryParams['org.osgi.service.http.port.secure'] <- org.osgi.service.http.port.secure

      queryParams['org.osgi.service.http.port.secure@TypeHint'] <- org.osgi.service.http.port.secure.type.hint

      body <- NULL
      urlPath <- "/apps/system/config/org.apache.felix.http"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigApacheHttpComponentsProxyConfiguration = function(proxy.host=NULL, proxy.host.type.hint=NULL, proxy.port=NULL, proxy.port.type.hint=NULL, proxy.exceptions=NULL, proxy.exceptions.type.hint=NULL, proxy.enabled=NULL, proxy.enabled.type.hint=NULL, proxy.user=NULL, proxy.user.type.hint=NULL, proxy.password=NULL, proxy.password.type.hint=NULL, ...){
      apiResponse <- self$PostConfigApacheHttpComponentsProxyConfigurationWithHttpInfo(proxy.host, proxy.host.type.hint, proxy.port, proxy.port.type.hint, proxy.exceptions, proxy.exceptions.type.hint, proxy.enabled, proxy.enabled.type.hint, proxy.user, proxy.user.type.hint, proxy.password, proxy.password.type.hint, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigApacheHttpComponentsProxyConfigurationWithHttpInfo = function(proxy.host=NULL, proxy.host.type.hint=NULL, proxy.port=NULL, proxy.port.type.hint=NULL, proxy.exceptions=NULL, proxy.exceptions.type.hint=NULL, proxy.enabled=NULL, proxy.enabled.type.hint=NULL, proxy.user=NULL, proxy.user.type.hint=NULL, proxy.password=NULL, proxy.password.type.hint=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['proxy.host'] <- proxy.host

      queryParams['proxy.host@TypeHint'] <- proxy.host.type.hint

      queryParams['proxy.port'] <- proxy.port

      queryParams['proxy.port@TypeHint'] <- proxy.port.type.hint

      queryParams['proxy.exceptions'] <- proxy.exceptions

      queryParams['proxy.exceptions@TypeHint'] <- proxy.exceptions.type.hint

      queryParams['proxy.enabled'] <- proxy.enabled

      queryParams['proxy.enabled@TypeHint'] <- proxy.enabled.type.hint

      queryParams['proxy.user'] <- proxy.user

      queryParams['proxy.user@TypeHint'] <- proxy.user.type.hint

      queryParams['proxy.password'] <- proxy.password

      queryParams['proxy.password@TypeHint'] <- proxy.password.type.hint

      body <- NULL
      urlPath <- "/apps/system/config/org.apache.http.proxyconfigurator.config"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigApacheSlingDavExServlet = function(alias=NULL, alias.type.hint=NULL, dav.create.absolute.uri=NULL, dav.create.absolute.uri.type.hint=NULL, ...){
      apiResponse <- self$PostConfigApacheSlingDavExServletWithHttpInfo(alias, alias.type.hint, dav.create.absolute.uri, dav.create.absolute.uri.type.hint, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigApacheSlingDavExServletWithHttpInfo = function(alias=NULL, alias.type.hint=NULL, dav.create.absolute.uri=NULL, dav.create.absolute.uri.type.hint=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['alias'] <- alias

      queryParams['alias@TypeHint'] <- alias.type.hint

      queryParams['dav.create-absolute-uri'] <- dav.create.absolute.uri

      queryParams['dav.create-absolute-uri@TypeHint'] <- dav.create.absolute.uri.type.hint

      body <- NULL
      urlPath <- "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigApacheSlingGetServlet = function(json.maximumresults=NULL, json.maximumresults.type.hint=NULL, enable.html=NULL, enable.html.type.hint=NULL, enable.txt=NULL, enable.txt.type.hint=NULL, enable.xml=NULL, enable.xml.type.hint=NULL, ...){
      apiResponse <- self$PostConfigApacheSlingGetServletWithHttpInfo(json.maximumresults, json.maximumresults.type.hint, enable.html, enable.html.type.hint, enable.txt, enable.txt.type.hint, enable.xml, enable.xml.type.hint, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigApacheSlingGetServletWithHttpInfo = function(json.maximumresults=NULL, json.maximumresults.type.hint=NULL, enable.html=NULL, enable.html.type.hint=NULL, enable.txt=NULL, enable.txt.type.hint=NULL, enable.xml=NULL, enable.xml.type.hint=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['json.maximumresults'] <- json.maximumresults

      queryParams['json.maximumresults@TypeHint'] <- json.maximumresults.type.hint

      queryParams['enable.html'] <- enable.html

      queryParams['enable.html@TypeHint'] <- enable.html.type.hint

      queryParams['enable.txt'] <- enable.txt

      queryParams['enable.txt@TypeHint'] <- enable.txt.type.hint

      queryParams['enable.xml'] <- enable.xml

      queryParams['enable.xml@TypeHint'] <- enable.xml.type.hint

      body <- NULL
      urlPath <- "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigApacheSlingReferrerFilter = function(allow.empty=NULL, allow.empty.type.hint=NULL, allow.hosts=NULL, allow.hosts.type.hint=NULL, allow.hosts.regexp=NULL, allow.hosts.regexp.type.hint=NULL, filter.methods=NULL, filter.methods.type.hint=NULL, ...){
      apiResponse <- self$PostConfigApacheSlingReferrerFilterWithHttpInfo(allow.empty, allow.empty.type.hint, allow.hosts, allow.hosts.type.hint, allow.hosts.regexp, allow.hosts.regexp.type.hint, filter.methods, filter.methods.type.hint, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigApacheSlingReferrerFilterWithHttpInfo = function(allow.empty=NULL, allow.empty.type.hint=NULL, allow.hosts=NULL, allow.hosts.type.hint=NULL, allow.hosts.regexp=NULL, allow.hosts.regexp.type.hint=NULL, filter.methods=NULL, filter.methods.type.hint=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['allow.empty'] <- allow.empty

      queryParams['allow.empty@TypeHint'] <- allow.empty.type.hint

      queryParams['allow.hosts'] <- allow.hosts

      queryParams['allow.hosts@TypeHint'] <- allow.hosts.type.hint

      queryParams['allow.hosts.regexp'] <- allow.hosts.regexp

      queryParams['allow.hosts.regexp@TypeHint'] <- allow.hosts.regexp.type.hint

      queryParams['filter.methods'] <- filter.methods

      queryParams['filter.methods@TypeHint'] <- filter.methods.type.hint

      body <- NULL
      urlPath <- "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostConfigProperty = function(config.node.name, ...){
      apiResponse <- self$PostConfigPropertyWithHttpInfo(config.node.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostConfigPropertyWithHttpInfo = function(config.node.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`config.node.name`)) {
        stop("Missing required parameter `config.node.name`.")
      }

      body <- NULL
      urlPath <- "/apps/system/config/{configNodeName}"
      if (!missing(`config.node.name`)) {
        urlPath <- gsub(paste0("\\{", "configNodeName", "\\}"), URLencode(as.character(`config.node.name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostNode = function(path, name, operation=NULL, delete.authorizable=NULL, file=NULL, ...){
      apiResponse <- self$PostNodeWithHttpInfo(path, name, operation, delete.authorizable, file, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostNodeWithHttpInfo = function(path, name, operation=NULL, delete.authorizable=NULL, file=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      queryParams[':operation'] <- operation

      queryParams['deleteAuthorizable'] <- delete.authorizable

      body <- list(
        "file" = httr::upload_file(file)
      )

      urlPath <- "/{path}/{name}"
      if (!missing(`path`)) {
        urlPath <- gsub(paste0("\\{", "path", "\\}"), URLencode(as.character(`path`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostNodeRw = function(path, name, add.members=NULL, ...){
      apiResponse <- self$PostNodeRwWithHttpInfo(path, name, add.members, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostNodeRwWithHttpInfo = function(path, name, add.members=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      queryParams['addMembers'] <- add.members

      body <- NULL
      urlPath <- "/{path}/{name}.rw.html"
      if (!missing(`path`)) {
        urlPath <- gsub(paste0("\\{", "path", "\\}"), URLencode(as.character(`path`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostPath = function(path, jcrprimary.type, name, ...){
      apiResponse <- self$PostPathWithHttpInfo(path, jcrprimary.type, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostPathWithHttpInfo = function(path, jcrprimary.type, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`jcrprimary.type`)) {
        stop("Missing required parameter `jcrprimary.type`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      queryParams['jcr:primaryType'] <- jcrprimary.type

      queryParams[':name'] <- name

      body <- NULL
      urlPath <- "/{path}/"
      if (!missing(`path`)) {
        urlPath <- gsub(paste0("\\{", "path", "\\}"), URLencode(as.character(`path`), reserved = TRUE), urlPath)
      }

      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostQuery = function(path, p.limit, Var1.property, Var1.property.value, ...){
      apiResponse <- self$PostQueryWithHttpInfo(path, p.limit, Var1.property, Var1.property.value, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostQueryWithHttpInfo = function(path, p.limit, Var1.property, Var1.property.value, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      if (missing(`p.limit`)) {
        stop("Missing required parameter `p.limit`.")
      }

      if (missing(`Var1.property`)) {
        stop("Missing required parameter `Var1.property`.")
      }

      if (missing(`Var1.property.value`)) {
        stop("Missing required parameter `Var1.property.value`.")
      }

      queryParams['path'] <- path

      queryParams['p.limit'] <- p.limit

      queryParams['1_property'] <- Var1.property

      queryParams['1_property.value'] <- Var1.property.value

      body <- NULL
      urlPath <- "/bin/querybuilder.json"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostTreeActivation = function(ignoredeactivated, onlymodified, path, ...){
      apiResponse <- self$PostTreeActivationWithHttpInfo(ignoredeactivated, onlymodified, path, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostTreeActivationWithHttpInfo = function(ignoredeactivated, onlymodified, path, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`ignoredeactivated`)) {
        stop("Missing required parameter `ignoredeactivated`.")
      }

      if (missing(`onlymodified`)) {
        stop("Missing required parameter `onlymodified`.")
      }

      if (missing(`path`)) {
        stop("Missing required parameter `path`.")
      }

      queryParams['ignoredeactivated'] <- ignoredeactivated

      queryParams['onlymodified'] <- onlymodified

      queryParams['path'] <- path

      body <- NULL
      urlPath <- "/etc/replication/treeactivation.html"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostTruststore = function(operation=NULL, new.password=NULL, re.password=NULL, key.store.type=NULL, remove.alias=NULL, certificate=NULL, ...){
      apiResponse <- self$PostTruststoreWithHttpInfo(operation, new.password, re.password, key.store.type, remove.alias, certificate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostTruststoreWithHttpInfo = function(operation=NULL, new.password=NULL, re.password=NULL, key.store.type=NULL, remove.alias=NULL, certificate=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams[':operation'] <- operation

      queryParams['newPassword'] <- new.password

      queryParams['rePassword'] <- re.password

      queryParams['keyStoreType'] <- key.store.type

      queryParams['removeAlias'] <- remove.alias

      body <- list(
        "certificate" = httr::upload_file(certificate)
      )

      urlPath <- "/libs/granite/security/post/truststore"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PostTruststorePKCS12 = function(truststore.p12=NULL, ...){
      apiResponse <- self$PostTruststorePKCS12WithHttpInfo(truststore.p12, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PostTruststorePKCS12WithHttpInfo = function(truststore.p12=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- list(
        "truststore.p12" = httr::upload_file(truststore.p12)
      )

      urlPath <- "/etc/truststore"
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
