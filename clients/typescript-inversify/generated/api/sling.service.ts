/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs/Observable';

import { map } from 'rxjs/operators';
import IHttpClient from '../IHttpClient';
import { inject, injectable } from 'inversify';
import { IAPIConfiguration } from '../IAPIConfiguration';
import { Headers } from '../Headers';
import HttpResponse from '../HttpResponse';

import { KeystoreInfo } from '../model/keystoreInfo';
import { TruststoreInfo } from '../model/truststoreInfo';

import { COLLECTION_FORMATS }  from '../variables';



@injectable()
export class SlingService {
    private basePath: string = 'http://localhost';

    constructor(@inject('IApiHttpClient') private httpClient: IHttpClient,
        @inject('IAPIConfiguration') private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * 
     * 
     * @param runmode 
     * @param name 
     
     */
    public deleteAgent(runmode: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public deleteAgent(runmode: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public deleteAgent(runmode: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (runmode === null || runmode === undefined){
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     
     */
    public deleteNode(path: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public deleteNode(path: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public deleteNode(path: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.delete(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param runmode 
     * @param name 
     
     */
    public getAgent(runmode: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public getAgent(runmode: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public getAgent(runmode: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (runmode === null || runmode === undefined){
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.get(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param runmode 
     
     */
    public getAgents(runmode: string, observe?: 'body', headers?: Headers): Observable<string>;
    public getAgents(runmode: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public getAgents(runmode: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (runmode === null || runmode === undefined){
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.get(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}.-1.json`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', headers?: Headers): Observable<KeystoreInfo>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<KeystoreInfo>>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined){
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        if (authorizableId === null || authorizableId === undefined){
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        const response: Observable<HttpResponse<KeystoreInfo>> = this.httpClient.get(`${this.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.json`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <KeystoreInfo>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     
     */
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', headers?: Headers): Observable<Blob>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Blob>>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined){
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        if (authorizableId === null || authorizableId === undefined){
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/octet-stream';

        const response: Observable<HttpResponse<Blob>> = this.httpClient.get(`${this.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}/keystore/store.p12`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Blob>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     
     */
    public getNode(path: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public getNode(path: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public getNode(path: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.get(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param group 
     * @param name 
     * @param version 
     
     */
    public getPackage(group: string, name: string, version: string, observe?: 'body', headers?: Headers): Observable<Blob>;
    public getPackage(group: string, name: string, version: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Blob>>;
    public getPackage(group: string, name: string, version: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (group === null || group === undefined){
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        if (version === null || version === undefined){
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/octet-stream';

        const response: Observable<HttpResponse<Blob>> = this.httpClient.get(`${this.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Blob>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param group 
     * @param name 
     * @param version 
     
     */
    public getPackageFilter(group: string, name: string, version: string, observe?: 'body', headers?: Headers): Observable<string>;
    public getPackageFilter(group: string, name: string, version: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public getPackageFilter(group: string, name: string, version: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (group === null || group === undefined){
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        if (version === null || version === undefined){
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.get(`${this.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip/jcr:content/vlt:definition/filter.tidy.2.json`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', headers?: Headers): Observable<string>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        if (pLimit === null || pLimit === undefined){
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        if (_1property === null || _1property === undefined){
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        if (_1propertyValue === null || _1propertyValue === undefined){
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        let queryParameters: string[] = [];
        if (path !== undefined) {
            queryParameters.push('path='+encodeURIComponent(String(path)));
        }
        if (pLimit !== undefined) {
            queryParameters.push('pLimit='+encodeURIComponent(String(pLimit)));
        }
        if (_1property !== undefined) {
            queryParameters.push('_1property='+encodeURIComponent(String(_1property)));
        }
        if (_1propertyValue !== undefined) {
            queryParameters.push('_1propertyValue='+encodeURIComponent(String(_1propertyValue)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.get(`${this.basePath}/bin/querybuilder.json?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     
     */
    public getTruststore(observe?: 'body', headers?: Headers): Observable<Blob>;
    public getTruststore(observe?: 'response', headers?: Headers): Observable<HttpResponse<Blob>>;
    public getTruststore(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/octet-stream';

        const response: Observable<HttpResponse<Blob>> = this.httpClient.get(`${this.basePath}/etc/truststore/truststore.p12`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Blob>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     
     */
    public getTruststoreInfo(observe?: 'body', headers?: Headers): Observable<TruststoreInfo>;
    public getTruststoreInfo(observe?: 'response', headers?: Headers): Observable<HttpResponse<TruststoreInfo>>;
    public getTruststoreInfo(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<TruststoreInfo>> = this.httpClient.get(`${this.basePath}/libs/granite/security/truststore.json`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <TruststoreInfo>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param runmode 
     * @param name 
     * @param jcrcontentCqdistribute 
     * @param jcrcontentCqdistributeTypeHint 
     * @param jcrcontentCqname 
     * @param jcrcontentCqtemplate 
     * @param jcrcontentEnabled 
     * @param jcrcontentJcrdescription 
     * @param jcrcontentJcrlastModified 
     * @param jcrcontentJcrlastModifiedBy 
     * @param jcrcontentJcrmixinTypes 
     * @param jcrcontentJcrtitle 
     * @param jcrcontentLogLevel 
     * @param jcrcontentNoStatusUpdate 
     * @param jcrcontentNoVersioning 
     * @param jcrcontentProtocolConnectTimeout 
     * @param jcrcontentProtocolHTTPConnectionClosed 
     * @param jcrcontentProtocolHTTPExpired 
     * @param jcrcontentProtocolHTTPHeaders 
     * @param jcrcontentProtocolHTTPHeadersTypeHint 
     * @param jcrcontentProtocolHTTPMethod 
     * @param jcrcontentProtocolHTTPSRelaxed 
     * @param jcrcontentProtocolInterface 
     * @param jcrcontentProtocolSocketTimeout 
     * @param jcrcontentProtocolVersion 
     * @param jcrcontentProxyNTLMDomain 
     * @param jcrcontentProxyNTLMHost 
     * @param jcrcontentProxyHost 
     * @param jcrcontentProxyPassword 
     * @param jcrcontentProxyPort 
     * @param jcrcontentProxyUser 
     * @param jcrcontentQueueBatchMaxSize 
     * @param jcrcontentQueueBatchMode 
     * @param jcrcontentQueueBatchWaitTime 
     * @param jcrcontentRetryDelay 
     * @param jcrcontentReverseReplication 
     * @param jcrcontentSerializationType 
     * @param jcrcontentSlingresourceType 
     * @param jcrcontentSsl 
     * @param jcrcontentTransportNTLMDomain 
     * @param jcrcontentTransportNTLMHost 
     * @param jcrcontentTransportPassword 
     * @param jcrcontentTransportUri 
     * @param jcrcontentTransportUser 
     * @param jcrcontentTriggerDistribute 
     * @param jcrcontentTriggerModified 
     * @param jcrcontentTriggerOnOffTime 
     * @param jcrcontentTriggerReceive 
     * @param jcrcontentTriggerSpecific 
     * @param jcrcontentUserId 
     * @param jcrprimaryType 
     * @param operation 
     
     */
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (runmode === null || runmode === undefined){
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        let queryParameters: string[] = [];
        if (jcrcontentCqdistribute !== undefined) {
            queryParameters.push('jcrcontentCqdistribute='+encodeURIComponent(String(jcrcontentCqdistribute)));
        }
        if (jcrcontentCqdistributeTypeHint !== undefined) {
            queryParameters.push('jcrcontentCqdistributeTypeHint='+encodeURIComponent(String(jcrcontentCqdistributeTypeHint)));
        }
        if (jcrcontentCqname !== undefined) {
            queryParameters.push('jcrcontentCqname='+encodeURIComponent(String(jcrcontentCqname)));
        }
        if (jcrcontentCqtemplate !== undefined) {
            queryParameters.push('jcrcontentCqtemplate='+encodeURIComponent(String(jcrcontentCqtemplate)));
        }
        if (jcrcontentEnabled !== undefined) {
            queryParameters.push('jcrcontentEnabled='+encodeURIComponent(String(jcrcontentEnabled)));
        }
        if (jcrcontentJcrdescription !== undefined) {
            queryParameters.push('jcrcontentJcrdescription='+encodeURIComponent(String(jcrcontentJcrdescription)));
        }
        if (jcrcontentJcrlastModified !== undefined) {
            queryParameters.push('jcrcontentJcrlastModified='+encodeURIComponent(String(jcrcontentJcrlastModified)));
        }
        if (jcrcontentJcrlastModifiedBy !== undefined) {
            queryParameters.push('jcrcontentJcrlastModifiedBy='+encodeURIComponent(String(jcrcontentJcrlastModifiedBy)));
        }
        if (jcrcontentJcrmixinTypes !== undefined) {
            queryParameters.push('jcrcontentJcrmixinTypes='+encodeURIComponent(String(jcrcontentJcrmixinTypes)));
        }
        if (jcrcontentJcrtitle !== undefined) {
            queryParameters.push('jcrcontentJcrtitle='+encodeURIComponent(String(jcrcontentJcrtitle)));
        }
        if (jcrcontentLogLevel !== undefined) {
            queryParameters.push('jcrcontentLogLevel='+encodeURIComponent(String(jcrcontentLogLevel)));
        }
        if (jcrcontentNoStatusUpdate !== undefined) {
            queryParameters.push('jcrcontentNoStatusUpdate='+encodeURIComponent(String(jcrcontentNoStatusUpdate)));
        }
        if (jcrcontentNoVersioning !== undefined) {
            queryParameters.push('jcrcontentNoVersioning='+encodeURIComponent(String(jcrcontentNoVersioning)));
        }
        if (jcrcontentProtocolConnectTimeout !== undefined) {
            queryParameters.push('jcrcontentProtocolConnectTimeout='+encodeURIComponent(String(jcrcontentProtocolConnectTimeout)));
        }
        if (jcrcontentProtocolHTTPConnectionClosed !== undefined) {
            queryParameters.push('jcrcontentProtocolHTTPConnectionClosed='+encodeURIComponent(String(jcrcontentProtocolHTTPConnectionClosed)));
        }
        if (jcrcontentProtocolHTTPExpired !== undefined) {
            queryParameters.push('jcrcontentProtocolHTTPExpired='+encodeURIComponent(String(jcrcontentProtocolHTTPExpired)));
        }
        if (jcrcontentProtocolHTTPHeaders) {
            jcrcontentProtocolHTTPHeaders.forEach((element) => {
                queryParameters.push('jcrcontentProtocolHTTPHeaders='+encodeURIComponent(String(element)));
            })
        }
        if (jcrcontentProtocolHTTPHeadersTypeHint !== undefined) {
            queryParameters.push('jcrcontentProtocolHTTPHeadersTypeHint='+encodeURIComponent(String(jcrcontentProtocolHTTPHeadersTypeHint)));
        }
        if (jcrcontentProtocolHTTPMethod !== undefined) {
            queryParameters.push('jcrcontentProtocolHTTPMethod='+encodeURIComponent(String(jcrcontentProtocolHTTPMethod)));
        }
        if (jcrcontentProtocolHTTPSRelaxed !== undefined) {
            queryParameters.push('jcrcontentProtocolHTTPSRelaxed='+encodeURIComponent(String(jcrcontentProtocolHTTPSRelaxed)));
        }
        if (jcrcontentProtocolInterface !== undefined) {
            queryParameters.push('jcrcontentProtocolInterface='+encodeURIComponent(String(jcrcontentProtocolInterface)));
        }
        if (jcrcontentProtocolSocketTimeout !== undefined) {
            queryParameters.push('jcrcontentProtocolSocketTimeout='+encodeURIComponent(String(jcrcontentProtocolSocketTimeout)));
        }
        if (jcrcontentProtocolVersion !== undefined) {
            queryParameters.push('jcrcontentProtocolVersion='+encodeURIComponent(String(jcrcontentProtocolVersion)));
        }
        if (jcrcontentProxyNTLMDomain !== undefined) {
            queryParameters.push('jcrcontentProxyNTLMDomain='+encodeURIComponent(String(jcrcontentProxyNTLMDomain)));
        }
        if (jcrcontentProxyNTLMHost !== undefined) {
            queryParameters.push('jcrcontentProxyNTLMHost='+encodeURIComponent(String(jcrcontentProxyNTLMHost)));
        }
        if (jcrcontentProxyHost !== undefined) {
            queryParameters.push('jcrcontentProxyHost='+encodeURIComponent(String(jcrcontentProxyHost)));
        }
        if (jcrcontentProxyPassword !== undefined) {
            queryParameters.push('jcrcontentProxyPassword='+encodeURIComponent(String(jcrcontentProxyPassword)));
        }
        if (jcrcontentProxyPort !== undefined) {
            queryParameters.push('jcrcontentProxyPort='+encodeURIComponent(String(jcrcontentProxyPort)));
        }
        if (jcrcontentProxyUser !== undefined) {
            queryParameters.push('jcrcontentProxyUser='+encodeURIComponent(String(jcrcontentProxyUser)));
        }
        if (jcrcontentQueueBatchMaxSize !== undefined) {
            queryParameters.push('jcrcontentQueueBatchMaxSize='+encodeURIComponent(String(jcrcontentQueueBatchMaxSize)));
        }
        if (jcrcontentQueueBatchMode !== undefined) {
            queryParameters.push('jcrcontentQueueBatchMode='+encodeURIComponent(String(jcrcontentQueueBatchMode)));
        }
        if (jcrcontentQueueBatchWaitTime !== undefined) {
            queryParameters.push('jcrcontentQueueBatchWaitTime='+encodeURIComponent(String(jcrcontentQueueBatchWaitTime)));
        }
        if (jcrcontentRetryDelay !== undefined) {
            queryParameters.push('jcrcontentRetryDelay='+encodeURIComponent(String(jcrcontentRetryDelay)));
        }
        if (jcrcontentReverseReplication !== undefined) {
            queryParameters.push('jcrcontentReverseReplication='+encodeURIComponent(String(jcrcontentReverseReplication)));
        }
        if (jcrcontentSerializationType !== undefined) {
            queryParameters.push('jcrcontentSerializationType='+encodeURIComponent(String(jcrcontentSerializationType)));
        }
        if (jcrcontentSlingresourceType !== undefined) {
            queryParameters.push('jcrcontentSlingresourceType='+encodeURIComponent(String(jcrcontentSlingresourceType)));
        }
        if (jcrcontentSsl !== undefined) {
            queryParameters.push('jcrcontentSsl='+encodeURIComponent(String(jcrcontentSsl)));
        }
        if (jcrcontentTransportNTLMDomain !== undefined) {
            queryParameters.push('jcrcontentTransportNTLMDomain='+encodeURIComponent(String(jcrcontentTransportNTLMDomain)));
        }
        if (jcrcontentTransportNTLMHost !== undefined) {
            queryParameters.push('jcrcontentTransportNTLMHost='+encodeURIComponent(String(jcrcontentTransportNTLMHost)));
        }
        if (jcrcontentTransportPassword !== undefined) {
            queryParameters.push('jcrcontentTransportPassword='+encodeURIComponent(String(jcrcontentTransportPassword)));
        }
        if (jcrcontentTransportUri !== undefined) {
            queryParameters.push('jcrcontentTransportUri='+encodeURIComponent(String(jcrcontentTransportUri)));
        }
        if (jcrcontentTransportUser !== undefined) {
            queryParameters.push('jcrcontentTransportUser='+encodeURIComponent(String(jcrcontentTransportUser)));
        }
        if (jcrcontentTriggerDistribute !== undefined) {
            queryParameters.push('jcrcontentTriggerDistribute='+encodeURIComponent(String(jcrcontentTriggerDistribute)));
        }
        if (jcrcontentTriggerModified !== undefined) {
            queryParameters.push('jcrcontentTriggerModified='+encodeURIComponent(String(jcrcontentTriggerModified)));
        }
        if (jcrcontentTriggerOnOffTime !== undefined) {
            queryParameters.push('jcrcontentTriggerOnOffTime='+encodeURIComponent(String(jcrcontentTriggerOnOffTime)));
        }
        if (jcrcontentTriggerReceive !== undefined) {
            queryParameters.push('jcrcontentTriggerReceive='+encodeURIComponent(String(jcrcontentTriggerReceive)));
        }
        if (jcrcontentTriggerSpecific !== undefined) {
            queryParameters.push('jcrcontentTriggerSpecific='+encodeURIComponent(String(jcrcontentTriggerSpecific)));
        }
        if (jcrcontentUserId !== undefined) {
            queryParameters.push('jcrcontentUserId='+encodeURIComponent(String(jcrcontentUserId)));
        }
        if (jcrprimaryType !== undefined) {
            queryParameters.push('jcrprimaryType='+encodeURIComponent(String(jcrprimaryType)));
        }
        if (operation !== undefined) {
            queryParameters.push('operation='+encodeURIComponent(String(operation)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'body', headers?: Headers): Observable<KeystoreInfo>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<KeystoreInfo>>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined){
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        if (authorizableId === null || authorizableId === undefined){
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        let queryParameters: string[] = [];
        if (operation !== undefined) {
            queryParameters.push('operation='+encodeURIComponent(String(operation)));
        }
        if (currentPassword !== undefined) {
            queryParameters.push('currentPassword='+encodeURIComponent(String(currentPassword)));
        }
        if (newPassword !== undefined) {
            queryParameters.push('newPassword='+encodeURIComponent(String(newPassword)));
        }
        if (rePassword !== undefined) {
            queryParameters.push('rePassword='+encodeURIComponent(String(rePassword)));
        }
        if (keyPassword !== undefined) {
            queryParameters.push('keyPassword='+encodeURIComponent(String(keyPassword)));
        }
        if (keyStorePass !== undefined) {
            queryParameters.push('keyStorePass='+encodeURIComponent(String(keyStorePass)));
        }
        if (alias !== undefined) {
            queryParameters.push('alias='+encodeURIComponent(String(alias)));
        }
        if (newAlias !== undefined) {
            queryParameters.push('newAlias='+encodeURIComponent(String(newAlias)));
        }
        if (removeAlias !== undefined) {
            queryParameters.push('removeAlias='+encodeURIComponent(String(removeAlias)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'multipart/form-data';
        if (certChain !== undefined) {
            formData.append('cert-chain', <any>certChain);
        }
        if (pk !== undefined) {
            formData.append('pk', <any>pk);
        }
        if (keyStore !== undefined) {
            formData.append('keyStore', <any>keyStore);
        }

        const response: Observable<HttpResponse<KeystoreInfo>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.html?${queryParameters.join('&')}`, formData, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <KeystoreInfo>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param reppassword 
     * @param profileGivenName 
     
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe?: 'body', headers?: Headers): Observable<string>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (authorizableId === null || authorizableId === undefined){
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        if (intermediatePath === null || intermediatePath === undefined){
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        let queryParameters: string[] = [];
        if (authorizableId !== undefined) {
            queryParameters.push('authorizableId='+encodeURIComponent(String(authorizableId)));
        }
        if (intermediatePath !== undefined) {
            queryParameters.push('intermediatePath='+encodeURIComponent(String(intermediatePath)));
        }
        if (createUser !== undefined) {
            queryParameters.push('createUser='+encodeURIComponent(String(createUser)));
        }
        if (createGroup !== undefined) {
            queryParameters.push('createGroup='+encodeURIComponent(String(createGroup)));
        }
        if (reppassword !== undefined) {
            queryParameters.push('reppassword='+encodeURIComponent(String(reppassword)));
        }
        if (profileGivenName !== undefined) {
            queryParameters.push('profileGivenName='+encodeURIComponent(String(profileGivenName)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/html';

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/libs/granite/security/post/authorizables?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param keyStorePassword 
     * @param keyStorePasswordTypeHint 
     * @param serviceRanking 
     * @param serviceRankingTypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirectTypeHint 
     * @param createUser 
     * @param createUserTypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrlTypeHint 
     * @param userIDAttribute 
     * @param userIDAttributeTypeHint 
     * @param defaultGroups 
     * @param defaultGroupsTypeHint 
     * @param idpCertAlias 
     * @param idpCertAliasTypeHint 
     * @param addGroupMemberships 
     * @param addGroupMembershipsTypeHint 
     * @param path 
     * @param pathTypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributesTypeHint 
     * @param clockTolerance 
     * @param clockToleranceTypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttributeTypeHint 
     * @param idpUrl 
     * @param idpUrlTypeHint 
     * @param logoutUrl 
     * @param logoutUrlTypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityIdTypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURLTypeHint 
     * @param handleLogout 
     * @param handleLogoutTypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAliasTypeHint 
     * @param useEncryption 
     * @param useEncryptionTypeHint 
     * @param nameIdFormat 
     * @param nameIdFormatTypeHint 
     * @param digestMethod 
     * @param digestMethodTypeHint 
     * @param signatureMethod 
     * @param signatureMethodTypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePathTypeHint 
     
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (keyStorePassword !== undefined) {
            queryParameters.push('keyStorePassword='+encodeURIComponent(String(keyStorePassword)));
        }
        if (keyStorePasswordTypeHint !== undefined) {
            queryParameters.push('keyStorePasswordTypeHint='+encodeURIComponent(String(keyStorePasswordTypeHint)));
        }
        if (serviceRanking !== undefined) {
            queryParameters.push('serviceRanking='+encodeURIComponent(String(serviceRanking)));
        }
        if (serviceRankingTypeHint !== undefined) {
            queryParameters.push('serviceRankingTypeHint='+encodeURIComponent(String(serviceRankingTypeHint)));
        }
        if (idpHttpRedirect !== undefined) {
            queryParameters.push('idpHttpRedirect='+encodeURIComponent(String(idpHttpRedirect)));
        }
        if (idpHttpRedirectTypeHint !== undefined) {
            queryParameters.push('idpHttpRedirectTypeHint='+encodeURIComponent(String(idpHttpRedirectTypeHint)));
        }
        if (createUser !== undefined) {
            queryParameters.push('createUser='+encodeURIComponent(String(createUser)));
        }
        if (createUserTypeHint !== undefined) {
            queryParameters.push('createUserTypeHint='+encodeURIComponent(String(createUserTypeHint)));
        }
        if (defaultRedirectUrl !== undefined) {
            queryParameters.push('defaultRedirectUrl='+encodeURIComponent(String(defaultRedirectUrl)));
        }
        if (defaultRedirectUrlTypeHint !== undefined) {
            queryParameters.push('defaultRedirectUrlTypeHint='+encodeURIComponent(String(defaultRedirectUrlTypeHint)));
        }
        if (userIDAttribute !== undefined) {
            queryParameters.push('userIDAttribute='+encodeURIComponent(String(userIDAttribute)));
        }
        if (userIDAttributeTypeHint !== undefined) {
            queryParameters.push('userIDAttributeTypeHint='+encodeURIComponent(String(userIDAttributeTypeHint)));
        }
        if (defaultGroups) {
            defaultGroups.forEach((element) => {
                queryParameters.push('defaultGroups='+encodeURIComponent(String(element)));
            })
        }
        if (defaultGroupsTypeHint !== undefined) {
            queryParameters.push('defaultGroupsTypeHint='+encodeURIComponent(String(defaultGroupsTypeHint)));
        }
        if (idpCertAlias !== undefined) {
            queryParameters.push('idpCertAlias='+encodeURIComponent(String(idpCertAlias)));
        }
        if (idpCertAliasTypeHint !== undefined) {
            queryParameters.push('idpCertAliasTypeHint='+encodeURIComponent(String(idpCertAliasTypeHint)));
        }
        if (addGroupMemberships !== undefined) {
            queryParameters.push('addGroupMemberships='+encodeURIComponent(String(addGroupMemberships)));
        }
        if (addGroupMembershipsTypeHint !== undefined) {
            queryParameters.push('addGroupMembershipsTypeHint='+encodeURIComponent(String(addGroupMembershipsTypeHint)));
        }
        if (path) {
            path.forEach((element) => {
                queryParameters.push('path='+encodeURIComponent(String(element)));
            })
        }
        if (pathTypeHint !== undefined) {
            queryParameters.push('pathTypeHint='+encodeURIComponent(String(pathTypeHint)));
        }
        if (synchronizeAttributes) {
            synchronizeAttributes.forEach((element) => {
                queryParameters.push('synchronizeAttributes='+encodeURIComponent(String(element)));
            })
        }
        if (synchronizeAttributesTypeHint !== undefined) {
            queryParameters.push('synchronizeAttributesTypeHint='+encodeURIComponent(String(synchronizeAttributesTypeHint)));
        }
        if (clockTolerance !== undefined) {
            queryParameters.push('clockTolerance='+encodeURIComponent(String(clockTolerance)));
        }
        if (clockToleranceTypeHint !== undefined) {
            queryParameters.push('clockToleranceTypeHint='+encodeURIComponent(String(clockToleranceTypeHint)));
        }
        if (groupMembershipAttribute !== undefined) {
            queryParameters.push('groupMembershipAttribute='+encodeURIComponent(String(groupMembershipAttribute)));
        }
        if (groupMembershipAttributeTypeHint !== undefined) {
            queryParameters.push('groupMembershipAttributeTypeHint='+encodeURIComponent(String(groupMembershipAttributeTypeHint)));
        }
        if (idpUrl !== undefined) {
            queryParameters.push('idpUrl='+encodeURIComponent(String(idpUrl)));
        }
        if (idpUrlTypeHint !== undefined) {
            queryParameters.push('idpUrlTypeHint='+encodeURIComponent(String(idpUrlTypeHint)));
        }
        if (logoutUrl !== undefined) {
            queryParameters.push('logoutUrl='+encodeURIComponent(String(logoutUrl)));
        }
        if (logoutUrlTypeHint !== undefined) {
            queryParameters.push('logoutUrlTypeHint='+encodeURIComponent(String(logoutUrlTypeHint)));
        }
        if (serviceProviderEntityId !== undefined) {
            queryParameters.push('serviceProviderEntityId='+encodeURIComponent(String(serviceProviderEntityId)));
        }
        if (serviceProviderEntityIdTypeHint !== undefined) {
            queryParameters.push('serviceProviderEntityIdTypeHint='+encodeURIComponent(String(serviceProviderEntityIdTypeHint)));
        }
        if (assertionConsumerServiceURL !== undefined) {
            queryParameters.push('assertionConsumerServiceURL='+encodeURIComponent(String(assertionConsumerServiceURL)));
        }
        if (assertionConsumerServiceURLTypeHint !== undefined) {
            queryParameters.push('assertionConsumerServiceURLTypeHint='+encodeURIComponent(String(assertionConsumerServiceURLTypeHint)));
        }
        if (handleLogout !== undefined) {
            queryParameters.push('handleLogout='+encodeURIComponent(String(handleLogout)));
        }
        if (handleLogoutTypeHint !== undefined) {
            queryParameters.push('handleLogoutTypeHint='+encodeURIComponent(String(handleLogoutTypeHint)));
        }
        if (spPrivateKeyAlias !== undefined) {
            queryParameters.push('spPrivateKeyAlias='+encodeURIComponent(String(spPrivateKeyAlias)));
        }
        if (spPrivateKeyAliasTypeHint !== undefined) {
            queryParameters.push('spPrivateKeyAliasTypeHint='+encodeURIComponent(String(spPrivateKeyAliasTypeHint)));
        }
        if (useEncryption !== undefined) {
            queryParameters.push('useEncryption='+encodeURIComponent(String(useEncryption)));
        }
        if (useEncryptionTypeHint !== undefined) {
            queryParameters.push('useEncryptionTypeHint='+encodeURIComponent(String(useEncryptionTypeHint)));
        }
        if (nameIdFormat !== undefined) {
            queryParameters.push('nameIdFormat='+encodeURIComponent(String(nameIdFormat)));
        }
        if (nameIdFormatTypeHint !== undefined) {
            queryParameters.push('nameIdFormatTypeHint='+encodeURIComponent(String(nameIdFormatTypeHint)));
        }
        if (digestMethod !== undefined) {
            queryParameters.push('digestMethod='+encodeURIComponent(String(digestMethod)));
        }
        if (digestMethodTypeHint !== undefined) {
            queryParameters.push('digestMethodTypeHint='+encodeURIComponent(String(digestMethodTypeHint)));
        }
        if (signatureMethod !== undefined) {
            queryParameters.push('signatureMethod='+encodeURIComponent(String(signatureMethod)));
        }
        if (signatureMethodTypeHint !== undefined) {
            queryParameters.push('signatureMethodTypeHint='+encodeURIComponent(String(signatureMethodTypeHint)));
        }
        if (userIntermediatePath !== undefined) {
            queryParameters.push('userIntermediatePath='+encodeURIComponent(String(userIntermediatePath)));
        }
        if (userIntermediatePathTypeHint !== undefined) {
            queryParameters.push('userIntermediatePathTypeHint='+encodeURIComponent(String(userIntermediatePathTypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNioTypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystoreTypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePasswordTypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKeyTypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPasswordTypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststoreTypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePasswordTypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificateTypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnableTypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecureTypeHint 
     
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (orgApacheFelixHttpsNio !== undefined) {
            queryParameters.push('orgApacheFelixHttpsNio='+encodeURIComponent(String(orgApacheFelixHttpsNio)));
        }
        if (orgApacheFelixHttpsNioTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsNioTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsNioTypeHint)));
        }
        if (orgApacheFelixHttpsKeystore !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystore='+encodeURIComponent(String(orgApacheFelixHttpsKeystore)));
        }
        if (orgApacheFelixHttpsKeystoreTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystoreTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsKeystoreTypeHint)));
        }
        if (orgApacheFelixHttpsKeystorePassword !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystorePassword='+encodeURIComponent(String(orgApacheFelixHttpsKeystorePassword)));
        }
        if (orgApacheFelixHttpsKeystorePasswordTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystorePasswordTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsKeystorePasswordTypeHint)));
        }
        if (orgApacheFelixHttpsKeystoreKey !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystoreKey='+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKey)));
        }
        if (orgApacheFelixHttpsKeystoreKeyTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystoreKeyTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKeyTypeHint)));
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystoreKeyPassword='+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKeyPassword)));
        }
        if (orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsKeystoreKeyPasswordTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsKeystoreKeyPasswordTypeHint)));
        }
        if (orgApacheFelixHttpsTruststore !== undefined) {
            queryParameters.push('orgApacheFelixHttpsTruststore='+encodeURIComponent(String(orgApacheFelixHttpsTruststore)));
        }
        if (orgApacheFelixHttpsTruststoreTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsTruststoreTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsTruststoreTypeHint)));
        }
        if (orgApacheFelixHttpsTruststorePassword !== undefined) {
            queryParameters.push('orgApacheFelixHttpsTruststorePassword='+encodeURIComponent(String(orgApacheFelixHttpsTruststorePassword)));
        }
        if (orgApacheFelixHttpsTruststorePasswordTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsTruststorePasswordTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsTruststorePasswordTypeHint)));
        }
        if (orgApacheFelixHttpsClientcertificate !== undefined) {
            queryParameters.push('orgApacheFelixHttpsClientcertificate='+encodeURIComponent(String(orgApacheFelixHttpsClientcertificate)));
        }
        if (orgApacheFelixHttpsClientcertificateTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsClientcertificateTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsClientcertificateTypeHint)));
        }
        if (orgApacheFelixHttpsEnable !== undefined) {
            queryParameters.push('orgApacheFelixHttpsEnable='+encodeURIComponent(String(orgApacheFelixHttpsEnable)));
        }
        if (orgApacheFelixHttpsEnableTypeHint !== undefined) {
            queryParameters.push('orgApacheFelixHttpsEnableTypeHint='+encodeURIComponent(String(orgApacheFelixHttpsEnableTypeHint)));
        }
        if (orgOsgiServiceHttpPortSecure !== undefined) {
            queryParameters.push('orgOsgiServiceHttpPortSecure='+encodeURIComponent(String(orgOsgiServiceHttpPortSecure)));
        }
        if (orgOsgiServiceHttpPortSecureTypeHint !== undefined) {
            queryParameters.push('orgOsgiServiceHttpPortSecureTypeHint='+encodeURIComponent(String(orgOsgiServiceHttpPortSecureTypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.felix.http?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param proxyHost 
     * @param proxyHostTypeHint 
     * @param proxyPort 
     * @param proxyPortTypeHint 
     * @param proxyExceptions 
     * @param proxyExceptionsTypeHint 
     * @param proxyEnabled 
     * @param proxyEnabledTypeHint 
     * @param proxyUser 
     * @param proxyUserTypeHint 
     * @param proxyPassword 
     * @param proxyPasswordTypeHint 
     
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (proxyHost !== undefined) {
            queryParameters.push('proxyHost='+encodeURIComponent(String(proxyHost)));
        }
        if (proxyHostTypeHint !== undefined) {
            queryParameters.push('proxyHostTypeHint='+encodeURIComponent(String(proxyHostTypeHint)));
        }
        if (proxyPort !== undefined) {
            queryParameters.push('proxyPort='+encodeURIComponent(String(proxyPort)));
        }
        if (proxyPortTypeHint !== undefined) {
            queryParameters.push('proxyPortTypeHint='+encodeURIComponent(String(proxyPortTypeHint)));
        }
        if (proxyExceptions) {
            proxyExceptions.forEach((element) => {
                queryParameters.push('proxyExceptions='+encodeURIComponent(String(element)));
            })
        }
        if (proxyExceptionsTypeHint !== undefined) {
            queryParameters.push('proxyExceptionsTypeHint='+encodeURIComponent(String(proxyExceptionsTypeHint)));
        }
        if (proxyEnabled !== undefined) {
            queryParameters.push('proxyEnabled='+encodeURIComponent(String(proxyEnabled)));
        }
        if (proxyEnabledTypeHint !== undefined) {
            queryParameters.push('proxyEnabledTypeHint='+encodeURIComponent(String(proxyEnabledTypeHint)));
        }
        if (proxyUser !== undefined) {
            queryParameters.push('proxyUser='+encodeURIComponent(String(proxyUser)));
        }
        if (proxyUserTypeHint !== undefined) {
            queryParameters.push('proxyUserTypeHint='+encodeURIComponent(String(proxyUserTypeHint)));
        }
        if (proxyPassword !== undefined) {
            queryParameters.push('proxyPassword='+encodeURIComponent(String(proxyPassword)));
        }
        if (proxyPasswordTypeHint !== undefined) {
            queryParameters.push('proxyPasswordTypeHint='+encodeURIComponent(String(proxyPasswordTypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.http.proxyconfigurator.config?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param alias 
     * @param aliasTypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUriTypeHint 
     
     */
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (alias !== undefined) {
            queryParameters.push('alias='+encodeURIComponent(String(alias)));
        }
        if (aliasTypeHint !== undefined) {
            queryParameters.push('aliasTypeHint='+encodeURIComponent(String(aliasTypeHint)));
        }
        if (davCreateAbsoluteUri !== undefined) {
            queryParameters.push('davCreateAbsoluteUri='+encodeURIComponent(String(davCreateAbsoluteUri)));
        }
        if (davCreateAbsoluteUriTypeHint !== undefined) {
            queryParameters.push('davCreateAbsoluteUriTypeHint='+encodeURIComponent(String(davCreateAbsoluteUriTypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresultsTypeHint 
     * @param enableHtml 
     * @param enableHtmlTypeHint 
     * @param enableTxt 
     * @param enableTxtTypeHint 
     * @param enableXml 
     * @param enableXmlTypeHint 
     
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (jsonMaximumresults !== undefined) {
            queryParameters.push('jsonMaximumresults='+encodeURIComponent(String(jsonMaximumresults)));
        }
        if (jsonMaximumresultsTypeHint !== undefined) {
            queryParameters.push('jsonMaximumresultsTypeHint='+encodeURIComponent(String(jsonMaximumresultsTypeHint)));
        }
        if (enableHtml !== undefined) {
            queryParameters.push('enableHtml='+encodeURIComponent(String(enableHtml)));
        }
        if (enableHtmlTypeHint !== undefined) {
            queryParameters.push('enableHtmlTypeHint='+encodeURIComponent(String(enableHtmlTypeHint)));
        }
        if (enableTxt !== undefined) {
            queryParameters.push('enableTxt='+encodeURIComponent(String(enableTxt)));
        }
        if (enableTxtTypeHint !== undefined) {
            queryParameters.push('enableTxtTypeHint='+encodeURIComponent(String(enableTxtTypeHint)));
        }
        if (enableXml !== undefined) {
            queryParameters.push('enableXml='+encodeURIComponent(String(enableXml)));
        }
        if (enableXmlTypeHint !== undefined) {
            queryParameters.push('enableXmlTypeHint='+encodeURIComponent(String(enableXmlTypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param allowEmpty 
     * @param allowEmptyTypeHint 
     * @param allowHosts 
     * @param allowHostsTypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexpTypeHint 
     * @param filterMethods 
     * @param filterMethodsTypeHint 
     
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (allowEmpty !== undefined) {
            queryParameters.push('allowEmpty='+encodeURIComponent(String(allowEmpty)));
        }
        if (allowEmptyTypeHint !== undefined) {
            queryParameters.push('allowEmptyTypeHint='+encodeURIComponent(String(allowEmptyTypeHint)));
        }
        if (allowHosts !== undefined) {
            queryParameters.push('allowHosts='+encodeURIComponent(String(allowHosts)));
        }
        if (allowHostsTypeHint !== undefined) {
            queryParameters.push('allowHostsTypeHint='+encodeURIComponent(String(allowHostsTypeHint)));
        }
        if (allowHostsRegexp !== undefined) {
            queryParameters.push('allowHostsRegexp='+encodeURIComponent(String(allowHostsRegexp)));
        }
        if (allowHostsRegexpTypeHint !== undefined) {
            queryParameters.push('allowHostsRegexpTypeHint='+encodeURIComponent(String(allowHostsRegexpTypeHint)));
        }
        if (filterMethods !== undefined) {
            queryParameters.push('filterMethods='+encodeURIComponent(String(filterMethods)));
        }
        if (filterMethodsTypeHint !== undefined) {
            queryParameters.push('filterMethodsTypeHint='+encodeURIComponent(String(filterMethodsTypeHint)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param configNodeName 
     
     */
    public postConfigProperty(configNodeName: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postConfigProperty(configNodeName: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postConfigProperty(configNodeName: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (configNodeName === null || configNodeName === undefined){
            throw new Error('Required parameter configNodeName was null or undefined when calling postConfigProperty.');
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/apps/system/config/${encodeURIComponent(String(configNodeName))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param operation 
     * @param deleteAuthorizable 
     * @param file 
     
     */
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'body', headers?: Headers): Observable<any>;
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        let queryParameters: string[] = [];
        if (operation !== undefined) {
            queryParameters.push('operation='+encodeURIComponent(String(operation)));
        }
        if (deleteAuthorizable !== undefined) {
            queryParameters.push('deleteAuthorizable='+encodeURIComponent(String(deleteAuthorizable)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'multipart/form-data';
        if (file !== undefined) {
            formData.append('file', <any>file);
        }

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}?${queryParameters.join('&')}`, formData, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     
     */
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        let queryParameters: string[] = [];
        if (addMembers !== undefined) {
            queryParameters.push('addMembers='+encodeURIComponent(String(addMembers)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}.rw.html?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param jcrprimaryType 
     * @param name 
     
     */
    public postPath(path: string, jcrprimaryType: string, name: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postPath(path: string, jcrprimaryType: string, name: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postPath(path: string, jcrprimaryType: string, name: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        if (jcrprimaryType === null || jcrprimaryType === undefined){
            throw new Error('Required parameter jcrprimaryType was null or undefined when calling postPath.');
        }

        if (name === null || name === undefined){
            throw new Error('Required parameter name was null or undefined when calling postPath.');
        }

        let queryParameters: string[] = [];
        if (jcrprimaryType !== undefined) {
            queryParameters.push('jcrprimaryType='+encodeURIComponent(String(jcrprimaryType)));
        }
        if (name !== undefined) {
            queryParameters.push('name='+encodeURIComponent(String(name)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/${encodeURIComponent(String(path))}/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', headers?: Headers): Observable<string>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        if (pLimit === null || pLimit === undefined){
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        if (_1property === null || _1property === undefined){
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        if (_1propertyValue === null || _1propertyValue === undefined){
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        let queryParameters: string[] = [];
        if (path !== undefined) {
            queryParameters.push('path='+encodeURIComponent(String(path)));
        }
        if (pLimit !== undefined) {
            queryParameters.push('pLimit='+encodeURIComponent(String(pLimit)));
        }
        if (_1property !== undefined) {
            queryParameters.push('_1property='+encodeURIComponent(String(_1property)));
        }
        if (_1propertyValue !== undefined) {
            queryParameters.push('_1propertyValue='+encodeURIComponent(String(_1propertyValue)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/bin/querybuilder.json?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'body', headers?: Headers): Observable<any>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (ignoredeactivated === null || ignoredeactivated === undefined){
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        if (onlymodified === null || onlymodified === undefined){
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        if (path === null || path === undefined){
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        let queryParameters: string[] = [];
        if (ignoredeactivated !== undefined) {
            queryParameters.push('ignoredeactivated='+encodeURIComponent(String(ignoredeactivated)));
        }
        if (onlymodified !== undefined) {
            queryParameters.push('onlymodified='+encodeURIComponent(String(onlymodified)));
        }
        if (path !== undefined) {
            queryParameters.push('path='+encodeURIComponent(String(path)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/etc/replication/treeactivation.html?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     
     */
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'body', headers?: Headers): Observable<string>;
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (operation !== undefined) {
            queryParameters.push('operation='+encodeURIComponent(String(operation)));
        }
        if (newPassword !== undefined) {
            queryParameters.push('newPassword='+encodeURIComponent(String(newPassword)));
        }
        if (rePassword !== undefined) {
            queryParameters.push('rePassword='+encodeURIComponent(String(rePassword)));
        }
        if (keyStoreType !== undefined) {
            queryParameters.push('keyStoreType='+encodeURIComponent(String(keyStoreType)));
        }
        if (removeAlias !== undefined) {
            queryParameters.push('removeAlias='+encodeURIComponent(String(removeAlias)));
        }

        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'multipart/form-data';
        if (certificate !== undefined) {
            formData.append('certificate', <any>certificate);
        }

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/libs/granite/security/post/truststore?${queryParameters.join('&')}`, formData, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * 
     * @param truststoreP12 
     
     */
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'body', headers?: Headers): Observable<string>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'response', headers?: Headers): Observable<HttpResponse<string>>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (aemAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        headers['Accept'] = 'text/plain';

        let formData: FormData = new FormData();
        headers['Content-Type'] = 'multipart/form-data';
        if (truststoreP12 !== undefined) {
            formData.append('truststore.p12', <any>truststoreP12);
        }

        const response: Observable<HttpResponse<string>> = this.httpClient.post(`${this.basePath}/etc/truststore`, formData, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <string>(httpResponse.response))
               );
        }
        return response;
    }

}
