/*
Adobe Experience Manager (AEM) API

Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API

API version: 3.5.0-pre.0
Contact: opensource@shinesolutions.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// SlingApiService SlingApi service
type SlingApiService service

type ApiDeleteAgentRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	runmode string
	name string
}


func (r ApiDeleteAgentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAgentExecute(r)
}

/*
DeleteAgent Method for DeleteAgent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runmode
 @param name
 @return ApiDeleteAgentRequest
*/
func (a *SlingApiService) DeleteAgent(ctx _context.Context, runmode string, name string) ApiDeleteAgentRequest {
	return ApiDeleteAgentRequest{
		ApiService: a,
		ctx: ctx,
		runmode: runmode,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) DeleteAgentExecute(r ApiDeleteAgentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.DeleteAgent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/replication/agents.{runmode}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", _neturl.PathEscape(parameterToString(r.runmode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNodeRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path string
	name string
}


func (r ApiDeleteNodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteNodeExecute(r)
}

/*
DeleteNode Method for DeleteNode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path
 @param name
 @return ApiDeleteNodeRequest
*/
func (a *SlingApiService) DeleteNode(ctx _context.Context, path string, name string) ApiDeleteNodeRequest {
	return ApiDeleteNodeRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) DeleteNodeExecute(r ApiDeleteNodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.DeleteNode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{path}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAgentRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	runmode string
	name string
}


func (r ApiGetAgentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAgentExecute(r)
}

/*
GetAgent Method for GetAgent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runmode
 @param name
 @return ApiGetAgentRequest
*/
func (a *SlingApiService) GetAgent(ctx _context.Context, runmode string, name string) ApiGetAgentRequest {
	return ApiGetAgentRequest{
		ApiService: a,
		ctx: ctx,
		runmode: runmode,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) GetAgentExecute(r ApiGetAgentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetAgent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/replication/agents.{runmode}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", _neturl.PathEscape(parameterToString(r.runmode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAgentsRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	runmode string
}


func (r ApiGetAgentsRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetAgentsExecute(r)
}

/*
GetAgents Method for GetAgents

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runmode
 @return ApiGetAgentsRequest
*/
func (a *SlingApiService) GetAgents(ctx _context.Context, runmode string) ApiGetAgentsRequest {
	return ApiGetAgentsRequest{
		ApiService: a,
		ctx: ctx,
		runmode: runmode,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) GetAgentsExecute(r ApiGetAgentsRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetAgents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/replication/agents.{runmode}.-1.json"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", _neturl.PathEscape(parameterToString(r.runmode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizableKeystoreRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	intermediatePath string
	authorizableId string
}


func (r ApiGetAuthorizableKeystoreRequest) Execute() (KeystoreInfo, *_nethttp.Response, error) {
	return r.ApiService.GetAuthorizableKeystoreExecute(r)
}

/*
GetAuthorizableKeystore Method for GetAuthorizableKeystore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param intermediatePath
 @param authorizableId
 @return ApiGetAuthorizableKeystoreRequest
*/
func (a *SlingApiService) GetAuthorizableKeystore(ctx _context.Context, intermediatePath string, authorizableId string) ApiGetAuthorizableKeystoreRequest {
	return ApiGetAuthorizableKeystoreRequest{
		ApiService: a,
		ctx: ctx,
		intermediatePath: intermediatePath,
		authorizableId: authorizableId,
	}
}

// Execute executes the request
//  @return KeystoreInfo
func (a *SlingApiService) GetAuthorizableKeystoreExecute(r ApiGetAuthorizableKeystoreRequest) (KeystoreInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KeystoreInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetAuthorizableKeystore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{intermediatePath}/{authorizableId}.ks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"intermediatePath"+"}", _neturl.PathEscape(parameterToString(r.intermediatePath, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizableId"+"}", _neturl.PathEscape(parameterToString(r.authorizableId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKeystoreRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	intermediatePath string
	authorizableId string
}


func (r ApiGetKeystoreRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.GetKeystoreExecute(r)
}

/*
GetKeystore Method for GetKeystore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param intermediatePath
 @param authorizableId
 @return ApiGetKeystoreRequest
*/
func (a *SlingApiService) GetKeystore(ctx _context.Context, intermediatePath string, authorizableId string) ApiGetKeystoreRequest {
	return ApiGetKeystoreRequest{
		ApiService: a,
		ctx: ctx,
		intermediatePath: intermediatePath,
		authorizableId: authorizableId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SlingApiService) GetKeystoreExecute(r ApiGetKeystoreRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetKeystore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{intermediatePath}/{authorizableId}/keystore/store.p12"
	localVarPath = strings.Replace(localVarPath, "{"+"intermediatePath"+"}", _neturl.PathEscape(parameterToString(r.intermediatePath, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizableId"+"}", _neturl.PathEscape(parameterToString(r.authorizableId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path string
	name string
}


func (r ApiGetNodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetNodeExecute(r)
}

/*
GetNode Method for GetNode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path
 @param name
 @return ApiGetNodeRequest
*/
func (a *SlingApiService) GetNode(ctx _context.Context, path string, name string) ApiGetNodeRequest {
	return ApiGetNodeRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) GetNodeExecute(r ApiGetNodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetNode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{path}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPackageRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	group string
	name string
	version string
}


func (r ApiGetPackageRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.GetPackageExecute(r)
}

/*
GetPackage Method for GetPackage

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param group
 @param name
 @param version
 @return ApiGetPackageRequest
*/
func (a *SlingApiService) GetPackage(ctx _context.Context, group string, name string, version string) ApiGetPackageRequest {
	return ApiGetPackageRequest{
		ApiService: a,
		ctx: ctx,
		group: group,
		name: name,
		version: version,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SlingApiService) GetPackageExecute(r ApiGetPackageRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/packages/{group}/{name}-{version}.zip"
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", _neturl.PathEscape(parameterToString(r.group, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPackageFilterRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	group string
	name string
	version string
}


func (r ApiGetPackageFilterRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetPackageFilterExecute(r)
}

/*
GetPackageFilter Method for GetPackageFilter

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param group
 @param name
 @param version
 @return ApiGetPackageFilterRequest
*/
func (a *SlingApiService) GetPackageFilter(ctx _context.Context, group string, name string, version string) ApiGetPackageFilterRequest {
	return ApiGetPackageFilterRequest{
		ApiService: a,
		ctx: ctx,
		group: group,
		name: name,
		version: version,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) GetPackageFilterExecute(r ApiGetPackageFilterRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetPackageFilter")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json"
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", _neturl.PathEscape(parameterToString(r.group, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueryRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path *string
	pLimit *float32
	var1Property *string
	var1PropertyValue *string
}

func (r ApiGetQueryRequest) Path(path string) ApiGetQueryRequest {
	r.path = &path
	return r
}
func (r ApiGetQueryRequest) PLimit(pLimit float32) ApiGetQueryRequest {
	r.pLimit = &pLimit
	return r
}
func (r ApiGetQueryRequest) Var1Property(var1Property string) ApiGetQueryRequest {
	r.var1Property = &var1Property
	return r
}
func (r ApiGetQueryRequest) Var1PropertyValue(var1PropertyValue string) ApiGetQueryRequest {
	r.var1PropertyValue = &var1PropertyValue
	return r
}

func (r ApiGetQueryRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetQueryExecute(r)
}

/*
GetQuery Method for GetQuery

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQueryRequest
*/
func (a *SlingApiService) GetQuery(ctx _context.Context) ApiGetQueryRequest {
	return ApiGetQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) GetQueryExecute(r ApiGetQueryRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetQuery")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bin/querybuilder.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pLimit == nil {
		return localVarReturnValue, nil, reportError("pLimit is required and must be specified")
	}
	if r.var1Property == nil {
		return localVarReturnValue, nil, reportError("var1Property is required and must be specified")
	}
	if r.var1PropertyValue == nil {
		return localVarReturnValue, nil, reportError("var1PropertyValue is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	localVarQueryParams.Add("p.limit", parameterToString(*r.pLimit, ""))
	localVarQueryParams.Add("1_property", parameterToString(*r.var1Property, ""))
	localVarQueryParams.Add("1_property.value", parameterToString(*r.var1PropertyValue, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTruststoreRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
}


func (r ApiGetTruststoreRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.GetTruststoreExecute(r)
}

/*
GetTruststore Method for GetTruststore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTruststoreRequest
*/
func (a *SlingApiService) GetTruststore(ctx _context.Context) ApiGetTruststoreRequest {
	return ApiGetTruststoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SlingApiService) GetTruststoreExecute(r ApiGetTruststoreRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetTruststore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/truststore/truststore.p12"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTruststoreInfoRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
}


func (r ApiGetTruststoreInfoRequest) Execute() (TruststoreInfo, *_nethttp.Response, error) {
	return r.ApiService.GetTruststoreInfoExecute(r)
}

/*
GetTruststoreInfo Method for GetTruststoreInfo

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTruststoreInfoRequest
*/
func (a *SlingApiService) GetTruststoreInfo(ctx _context.Context) ApiGetTruststoreInfoRequest {
	return ApiGetTruststoreInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TruststoreInfo
func (a *SlingApiService) GetTruststoreInfoExecute(r ApiGetTruststoreInfoRequest) (TruststoreInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TruststoreInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.GetTruststoreInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/libs/granite/security/truststore.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAgentRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	runmode string
	name string
	jcrcontentCqdistribute *bool
	jcrcontentCqdistributeTypeHint *string
	jcrcontentCqname *string
	jcrcontentCqtemplate *string
	jcrcontentEnabled *bool
	jcrcontentJcrdescription *string
	jcrcontentJcrlastModified *string
	jcrcontentJcrlastModifiedBy *string
	jcrcontentJcrmixinTypes *string
	jcrcontentJcrtitle *string
	jcrcontentLogLevel *string
	jcrcontentNoStatusUpdate *bool
	jcrcontentNoVersioning *bool
	jcrcontentProtocolConnectTimeout *float32
	jcrcontentProtocolHTTPConnectionClosed *bool
	jcrcontentProtocolHTTPExpired *string
	jcrcontentProtocolHTTPHeaders *[]string
	jcrcontentProtocolHTTPHeadersTypeHint *string
	jcrcontentProtocolHTTPMethod *string
	jcrcontentProtocolHTTPSRelaxed *bool
	jcrcontentProtocolInterface *string
	jcrcontentProtocolSocketTimeout *float32
	jcrcontentProtocolVersion *string
	jcrcontentProxyNTLMDomain *string
	jcrcontentProxyNTLMHost *string
	jcrcontentProxyHost *string
	jcrcontentProxyPassword *string
	jcrcontentProxyPort *float32
	jcrcontentProxyUser *string
	jcrcontentQueueBatchMaxSize *float32
	jcrcontentQueueBatchMode *string
	jcrcontentQueueBatchWaitTime *float32
	jcrcontentRetryDelay *string
	jcrcontentReverseReplication *bool
	jcrcontentSerializationType *string
	jcrcontentSlingresourceType *string
	jcrcontentSsl *string
	jcrcontentTransportNTLMDomain *string
	jcrcontentTransportNTLMHost *string
	jcrcontentTransportPassword *string
	jcrcontentTransportUri *string
	jcrcontentTransportUser *string
	jcrcontentTriggerDistribute *bool
	jcrcontentTriggerModified *bool
	jcrcontentTriggerOnOffTime *bool
	jcrcontentTriggerReceive *bool
	jcrcontentTriggerSpecific *bool
	jcrcontentUserId *string
	jcrprimaryType *string
	operation *string
}

func (r ApiPostAgentRequest) JcrcontentCqdistribute(jcrcontentCqdistribute bool) ApiPostAgentRequest {
	r.jcrcontentCqdistribute = &jcrcontentCqdistribute
	return r
}
func (r ApiPostAgentRequest) JcrcontentCqdistributeTypeHint(jcrcontentCqdistributeTypeHint string) ApiPostAgentRequest {
	r.jcrcontentCqdistributeTypeHint = &jcrcontentCqdistributeTypeHint
	return r
}
func (r ApiPostAgentRequest) JcrcontentCqname(jcrcontentCqname string) ApiPostAgentRequest {
	r.jcrcontentCqname = &jcrcontentCqname
	return r
}
func (r ApiPostAgentRequest) JcrcontentCqtemplate(jcrcontentCqtemplate string) ApiPostAgentRequest {
	r.jcrcontentCqtemplate = &jcrcontentCqtemplate
	return r
}
func (r ApiPostAgentRequest) JcrcontentEnabled(jcrcontentEnabled bool) ApiPostAgentRequest {
	r.jcrcontentEnabled = &jcrcontentEnabled
	return r
}
func (r ApiPostAgentRequest) JcrcontentJcrdescription(jcrcontentJcrdescription string) ApiPostAgentRequest {
	r.jcrcontentJcrdescription = &jcrcontentJcrdescription
	return r
}
func (r ApiPostAgentRequest) JcrcontentJcrlastModified(jcrcontentJcrlastModified string) ApiPostAgentRequest {
	r.jcrcontentJcrlastModified = &jcrcontentJcrlastModified
	return r
}
func (r ApiPostAgentRequest) JcrcontentJcrlastModifiedBy(jcrcontentJcrlastModifiedBy string) ApiPostAgentRequest {
	r.jcrcontentJcrlastModifiedBy = &jcrcontentJcrlastModifiedBy
	return r
}
func (r ApiPostAgentRequest) JcrcontentJcrmixinTypes(jcrcontentJcrmixinTypes string) ApiPostAgentRequest {
	r.jcrcontentJcrmixinTypes = &jcrcontentJcrmixinTypes
	return r
}
func (r ApiPostAgentRequest) JcrcontentJcrtitle(jcrcontentJcrtitle string) ApiPostAgentRequest {
	r.jcrcontentJcrtitle = &jcrcontentJcrtitle
	return r
}
func (r ApiPostAgentRequest) JcrcontentLogLevel(jcrcontentLogLevel string) ApiPostAgentRequest {
	r.jcrcontentLogLevel = &jcrcontentLogLevel
	return r
}
func (r ApiPostAgentRequest) JcrcontentNoStatusUpdate(jcrcontentNoStatusUpdate bool) ApiPostAgentRequest {
	r.jcrcontentNoStatusUpdate = &jcrcontentNoStatusUpdate
	return r
}
func (r ApiPostAgentRequest) JcrcontentNoVersioning(jcrcontentNoVersioning bool) ApiPostAgentRequest {
	r.jcrcontentNoVersioning = &jcrcontentNoVersioning
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolConnectTimeout(jcrcontentProtocolConnectTimeout float32) ApiPostAgentRequest {
	r.jcrcontentProtocolConnectTimeout = &jcrcontentProtocolConnectTimeout
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolHTTPConnectionClosed(jcrcontentProtocolHTTPConnectionClosed bool) ApiPostAgentRequest {
	r.jcrcontentProtocolHTTPConnectionClosed = &jcrcontentProtocolHTTPConnectionClosed
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolHTTPExpired(jcrcontentProtocolHTTPExpired string) ApiPostAgentRequest {
	r.jcrcontentProtocolHTTPExpired = &jcrcontentProtocolHTTPExpired
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolHTTPHeaders(jcrcontentProtocolHTTPHeaders []string) ApiPostAgentRequest {
	r.jcrcontentProtocolHTTPHeaders = &jcrcontentProtocolHTTPHeaders
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolHTTPHeadersTypeHint(jcrcontentProtocolHTTPHeadersTypeHint string) ApiPostAgentRequest {
	r.jcrcontentProtocolHTTPHeadersTypeHint = &jcrcontentProtocolHTTPHeadersTypeHint
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolHTTPMethod(jcrcontentProtocolHTTPMethod string) ApiPostAgentRequest {
	r.jcrcontentProtocolHTTPMethod = &jcrcontentProtocolHTTPMethod
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolHTTPSRelaxed(jcrcontentProtocolHTTPSRelaxed bool) ApiPostAgentRequest {
	r.jcrcontentProtocolHTTPSRelaxed = &jcrcontentProtocolHTTPSRelaxed
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolInterface(jcrcontentProtocolInterface string) ApiPostAgentRequest {
	r.jcrcontentProtocolInterface = &jcrcontentProtocolInterface
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolSocketTimeout(jcrcontentProtocolSocketTimeout float32) ApiPostAgentRequest {
	r.jcrcontentProtocolSocketTimeout = &jcrcontentProtocolSocketTimeout
	return r
}
func (r ApiPostAgentRequest) JcrcontentProtocolVersion(jcrcontentProtocolVersion string) ApiPostAgentRequest {
	r.jcrcontentProtocolVersion = &jcrcontentProtocolVersion
	return r
}
func (r ApiPostAgentRequest) JcrcontentProxyNTLMDomain(jcrcontentProxyNTLMDomain string) ApiPostAgentRequest {
	r.jcrcontentProxyNTLMDomain = &jcrcontentProxyNTLMDomain
	return r
}
func (r ApiPostAgentRequest) JcrcontentProxyNTLMHost(jcrcontentProxyNTLMHost string) ApiPostAgentRequest {
	r.jcrcontentProxyNTLMHost = &jcrcontentProxyNTLMHost
	return r
}
func (r ApiPostAgentRequest) JcrcontentProxyHost(jcrcontentProxyHost string) ApiPostAgentRequest {
	r.jcrcontentProxyHost = &jcrcontentProxyHost
	return r
}
func (r ApiPostAgentRequest) JcrcontentProxyPassword(jcrcontentProxyPassword string) ApiPostAgentRequest {
	r.jcrcontentProxyPassword = &jcrcontentProxyPassword
	return r
}
func (r ApiPostAgentRequest) JcrcontentProxyPort(jcrcontentProxyPort float32) ApiPostAgentRequest {
	r.jcrcontentProxyPort = &jcrcontentProxyPort
	return r
}
func (r ApiPostAgentRequest) JcrcontentProxyUser(jcrcontentProxyUser string) ApiPostAgentRequest {
	r.jcrcontentProxyUser = &jcrcontentProxyUser
	return r
}
func (r ApiPostAgentRequest) JcrcontentQueueBatchMaxSize(jcrcontentQueueBatchMaxSize float32) ApiPostAgentRequest {
	r.jcrcontentQueueBatchMaxSize = &jcrcontentQueueBatchMaxSize
	return r
}
func (r ApiPostAgentRequest) JcrcontentQueueBatchMode(jcrcontentQueueBatchMode string) ApiPostAgentRequest {
	r.jcrcontentQueueBatchMode = &jcrcontentQueueBatchMode
	return r
}
func (r ApiPostAgentRequest) JcrcontentQueueBatchWaitTime(jcrcontentQueueBatchWaitTime float32) ApiPostAgentRequest {
	r.jcrcontentQueueBatchWaitTime = &jcrcontentQueueBatchWaitTime
	return r
}
func (r ApiPostAgentRequest) JcrcontentRetryDelay(jcrcontentRetryDelay string) ApiPostAgentRequest {
	r.jcrcontentRetryDelay = &jcrcontentRetryDelay
	return r
}
func (r ApiPostAgentRequest) JcrcontentReverseReplication(jcrcontentReverseReplication bool) ApiPostAgentRequest {
	r.jcrcontentReverseReplication = &jcrcontentReverseReplication
	return r
}
func (r ApiPostAgentRequest) JcrcontentSerializationType(jcrcontentSerializationType string) ApiPostAgentRequest {
	r.jcrcontentSerializationType = &jcrcontentSerializationType
	return r
}
func (r ApiPostAgentRequest) JcrcontentSlingresourceType(jcrcontentSlingresourceType string) ApiPostAgentRequest {
	r.jcrcontentSlingresourceType = &jcrcontentSlingresourceType
	return r
}
func (r ApiPostAgentRequest) JcrcontentSsl(jcrcontentSsl string) ApiPostAgentRequest {
	r.jcrcontentSsl = &jcrcontentSsl
	return r
}
func (r ApiPostAgentRequest) JcrcontentTransportNTLMDomain(jcrcontentTransportNTLMDomain string) ApiPostAgentRequest {
	r.jcrcontentTransportNTLMDomain = &jcrcontentTransportNTLMDomain
	return r
}
func (r ApiPostAgentRequest) JcrcontentTransportNTLMHost(jcrcontentTransportNTLMHost string) ApiPostAgentRequest {
	r.jcrcontentTransportNTLMHost = &jcrcontentTransportNTLMHost
	return r
}
func (r ApiPostAgentRequest) JcrcontentTransportPassword(jcrcontentTransportPassword string) ApiPostAgentRequest {
	r.jcrcontentTransportPassword = &jcrcontentTransportPassword
	return r
}
func (r ApiPostAgentRequest) JcrcontentTransportUri(jcrcontentTransportUri string) ApiPostAgentRequest {
	r.jcrcontentTransportUri = &jcrcontentTransportUri
	return r
}
func (r ApiPostAgentRequest) JcrcontentTransportUser(jcrcontentTransportUser string) ApiPostAgentRequest {
	r.jcrcontentTransportUser = &jcrcontentTransportUser
	return r
}
func (r ApiPostAgentRequest) JcrcontentTriggerDistribute(jcrcontentTriggerDistribute bool) ApiPostAgentRequest {
	r.jcrcontentTriggerDistribute = &jcrcontentTriggerDistribute
	return r
}
func (r ApiPostAgentRequest) JcrcontentTriggerModified(jcrcontentTriggerModified bool) ApiPostAgentRequest {
	r.jcrcontentTriggerModified = &jcrcontentTriggerModified
	return r
}
func (r ApiPostAgentRequest) JcrcontentTriggerOnOffTime(jcrcontentTriggerOnOffTime bool) ApiPostAgentRequest {
	r.jcrcontentTriggerOnOffTime = &jcrcontentTriggerOnOffTime
	return r
}
func (r ApiPostAgentRequest) JcrcontentTriggerReceive(jcrcontentTriggerReceive bool) ApiPostAgentRequest {
	r.jcrcontentTriggerReceive = &jcrcontentTriggerReceive
	return r
}
func (r ApiPostAgentRequest) JcrcontentTriggerSpecific(jcrcontentTriggerSpecific bool) ApiPostAgentRequest {
	r.jcrcontentTriggerSpecific = &jcrcontentTriggerSpecific
	return r
}
func (r ApiPostAgentRequest) JcrcontentUserId(jcrcontentUserId string) ApiPostAgentRequest {
	r.jcrcontentUserId = &jcrcontentUserId
	return r
}
func (r ApiPostAgentRequest) JcrprimaryType(jcrprimaryType string) ApiPostAgentRequest {
	r.jcrprimaryType = &jcrprimaryType
	return r
}
func (r ApiPostAgentRequest) Operation(operation string) ApiPostAgentRequest {
	r.operation = &operation
	return r
}

func (r ApiPostAgentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostAgentExecute(r)
}

/*
PostAgent Method for PostAgent

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runmode
 @param name
 @return ApiPostAgentRequest
*/
func (a *SlingApiService) PostAgent(ctx _context.Context, runmode string, name string) ApiPostAgentRequest {
	return ApiPostAgentRequest{
		ApiService: a,
		ctx: ctx,
		runmode: runmode,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) PostAgentExecute(r ApiPostAgentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostAgent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/replication/agents.{runmode}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"runmode"+"}", _neturl.PathEscape(parameterToString(r.runmode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.jcrcontentCqdistribute != nil {
		localVarQueryParams.Add("jcr:content/cq:distribute", parameterToString(*r.jcrcontentCqdistribute, ""))
	}
	if r.jcrcontentCqdistributeTypeHint != nil {
		localVarQueryParams.Add("jcr:content/cq:distribute@TypeHint", parameterToString(*r.jcrcontentCqdistributeTypeHint, ""))
	}
	if r.jcrcontentCqname != nil {
		localVarQueryParams.Add("jcr:content/cq:name", parameterToString(*r.jcrcontentCqname, ""))
	}
	if r.jcrcontentCqtemplate != nil {
		localVarQueryParams.Add("jcr:content/cq:template", parameterToString(*r.jcrcontentCqtemplate, ""))
	}
	if r.jcrcontentEnabled != nil {
		localVarQueryParams.Add("jcr:content/enabled", parameterToString(*r.jcrcontentEnabled, ""))
	}
	if r.jcrcontentJcrdescription != nil {
		localVarQueryParams.Add("jcr:content/jcr:description", parameterToString(*r.jcrcontentJcrdescription, ""))
	}
	if r.jcrcontentJcrlastModified != nil {
		localVarQueryParams.Add("jcr:content/jcr:lastModified", parameterToString(*r.jcrcontentJcrlastModified, ""))
	}
	if r.jcrcontentJcrlastModifiedBy != nil {
		localVarQueryParams.Add("jcr:content/jcr:lastModifiedBy", parameterToString(*r.jcrcontentJcrlastModifiedBy, ""))
	}
	if r.jcrcontentJcrmixinTypes != nil {
		localVarQueryParams.Add("jcr:content/jcr:mixinTypes", parameterToString(*r.jcrcontentJcrmixinTypes, ""))
	}
	if r.jcrcontentJcrtitle != nil {
		localVarQueryParams.Add("jcr:content/jcr:title", parameterToString(*r.jcrcontentJcrtitle, ""))
	}
	if r.jcrcontentLogLevel != nil {
		localVarQueryParams.Add("jcr:content/logLevel", parameterToString(*r.jcrcontentLogLevel, ""))
	}
	if r.jcrcontentNoStatusUpdate != nil {
		localVarQueryParams.Add("jcr:content/noStatusUpdate", parameterToString(*r.jcrcontentNoStatusUpdate, ""))
	}
	if r.jcrcontentNoVersioning != nil {
		localVarQueryParams.Add("jcr:content/noVersioning", parameterToString(*r.jcrcontentNoVersioning, ""))
	}
	if r.jcrcontentProtocolConnectTimeout != nil {
		localVarQueryParams.Add("jcr:content/protocolConnectTimeout", parameterToString(*r.jcrcontentProtocolConnectTimeout, ""))
	}
	if r.jcrcontentProtocolHTTPConnectionClosed != nil {
		localVarQueryParams.Add("jcr:content/protocolHTTPConnectionClosed", parameterToString(*r.jcrcontentProtocolHTTPConnectionClosed, ""))
	}
	if r.jcrcontentProtocolHTTPExpired != nil {
		localVarQueryParams.Add("jcr:content/protocolHTTPExpired", parameterToString(*r.jcrcontentProtocolHTTPExpired, ""))
	}
	if r.jcrcontentProtocolHTTPHeaders != nil {
		t := *r.jcrcontentProtocolHTTPHeaders
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("jcr:content/protocolHTTPHeaders", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("jcr:content/protocolHTTPHeaders", parameterToString(t, "multi"))
		}
	}
	if r.jcrcontentProtocolHTTPHeadersTypeHint != nil {
		localVarQueryParams.Add("jcr:content/protocolHTTPHeaders@TypeHint", parameterToString(*r.jcrcontentProtocolHTTPHeadersTypeHint, ""))
	}
	if r.jcrcontentProtocolHTTPMethod != nil {
		localVarQueryParams.Add("jcr:content/protocolHTTPMethod", parameterToString(*r.jcrcontentProtocolHTTPMethod, ""))
	}
	if r.jcrcontentProtocolHTTPSRelaxed != nil {
		localVarQueryParams.Add("jcr:content/protocolHTTPSRelaxed", parameterToString(*r.jcrcontentProtocolHTTPSRelaxed, ""))
	}
	if r.jcrcontentProtocolInterface != nil {
		localVarQueryParams.Add("jcr:content/protocolInterface", parameterToString(*r.jcrcontentProtocolInterface, ""))
	}
	if r.jcrcontentProtocolSocketTimeout != nil {
		localVarQueryParams.Add("jcr:content/protocolSocketTimeout", parameterToString(*r.jcrcontentProtocolSocketTimeout, ""))
	}
	if r.jcrcontentProtocolVersion != nil {
		localVarQueryParams.Add("jcr:content/protocolVersion", parameterToString(*r.jcrcontentProtocolVersion, ""))
	}
	if r.jcrcontentProxyNTLMDomain != nil {
		localVarQueryParams.Add("jcr:content/proxyNTLMDomain", parameterToString(*r.jcrcontentProxyNTLMDomain, ""))
	}
	if r.jcrcontentProxyNTLMHost != nil {
		localVarQueryParams.Add("jcr:content/proxyNTLMHost", parameterToString(*r.jcrcontentProxyNTLMHost, ""))
	}
	if r.jcrcontentProxyHost != nil {
		localVarQueryParams.Add("jcr:content/proxyHost", parameterToString(*r.jcrcontentProxyHost, ""))
	}
	if r.jcrcontentProxyPassword != nil {
		localVarQueryParams.Add("jcr:content/proxyPassword", parameterToString(*r.jcrcontentProxyPassword, ""))
	}
	if r.jcrcontentProxyPort != nil {
		localVarQueryParams.Add("jcr:content/proxyPort", parameterToString(*r.jcrcontentProxyPort, ""))
	}
	if r.jcrcontentProxyUser != nil {
		localVarQueryParams.Add("jcr:content/proxyUser", parameterToString(*r.jcrcontentProxyUser, ""))
	}
	if r.jcrcontentQueueBatchMaxSize != nil {
		localVarQueryParams.Add("jcr:content/queueBatchMaxSize", parameterToString(*r.jcrcontentQueueBatchMaxSize, ""))
	}
	if r.jcrcontentQueueBatchMode != nil {
		localVarQueryParams.Add("jcr:content/queueBatchMode", parameterToString(*r.jcrcontentQueueBatchMode, ""))
	}
	if r.jcrcontentQueueBatchWaitTime != nil {
		localVarQueryParams.Add("jcr:content/queueBatchWaitTime", parameterToString(*r.jcrcontentQueueBatchWaitTime, ""))
	}
	if r.jcrcontentRetryDelay != nil {
		localVarQueryParams.Add("jcr:content/retryDelay", parameterToString(*r.jcrcontentRetryDelay, ""))
	}
	if r.jcrcontentReverseReplication != nil {
		localVarQueryParams.Add("jcr:content/reverseReplication", parameterToString(*r.jcrcontentReverseReplication, ""))
	}
	if r.jcrcontentSerializationType != nil {
		localVarQueryParams.Add("jcr:content/serializationType", parameterToString(*r.jcrcontentSerializationType, ""))
	}
	if r.jcrcontentSlingresourceType != nil {
		localVarQueryParams.Add("jcr:content/sling:resourceType", parameterToString(*r.jcrcontentSlingresourceType, ""))
	}
	if r.jcrcontentSsl != nil {
		localVarQueryParams.Add("jcr:content/ssl", parameterToString(*r.jcrcontentSsl, ""))
	}
	if r.jcrcontentTransportNTLMDomain != nil {
		localVarQueryParams.Add("jcr:content/transportNTLMDomain", parameterToString(*r.jcrcontentTransportNTLMDomain, ""))
	}
	if r.jcrcontentTransportNTLMHost != nil {
		localVarQueryParams.Add("jcr:content/transportNTLMHost", parameterToString(*r.jcrcontentTransportNTLMHost, ""))
	}
	if r.jcrcontentTransportPassword != nil {
		localVarQueryParams.Add("jcr:content/transportPassword", parameterToString(*r.jcrcontentTransportPassword, ""))
	}
	if r.jcrcontentTransportUri != nil {
		localVarQueryParams.Add("jcr:content/transportUri", parameterToString(*r.jcrcontentTransportUri, ""))
	}
	if r.jcrcontentTransportUser != nil {
		localVarQueryParams.Add("jcr:content/transportUser", parameterToString(*r.jcrcontentTransportUser, ""))
	}
	if r.jcrcontentTriggerDistribute != nil {
		localVarQueryParams.Add("jcr:content/triggerDistribute", parameterToString(*r.jcrcontentTriggerDistribute, ""))
	}
	if r.jcrcontentTriggerModified != nil {
		localVarQueryParams.Add("jcr:content/triggerModified", parameterToString(*r.jcrcontentTriggerModified, ""))
	}
	if r.jcrcontentTriggerOnOffTime != nil {
		localVarQueryParams.Add("jcr:content/triggerOnOffTime", parameterToString(*r.jcrcontentTriggerOnOffTime, ""))
	}
	if r.jcrcontentTriggerReceive != nil {
		localVarQueryParams.Add("jcr:content/triggerReceive", parameterToString(*r.jcrcontentTriggerReceive, ""))
	}
	if r.jcrcontentTriggerSpecific != nil {
		localVarQueryParams.Add("jcr:content/triggerSpecific", parameterToString(*r.jcrcontentTriggerSpecific, ""))
	}
	if r.jcrcontentUserId != nil {
		localVarQueryParams.Add("jcr:content/userId", parameterToString(*r.jcrcontentUserId, ""))
	}
	if r.jcrprimaryType != nil {
		localVarQueryParams.Add("jcr:primaryType", parameterToString(*r.jcrprimaryType, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add(":operation", parameterToString(*r.operation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAuthorizableKeystoreRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	intermediatePath string
	authorizableId string
	operation *string
	currentPassword *string
	newPassword *string
	rePassword *string
	keyPassword *string
	keyStorePass *string
	alias *string
	newAlias *string
	removeAlias *string
	certChain **os.File
	pk **os.File
	keyStore **os.File
}

func (r ApiPostAuthorizableKeystoreRequest) Operation(operation string) ApiPostAuthorizableKeystoreRequest {
	r.operation = &operation
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) CurrentPassword(currentPassword string) ApiPostAuthorizableKeystoreRequest {
	r.currentPassword = &currentPassword
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) NewPassword(newPassword string) ApiPostAuthorizableKeystoreRequest {
	r.newPassword = &newPassword
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) RePassword(rePassword string) ApiPostAuthorizableKeystoreRequest {
	r.rePassword = &rePassword
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) KeyPassword(keyPassword string) ApiPostAuthorizableKeystoreRequest {
	r.keyPassword = &keyPassword
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) KeyStorePass(keyStorePass string) ApiPostAuthorizableKeystoreRequest {
	r.keyStorePass = &keyStorePass
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) Alias(alias string) ApiPostAuthorizableKeystoreRequest {
	r.alias = &alias
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) NewAlias(newAlias string) ApiPostAuthorizableKeystoreRequest {
	r.newAlias = &newAlias
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) RemoveAlias(removeAlias string) ApiPostAuthorizableKeystoreRequest {
	r.removeAlias = &removeAlias
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) CertChain(certChain *os.File) ApiPostAuthorizableKeystoreRequest {
	r.certChain = &certChain
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) Pk(pk *os.File) ApiPostAuthorizableKeystoreRequest {
	r.pk = &pk
	return r
}
func (r ApiPostAuthorizableKeystoreRequest) KeyStore(keyStore *os.File) ApiPostAuthorizableKeystoreRequest {
	r.keyStore = &keyStore
	return r
}

func (r ApiPostAuthorizableKeystoreRequest) Execute() (KeystoreInfo, *_nethttp.Response, error) {
	return r.ApiService.PostAuthorizableKeystoreExecute(r)
}

/*
PostAuthorizableKeystore Method for PostAuthorizableKeystore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param intermediatePath
 @param authorizableId
 @return ApiPostAuthorizableKeystoreRequest
*/
func (a *SlingApiService) PostAuthorizableKeystore(ctx _context.Context, intermediatePath string, authorizableId string) ApiPostAuthorizableKeystoreRequest {
	return ApiPostAuthorizableKeystoreRequest{
		ApiService: a,
		ctx: ctx,
		intermediatePath: intermediatePath,
		authorizableId: authorizableId,
	}
}

// Execute executes the request
//  @return KeystoreInfo
func (a *SlingApiService) PostAuthorizableKeystoreExecute(r ApiPostAuthorizableKeystoreRequest) (KeystoreInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KeystoreInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostAuthorizableKeystore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{intermediatePath}/{authorizableId}.ks.html"
	localVarPath = strings.Replace(localVarPath, "{"+"intermediatePath"+"}", _neturl.PathEscape(parameterToString(r.intermediatePath, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizableId"+"}", _neturl.PathEscape(parameterToString(r.authorizableId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.operation != nil {
		localVarQueryParams.Add(":operation", parameterToString(*r.operation, ""))
	}
	if r.currentPassword != nil {
		localVarQueryParams.Add("currentPassword", parameterToString(*r.currentPassword, ""))
	}
	if r.newPassword != nil {
		localVarQueryParams.Add("newPassword", parameterToString(*r.newPassword, ""))
	}
	if r.rePassword != nil {
		localVarQueryParams.Add("rePassword", parameterToString(*r.rePassword, ""))
	}
	if r.keyPassword != nil {
		localVarQueryParams.Add("keyPassword", parameterToString(*r.keyPassword, ""))
	}
	if r.keyStorePass != nil {
		localVarQueryParams.Add("keyStorePass", parameterToString(*r.keyStorePass, ""))
	}
	if r.alias != nil {
		localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	}
	if r.newAlias != nil {
		localVarQueryParams.Add("newAlias", parameterToString(*r.newAlias, ""))
	}
	if r.removeAlias != nil {
		localVarQueryParams.Add("removeAlias", parameterToString(*r.removeAlias, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormFileName = "cert-chain"
	var localVarFile *os.File
	if r.certChain != nil {
		localVarFile = *r.certChain
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	localVarFormFileName = "pk"
	var localVarFile *os.File
	if r.pk != nil {
		localVarFile = *r.pk
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	localVarFormFileName = "keyStore"
	var localVarFile *os.File
	if r.keyStore != nil {
		localVarFile = *r.keyStore
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAuthorizablesRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	authorizableId *string
	intermediatePath *string
	createUser *string
	createGroup *string
	reppassword *string
	profileGivenName *string
}

func (r ApiPostAuthorizablesRequest) AuthorizableId(authorizableId string) ApiPostAuthorizablesRequest {
	r.authorizableId = &authorizableId
	return r
}
func (r ApiPostAuthorizablesRequest) IntermediatePath(intermediatePath string) ApiPostAuthorizablesRequest {
	r.intermediatePath = &intermediatePath
	return r
}
func (r ApiPostAuthorizablesRequest) CreateUser(createUser string) ApiPostAuthorizablesRequest {
	r.createUser = &createUser
	return r
}
func (r ApiPostAuthorizablesRequest) CreateGroup(createGroup string) ApiPostAuthorizablesRequest {
	r.createGroup = &createGroup
	return r
}
func (r ApiPostAuthorizablesRequest) Reppassword(reppassword string) ApiPostAuthorizablesRequest {
	r.reppassword = &reppassword
	return r
}
func (r ApiPostAuthorizablesRequest) ProfileGivenName(profileGivenName string) ApiPostAuthorizablesRequest {
	r.profileGivenName = &profileGivenName
	return r
}

func (r ApiPostAuthorizablesRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PostAuthorizablesExecute(r)
}

/*
PostAuthorizables Method for PostAuthorizables

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAuthorizablesRequest
*/
func (a *SlingApiService) PostAuthorizables(ctx _context.Context) ApiPostAuthorizablesRequest {
	return ApiPostAuthorizablesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) PostAuthorizablesExecute(r ApiPostAuthorizablesRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostAuthorizables")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/libs/granite/security/post/authorizables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorizableId == nil {
		return localVarReturnValue, nil, reportError("authorizableId is required and must be specified")
	}
	if r.intermediatePath == nil {
		return localVarReturnValue, nil, reportError("intermediatePath is required and must be specified")
	}

	localVarQueryParams.Add("authorizableId", parameterToString(*r.authorizableId, ""))
	localVarQueryParams.Add("intermediatePath", parameterToString(*r.intermediatePath, ""))
	if r.createUser != nil {
		localVarQueryParams.Add("createUser", parameterToString(*r.createUser, ""))
	}
	if r.createGroup != nil {
		localVarQueryParams.Add("createGroup", parameterToString(*r.createGroup, ""))
	}
	if r.reppassword != nil {
		localVarQueryParams.Add("rep:password", parameterToString(*r.reppassword, ""))
	}
	if r.profileGivenName != nil {
		localVarQueryParams.Add("profile/givenName", parameterToString(*r.profileGivenName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	keyStorePassword *string
	keyStorePasswordTypeHint *string
	serviceRanking *int32
	serviceRankingTypeHint *string
	idpHttpRedirect *bool
	idpHttpRedirectTypeHint *string
	createUser *bool
	createUserTypeHint *string
	defaultRedirectUrl *string
	defaultRedirectUrlTypeHint *string
	userIDAttribute *string
	userIDAttributeTypeHint *string
	defaultGroups *[]string
	defaultGroupsTypeHint *string
	idpCertAlias *string
	idpCertAliasTypeHint *string
	addGroupMemberships *bool
	addGroupMembershipsTypeHint *string
	path *[]string
	pathTypeHint *string
	synchronizeAttributes *[]string
	synchronizeAttributesTypeHint *string
	clockTolerance *int32
	clockToleranceTypeHint *string
	groupMembershipAttribute *string
	groupMembershipAttributeTypeHint *string
	idpUrl *string
	idpUrlTypeHint *string
	logoutUrl *string
	logoutUrlTypeHint *string
	serviceProviderEntityId *string
	serviceProviderEntityIdTypeHint *string
	assertionConsumerServiceURL *string
	assertionConsumerServiceURLTypeHint *string
	handleLogout *bool
	handleLogoutTypeHint *string
	spPrivateKeyAlias *string
	spPrivateKeyAliasTypeHint *string
	useEncryption *bool
	useEncryptionTypeHint *string
	nameIdFormat *string
	nameIdFormatTypeHint *string
	digestMethod *string
	digestMethodTypeHint *string
	signatureMethod *string
	signatureMethodTypeHint *string
	userIntermediatePath *string
	userIntermediatePathTypeHint *string
}

func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) KeyStorePassword(keyStorePassword string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.keyStorePassword = &keyStorePassword
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) KeyStorePasswordTypeHint(keyStorePasswordTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.keyStorePasswordTypeHint = &keyStorePasswordTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) ServiceRanking(serviceRanking int32) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.serviceRanking = &serviceRanking
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) ServiceRankingTypeHint(serviceRankingTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.serviceRankingTypeHint = &serviceRankingTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) IdpHttpRedirect(idpHttpRedirect bool) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.idpHttpRedirect = &idpHttpRedirect
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) IdpHttpRedirectTypeHint(idpHttpRedirectTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.idpHttpRedirectTypeHint = &idpHttpRedirectTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) CreateUser(createUser bool) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.createUser = &createUser
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) CreateUserTypeHint(createUserTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.createUserTypeHint = &createUserTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) DefaultRedirectUrl(defaultRedirectUrl string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.defaultRedirectUrl = &defaultRedirectUrl
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) DefaultRedirectUrlTypeHint(defaultRedirectUrlTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.defaultRedirectUrlTypeHint = &defaultRedirectUrlTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) UserIDAttribute(userIDAttribute string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.userIDAttribute = &userIDAttribute
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) UserIDAttributeTypeHint(userIDAttributeTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.userIDAttributeTypeHint = &userIDAttributeTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) DefaultGroups(defaultGroups []string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.defaultGroups = &defaultGroups
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) DefaultGroupsTypeHint(defaultGroupsTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.defaultGroupsTypeHint = &defaultGroupsTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) IdpCertAlias(idpCertAlias string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.idpCertAlias = &idpCertAlias
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) IdpCertAliasTypeHint(idpCertAliasTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.idpCertAliasTypeHint = &idpCertAliasTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) AddGroupMemberships(addGroupMemberships bool) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.addGroupMemberships = &addGroupMemberships
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) AddGroupMembershipsTypeHint(addGroupMembershipsTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.addGroupMembershipsTypeHint = &addGroupMembershipsTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) Path(path []string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.path = &path
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) PathTypeHint(pathTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.pathTypeHint = &pathTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) SynchronizeAttributes(synchronizeAttributes []string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.synchronizeAttributes = &synchronizeAttributes
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) SynchronizeAttributesTypeHint(synchronizeAttributesTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.synchronizeAttributesTypeHint = &synchronizeAttributesTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) ClockTolerance(clockTolerance int32) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.clockTolerance = &clockTolerance
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) ClockToleranceTypeHint(clockToleranceTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.clockToleranceTypeHint = &clockToleranceTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) GroupMembershipAttribute(groupMembershipAttribute string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.groupMembershipAttribute = &groupMembershipAttribute
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) GroupMembershipAttributeTypeHint(groupMembershipAttributeTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.groupMembershipAttributeTypeHint = &groupMembershipAttributeTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) IdpUrl(idpUrl string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.idpUrl = &idpUrl
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) IdpUrlTypeHint(idpUrlTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.idpUrlTypeHint = &idpUrlTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) LogoutUrl(logoutUrl string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.logoutUrl = &logoutUrl
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) LogoutUrlTypeHint(logoutUrlTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.logoutUrlTypeHint = &logoutUrlTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) ServiceProviderEntityId(serviceProviderEntityId string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.serviceProviderEntityId = &serviceProviderEntityId
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) ServiceProviderEntityIdTypeHint(serviceProviderEntityIdTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.serviceProviderEntityIdTypeHint = &serviceProviderEntityIdTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) AssertionConsumerServiceURL(assertionConsumerServiceURL string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.assertionConsumerServiceURL = &assertionConsumerServiceURL
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) AssertionConsumerServiceURLTypeHint(assertionConsumerServiceURLTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.assertionConsumerServiceURLTypeHint = &assertionConsumerServiceURLTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) HandleLogout(handleLogout bool) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.handleLogout = &handleLogout
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) HandleLogoutTypeHint(handleLogoutTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.handleLogoutTypeHint = &handleLogoutTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) SpPrivateKeyAlias(spPrivateKeyAlias string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.spPrivateKeyAlias = &spPrivateKeyAlias
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) SpPrivateKeyAliasTypeHint(spPrivateKeyAliasTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.spPrivateKeyAliasTypeHint = &spPrivateKeyAliasTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) UseEncryption(useEncryption bool) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.useEncryption = &useEncryption
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) UseEncryptionTypeHint(useEncryptionTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.useEncryptionTypeHint = &useEncryptionTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) NameIdFormat(nameIdFormat string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.nameIdFormat = &nameIdFormat
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) NameIdFormatTypeHint(nameIdFormatTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.nameIdFormatTypeHint = &nameIdFormatTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) DigestMethod(digestMethod string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.digestMethod = &digestMethod
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) DigestMethodTypeHint(digestMethodTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.digestMethodTypeHint = &digestMethodTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) SignatureMethod(signatureMethod string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.signatureMethod = &signatureMethod
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) SignatureMethodTypeHint(signatureMethodTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.signatureMethodTypeHint = &signatureMethodTypeHint
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) UserIntermediatePath(userIntermediatePath string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.userIntermediatePath = &userIntermediatePath
	return r
}
func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) UserIntermediatePathTypeHint(userIntermediatePathTypeHint string) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	r.userIntermediatePathTypeHint = &userIntermediatePathTypeHint
	return r
}

func (r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigAdobeGraniteSamlAuthenticationHandlerExecute(r)
}

/*
PostConfigAdobeGraniteSamlAuthenticationHandler Method for PostConfigAdobeGraniteSamlAuthenticationHandler

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest
*/
func (a *SlingApiService) PostConfigAdobeGraniteSamlAuthenticationHandler(ctx _context.Context) ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
	return ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigAdobeGraniteSamlAuthenticationHandlerExecute(r ApiPostConfigAdobeGraniteSamlAuthenticationHandlerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigAdobeGraniteSamlAuthenticationHandler")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.keyStorePassword != nil {
		localVarQueryParams.Add("keyStorePassword", parameterToString(*r.keyStorePassword, ""))
	}
	if r.keyStorePasswordTypeHint != nil {
		localVarQueryParams.Add("keyStorePassword@TypeHint", parameterToString(*r.keyStorePasswordTypeHint, ""))
	}
	if r.serviceRanking != nil {
		localVarQueryParams.Add("service.ranking", parameterToString(*r.serviceRanking, ""))
	}
	if r.serviceRankingTypeHint != nil {
		localVarQueryParams.Add("service.ranking@TypeHint", parameterToString(*r.serviceRankingTypeHint, ""))
	}
	if r.idpHttpRedirect != nil {
		localVarQueryParams.Add("idpHttpRedirect", parameterToString(*r.idpHttpRedirect, ""))
	}
	if r.idpHttpRedirectTypeHint != nil {
		localVarQueryParams.Add("idpHttpRedirect@TypeHint", parameterToString(*r.idpHttpRedirectTypeHint, ""))
	}
	if r.createUser != nil {
		localVarQueryParams.Add("createUser", parameterToString(*r.createUser, ""))
	}
	if r.createUserTypeHint != nil {
		localVarQueryParams.Add("createUser@TypeHint", parameterToString(*r.createUserTypeHint, ""))
	}
	if r.defaultRedirectUrl != nil {
		localVarQueryParams.Add("defaultRedirectUrl", parameterToString(*r.defaultRedirectUrl, ""))
	}
	if r.defaultRedirectUrlTypeHint != nil {
		localVarQueryParams.Add("defaultRedirectUrl@TypeHint", parameterToString(*r.defaultRedirectUrlTypeHint, ""))
	}
	if r.userIDAttribute != nil {
		localVarQueryParams.Add("userIDAttribute", parameterToString(*r.userIDAttribute, ""))
	}
	if r.userIDAttributeTypeHint != nil {
		localVarQueryParams.Add("userIDAttribute@TypeHint", parameterToString(*r.userIDAttributeTypeHint, ""))
	}
	if r.defaultGroups != nil {
		t := *r.defaultGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("defaultGroups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("defaultGroups", parameterToString(t, "multi"))
		}
	}
	if r.defaultGroupsTypeHint != nil {
		localVarQueryParams.Add("defaultGroups@TypeHint", parameterToString(*r.defaultGroupsTypeHint, ""))
	}
	if r.idpCertAlias != nil {
		localVarQueryParams.Add("idpCertAlias", parameterToString(*r.idpCertAlias, ""))
	}
	if r.idpCertAliasTypeHint != nil {
		localVarQueryParams.Add("idpCertAlias@TypeHint", parameterToString(*r.idpCertAliasTypeHint, ""))
	}
	if r.addGroupMemberships != nil {
		localVarQueryParams.Add("addGroupMemberships", parameterToString(*r.addGroupMemberships, ""))
	}
	if r.addGroupMembershipsTypeHint != nil {
		localVarQueryParams.Add("addGroupMemberships@TypeHint", parameterToString(*r.addGroupMembershipsTypeHint, ""))
	}
	if r.path != nil {
		t := *r.path
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("path", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("path", parameterToString(t, "multi"))
		}
	}
	if r.pathTypeHint != nil {
		localVarQueryParams.Add("path@TypeHint", parameterToString(*r.pathTypeHint, ""))
	}
	if r.synchronizeAttributes != nil {
		t := *r.synchronizeAttributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("synchronizeAttributes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("synchronizeAttributes", parameterToString(t, "multi"))
		}
	}
	if r.synchronizeAttributesTypeHint != nil {
		localVarQueryParams.Add("synchronizeAttributes@TypeHint", parameterToString(*r.synchronizeAttributesTypeHint, ""))
	}
	if r.clockTolerance != nil {
		localVarQueryParams.Add("clockTolerance", parameterToString(*r.clockTolerance, ""))
	}
	if r.clockToleranceTypeHint != nil {
		localVarQueryParams.Add("clockTolerance@TypeHint", parameterToString(*r.clockToleranceTypeHint, ""))
	}
	if r.groupMembershipAttribute != nil {
		localVarQueryParams.Add("groupMembershipAttribute", parameterToString(*r.groupMembershipAttribute, ""))
	}
	if r.groupMembershipAttributeTypeHint != nil {
		localVarQueryParams.Add("groupMembershipAttribute@TypeHint", parameterToString(*r.groupMembershipAttributeTypeHint, ""))
	}
	if r.idpUrl != nil {
		localVarQueryParams.Add("idpUrl", parameterToString(*r.idpUrl, ""))
	}
	if r.idpUrlTypeHint != nil {
		localVarQueryParams.Add("idpUrl@TypeHint", parameterToString(*r.idpUrlTypeHint, ""))
	}
	if r.logoutUrl != nil {
		localVarQueryParams.Add("logoutUrl", parameterToString(*r.logoutUrl, ""))
	}
	if r.logoutUrlTypeHint != nil {
		localVarQueryParams.Add("logoutUrl@TypeHint", parameterToString(*r.logoutUrlTypeHint, ""))
	}
	if r.serviceProviderEntityId != nil {
		localVarQueryParams.Add("serviceProviderEntityId", parameterToString(*r.serviceProviderEntityId, ""))
	}
	if r.serviceProviderEntityIdTypeHint != nil {
		localVarQueryParams.Add("serviceProviderEntityId@TypeHint", parameterToString(*r.serviceProviderEntityIdTypeHint, ""))
	}
	if r.assertionConsumerServiceURL != nil {
		localVarQueryParams.Add("assertionConsumerServiceURL", parameterToString(*r.assertionConsumerServiceURL, ""))
	}
	if r.assertionConsumerServiceURLTypeHint != nil {
		localVarQueryParams.Add("assertionConsumerServiceURL@TypeHint", parameterToString(*r.assertionConsumerServiceURLTypeHint, ""))
	}
	if r.handleLogout != nil {
		localVarQueryParams.Add("handleLogout", parameterToString(*r.handleLogout, ""))
	}
	if r.handleLogoutTypeHint != nil {
		localVarQueryParams.Add("handleLogout@TypeHint", parameterToString(*r.handleLogoutTypeHint, ""))
	}
	if r.spPrivateKeyAlias != nil {
		localVarQueryParams.Add("spPrivateKeyAlias", parameterToString(*r.spPrivateKeyAlias, ""))
	}
	if r.spPrivateKeyAliasTypeHint != nil {
		localVarQueryParams.Add("spPrivateKeyAlias@TypeHint", parameterToString(*r.spPrivateKeyAliasTypeHint, ""))
	}
	if r.useEncryption != nil {
		localVarQueryParams.Add("useEncryption", parameterToString(*r.useEncryption, ""))
	}
	if r.useEncryptionTypeHint != nil {
		localVarQueryParams.Add("useEncryption@TypeHint", parameterToString(*r.useEncryptionTypeHint, ""))
	}
	if r.nameIdFormat != nil {
		localVarQueryParams.Add("nameIdFormat", parameterToString(*r.nameIdFormat, ""))
	}
	if r.nameIdFormatTypeHint != nil {
		localVarQueryParams.Add("nameIdFormat@TypeHint", parameterToString(*r.nameIdFormatTypeHint, ""))
	}
	if r.digestMethod != nil {
		localVarQueryParams.Add("digestMethod", parameterToString(*r.digestMethod, ""))
	}
	if r.digestMethodTypeHint != nil {
		localVarQueryParams.Add("digestMethod@TypeHint", parameterToString(*r.digestMethodTypeHint, ""))
	}
	if r.signatureMethod != nil {
		localVarQueryParams.Add("signatureMethod", parameterToString(*r.signatureMethod, ""))
	}
	if r.signatureMethodTypeHint != nil {
		localVarQueryParams.Add("signatureMethod@TypeHint", parameterToString(*r.signatureMethodTypeHint, ""))
	}
	if r.userIntermediatePath != nil {
		localVarQueryParams.Add("userIntermediatePath", parameterToString(*r.userIntermediatePath, ""))
	}
	if r.userIntermediatePathTypeHint != nil {
		localVarQueryParams.Add("userIntermediatePath@TypeHint", parameterToString(*r.userIntermediatePathTypeHint, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostConfigApacheFelixJettyBasedHttpServiceRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	orgApacheFelixHttpsNio *bool
	orgApacheFelixHttpsNioTypeHint *string
	orgApacheFelixHttpsKeystore *string
	orgApacheFelixHttpsKeystoreTypeHint *string
	orgApacheFelixHttpsKeystorePassword *string
	orgApacheFelixHttpsKeystorePasswordTypeHint *string
	orgApacheFelixHttpsKeystoreKey *string
	orgApacheFelixHttpsKeystoreKeyTypeHint *string
	orgApacheFelixHttpsKeystoreKeyPassword *string
	orgApacheFelixHttpsKeystoreKeyPasswordTypeHint *string
	orgApacheFelixHttpsTruststore *string
	orgApacheFelixHttpsTruststoreTypeHint *string
	orgApacheFelixHttpsTruststorePassword *string
	orgApacheFelixHttpsTruststorePasswordTypeHint *string
	orgApacheFelixHttpsClientcertificate *string
	orgApacheFelixHttpsClientcertificateTypeHint *string
	orgApacheFelixHttpsEnable *bool
	orgApacheFelixHttpsEnableTypeHint *string
	orgOsgiServiceHttpPortSecure *string
	orgOsgiServiceHttpPortSecureTypeHint *string
}

func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsNio(orgApacheFelixHttpsNio bool) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsNio = &orgApacheFelixHttpsNio
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsNioTypeHint(orgApacheFelixHttpsNioTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsNioTypeHint = &orgApacheFelixHttpsNioTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystore(orgApacheFelixHttpsKeystore string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystore = &orgApacheFelixHttpsKeystore
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystoreTypeHint(orgApacheFelixHttpsKeystoreTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystoreTypeHint = &orgApacheFelixHttpsKeystoreTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystorePassword(orgApacheFelixHttpsKeystorePassword string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystorePassword = &orgApacheFelixHttpsKeystorePassword
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystorePasswordTypeHint(orgApacheFelixHttpsKeystorePasswordTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystorePasswordTypeHint = &orgApacheFelixHttpsKeystorePasswordTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystoreKey(orgApacheFelixHttpsKeystoreKey string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystoreKey = &orgApacheFelixHttpsKeystoreKey
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystoreKeyTypeHint(orgApacheFelixHttpsKeystoreKeyTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystoreKeyTypeHint = &orgApacheFelixHttpsKeystoreKeyTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystoreKeyPassword(orgApacheFelixHttpsKeystoreKeyPassword string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystoreKeyPassword = &orgApacheFelixHttpsKeystoreKeyPassword
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint(orgApacheFelixHttpsKeystoreKeyPasswordTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsKeystoreKeyPasswordTypeHint = &orgApacheFelixHttpsKeystoreKeyPasswordTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsTruststore(orgApacheFelixHttpsTruststore string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsTruststore = &orgApacheFelixHttpsTruststore
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsTruststoreTypeHint(orgApacheFelixHttpsTruststoreTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsTruststoreTypeHint = &orgApacheFelixHttpsTruststoreTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsTruststorePassword(orgApacheFelixHttpsTruststorePassword string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsTruststorePassword = &orgApacheFelixHttpsTruststorePassword
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsTruststorePasswordTypeHint(orgApacheFelixHttpsTruststorePasswordTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsTruststorePasswordTypeHint = &orgApacheFelixHttpsTruststorePasswordTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsClientcertificate(orgApacheFelixHttpsClientcertificate string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsClientcertificate = &orgApacheFelixHttpsClientcertificate
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsClientcertificateTypeHint(orgApacheFelixHttpsClientcertificateTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsClientcertificateTypeHint = &orgApacheFelixHttpsClientcertificateTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsEnable(orgApacheFelixHttpsEnable bool) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsEnable = &orgApacheFelixHttpsEnable
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgApacheFelixHttpsEnableTypeHint(orgApacheFelixHttpsEnableTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgApacheFelixHttpsEnableTypeHint = &orgApacheFelixHttpsEnableTypeHint
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgOsgiServiceHttpPortSecure(orgOsgiServiceHttpPortSecure string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgOsgiServiceHttpPortSecure = &orgOsgiServiceHttpPortSecure
	return r
}
func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) OrgOsgiServiceHttpPortSecureTypeHint(orgOsgiServiceHttpPortSecureTypeHint string) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	r.orgOsgiServiceHttpPortSecureTypeHint = &orgOsgiServiceHttpPortSecureTypeHint
	return r
}

func (r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigApacheFelixJettyBasedHttpServiceExecute(r)
}

/*
PostConfigApacheFelixJettyBasedHttpService Method for PostConfigApacheFelixJettyBasedHttpService

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConfigApacheFelixJettyBasedHttpServiceRequest
*/
func (a *SlingApiService) PostConfigApacheFelixJettyBasedHttpService(ctx _context.Context) ApiPostConfigApacheFelixJettyBasedHttpServiceRequest {
	return ApiPostConfigApacheFelixJettyBasedHttpServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigApacheFelixJettyBasedHttpServiceExecute(r ApiPostConfigApacheFelixJettyBasedHttpServiceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigApacheFelixJettyBasedHttpService")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/org.apache.felix.http"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orgApacheFelixHttpsNio != nil {
		localVarQueryParams.Add("org.apache.felix.https.nio", parameterToString(*r.orgApacheFelixHttpsNio, ""))
	}
	if r.orgApacheFelixHttpsNioTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.nio@TypeHint", parameterToString(*r.orgApacheFelixHttpsNioTypeHint, ""))
	}
	if r.orgApacheFelixHttpsKeystore != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore", parameterToString(*r.orgApacheFelixHttpsKeystore, ""))
	}
	if r.orgApacheFelixHttpsKeystoreTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore@TypeHint", parameterToString(*r.orgApacheFelixHttpsKeystoreTypeHint, ""))
	}
	if r.orgApacheFelixHttpsKeystorePassword != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore.password", parameterToString(*r.orgApacheFelixHttpsKeystorePassword, ""))
	}
	if r.orgApacheFelixHttpsKeystorePasswordTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore.password@TypeHint", parameterToString(*r.orgApacheFelixHttpsKeystorePasswordTypeHint, ""))
	}
	if r.orgApacheFelixHttpsKeystoreKey != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key", parameterToString(*r.orgApacheFelixHttpsKeystoreKey, ""))
	}
	if r.orgApacheFelixHttpsKeystoreKeyTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key@TypeHint", parameterToString(*r.orgApacheFelixHttpsKeystoreKeyTypeHint, ""))
	}
	if r.orgApacheFelixHttpsKeystoreKeyPassword != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key.password", parameterToString(*r.orgApacheFelixHttpsKeystoreKeyPassword, ""))
	}
	if r.orgApacheFelixHttpsKeystoreKeyPasswordTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.keystore.key.password@TypeHint", parameterToString(*r.orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, ""))
	}
	if r.orgApacheFelixHttpsTruststore != nil {
		localVarQueryParams.Add("org.apache.felix.https.truststore", parameterToString(*r.orgApacheFelixHttpsTruststore, ""))
	}
	if r.orgApacheFelixHttpsTruststoreTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.truststore@TypeHint", parameterToString(*r.orgApacheFelixHttpsTruststoreTypeHint, ""))
	}
	if r.orgApacheFelixHttpsTruststorePassword != nil {
		localVarQueryParams.Add("org.apache.felix.https.truststore.password", parameterToString(*r.orgApacheFelixHttpsTruststorePassword, ""))
	}
	if r.orgApacheFelixHttpsTruststorePasswordTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.truststore.password@TypeHint", parameterToString(*r.orgApacheFelixHttpsTruststorePasswordTypeHint, ""))
	}
	if r.orgApacheFelixHttpsClientcertificate != nil {
		localVarQueryParams.Add("org.apache.felix.https.clientcertificate", parameterToString(*r.orgApacheFelixHttpsClientcertificate, ""))
	}
	if r.orgApacheFelixHttpsClientcertificateTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.clientcertificate@TypeHint", parameterToString(*r.orgApacheFelixHttpsClientcertificateTypeHint, ""))
	}
	if r.orgApacheFelixHttpsEnable != nil {
		localVarQueryParams.Add("org.apache.felix.https.enable", parameterToString(*r.orgApacheFelixHttpsEnable, ""))
	}
	if r.orgApacheFelixHttpsEnableTypeHint != nil {
		localVarQueryParams.Add("org.apache.felix.https.enable@TypeHint", parameterToString(*r.orgApacheFelixHttpsEnableTypeHint, ""))
	}
	if r.orgOsgiServiceHttpPortSecure != nil {
		localVarQueryParams.Add("org.osgi.service.http.port.secure", parameterToString(*r.orgOsgiServiceHttpPortSecure, ""))
	}
	if r.orgOsgiServiceHttpPortSecureTypeHint != nil {
		localVarQueryParams.Add("org.osgi.service.http.port.secure@TypeHint", parameterToString(*r.orgOsgiServiceHttpPortSecureTypeHint, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostConfigApacheHttpComponentsProxyConfigurationRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	proxyHost *string
	proxyHostTypeHint *string
	proxyPort *int32
	proxyPortTypeHint *string
	proxyExceptions *[]string
	proxyExceptionsTypeHint *string
	proxyEnabled *bool
	proxyEnabledTypeHint *string
	proxyUser *string
	proxyUserTypeHint *string
	proxyPassword *string
	proxyPasswordTypeHint *string
}

func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyHost(proxyHost string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyHost = &proxyHost
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyHostTypeHint(proxyHostTypeHint string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyHostTypeHint = &proxyHostTypeHint
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyPort(proxyPort int32) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyPort = &proxyPort
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyPortTypeHint(proxyPortTypeHint string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyPortTypeHint = &proxyPortTypeHint
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyExceptions(proxyExceptions []string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyExceptions = &proxyExceptions
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyExceptionsTypeHint(proxyExceptionsTypeHint string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyExceptionsTypeHint = &proxyExceptionsTypeHint
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyEnabled(proxyEnabled bool) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyEnabled = &proxyEnabled
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyEnabledTypeHint(proxyEnabledTypeHint string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyEnabledTypeHint = &proxyEnabledTypeHint
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyUser(proxyUser string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyUser = &proxyUser
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyUserTypeHint(proxyUserTypeHint string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyUserTypeHint = &proxyUserTypeHint
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyPassword(proxyPassword string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyPassword = &proxyPassword
	return r
}
func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) ProxyPasswordTypeHint(proxyPasswordTypeHint string) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	r.proxyPasswordTypeHint = &proxyPasswordTypeHint
	return r
}

func (r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigApacheHttpComponentsProxyConfigurationExecute(r)
}

/*
PostConfigApacheHttpComponentsProxyConfiguration Method for PostConfigApacheHttpComponentsProxyConfiguration

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConfigApacheHttpComponentsProxyConfigurationRequest
*/
func (a *SlingApiService) PostConfigApacheHttpComponentsProxyConfiguration(ctx _context.Context) ApiPostConfigApacheHttpComponentsProxyConfigurationRequest {
	return ApiPostConfigApacheHttpComponentsProxyConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigApacheHttpComponentsProxyConfigurationExecute(r ApiPostConfigApacheHttpComponentsProxyConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigApacheHttpComponentsProxyConfiguration")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/org.apache.http.proxyconfigurator.config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.proxyHost != nil {
		localVarQueryParams.Add("proxy.host", parameterToString(*r.proxyHost, ""))
	}
	if r.proxyHostTypeHint != nil {
		localVarQueryParams.Add("proxy.host@TypeHint", parameterToString(*r.proxyHostTypeHint, ""))
	}
	if r.proxyPort != nil {
		localVarQueryParams.Add("proxy.port", parameterToString(*r.proxyPort, ""))
	}
	if r.proxyPortTypeHint != nil {
		localVarQueryParams.Add("proxy.port@TypeHint", parameterToString(*r.proxyPortTypeHint, ""))
	}
	if r.proxyExceptions != nil {
		t := *r.proxyExceptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("proxy.exceptions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("proxy.exceptions", parameterToString(t, "multi"))
		}
	}
	if r.proxyExceptionsTypeHint != nil {
		localVarQueryParams.Add("proxy.exceptions@TypeHint", parameterToString(*r.proxyExceptionsTypeHint, ""))
	}
	if r.proxyEnabled != nil {
		localVarQueryParams.Add("proxy.enabled", parameterToString(*r.proxyEnabled, ""))
	}
	if r.proxyEnabledTypeHint != nil {
		localVarQueryParams.Add("proxy.enabled@TypeHint", parameterToString(*r.proxyEnabledTypeHint, ""))
	}
	if r.proxyUser != nil {
		localVarQueryParams.Add("proxy.user", parameterToString(*r.proxyUser, ""))
	}
	if r.proxyUserTypeHint != nil {
		localVarQueryParams.Add("proxy.user@TypeHint", parameterToString(*r.proxyUserTypeHint, ""))
	}
	if r.proxyPassword != nil {
		localVarQueryParams.Add("proxy.password", parameterToString(*r.proxyPassword, ""))
	}
	if r.proxyPasswordTypeHint != nil {
		localVarQueryParams.Add("proxy.password@TypeHint", parameterToString(*r.proxyPasswordTypeHint, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostConfigApacheSlingDavExServletRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	alias *string
	aliasTypeHint *string
	davCreateAbsoluteUri *bool
	davCreateAbsoluteUriTypeHint *string
}

func (r ApiPostConfigApacheSlingDavExServletRequest) Alias(alias string) ApiPostConfigApacheSlingDavExServletRequest {
	r.alias = &alias
	return r
}
func (r ApiPostConfigApacheSlingDavExServletRequest) AliasTypeHint(aliasTypeHint string) ApiPostConfigApacheSlingDavExServletRequest {
	r.aliasTypeHint = &aliasTypeHint
	return r
}
func (r ApiPostConfigApacheSlingDavExServletRequest) DavCreateAbsoluteUri(davCreateAbsoluteUri bool) ApiPostConfigApacheSlingDavExServletRequest {
	r.davCreateAbsoluteUri = &davCreateAbsoluteUri
	return r
}
func (r ApiPostConfigApacheSlingDavExServletRequest) DavCreateAbsoluteUriTypeHint(davCreateAbsoluteUriTypeHint string) ApiPostConfigApacheSlingDavExServletRequest {
	r.davCreateAbsoluteUriTypeHint = &davCreateAbsoluteUriTypeHint
	return r
}

func (r ApiPostConfigApacheSlingDavExServletRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigApacheSlingDavExServletExecute(r)
}

/*
PostConfigApacheSlingDavExServlet Method for PostConfigApacheSlingDavExServlet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConfigApacheSlingDavExServletRequest
*/
func (a *SlingApiService) PostConfigApacheSlingDavExServlet(ctx _context.Context) ApiPostConfigApacheSlingDavExServletRequest {
	return ApiPostConfigApacheSlingDavExServletRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigApacheSlingDavExServletExecute(r ApiPostConfigApacheSlingDavExServletRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigApacheSlingDavExServlet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.alias != nil {
		localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	}
	if r.aliasTypeHint != nil {
		localVarQueryParams.Add("alias@TypeHint", parameterToString(*r.aliasTypeHint, ""))
	}
	if r.davCreateAbsoluteUri != nil {
		localVarQueryParams.Add("dav.create-absolute-uri", parameterToString(*r.davCreateAbsoluteUri, ""))
	}
	if r.davCreateAbsoluteUriTypeHint != nil {
		localVarQueryParams.Add("dav.create-absolute-uri@TypeHint", parameterToString(*r.davCreateAbsoluteUriTypeHint, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostConfigApacheSlingGetServletRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	jsonMaximumresults *string
	jsonMaximumresultsTypeHint *string
	enableHtml *bool
	enableHtmlTypeHint *string
	enableTxt *bool
	enableTxtTypeHint *string
	enableXml *bool
	enableXmlTypeHint *string
}

func (r ApiPostConfigApacheSlingGetServletRequest) JsonMaximumresults(jsonMaximumresults string) ApiPostConfigApacheSlingGetServletRequest {
	r.jsonMaximumresults = &jsonMaximumresults
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) JsonMaximumresultsTypeHint(jsonMaximumresultsTypeHint string) ApiPostConfigApacheSlingGetServletRequest {
	r.jsonMaximumresultsTypeHint = &jsonMaximumresultsTypeHint
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) EnableHtml(enableHtml bool) ApiPostConfigApacheSlingGetServletRequest {
	r.enableHtml = &enableHtml
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) EnableHtmlTypeHint(enableHtmlTypeHint string) ApiPostConfigApacheSlingGetServletRequest {
	r.enableHtmlTypeHint = &enableHtmlTypeHint
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) EnableTxt(enableTxt bool) ApiPostConfigApacheSlingGetServletRequest {
	r.enableTxt = &enableTxt
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) EnableTxtTypeHint(enableTxtTypeHint string) ApiPostConfigApacheSlingGetServletRequest {
	r.enableTxtTypeHint = &enableTxtTypeHint
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) EnableXml(enableXml bool) ApiPostConfigApacheSlingGetServletRequest {
	r.enableXml = &enableXml
	return r
}
func (r ApiPostConfigApacheSlingGetServletRequest) EnableXmlTypeHint(enableXmlTypeHint string) ApiPostConfigApacheSlingGetServletRequest {
	r.enableXmlTypeHint = &enableXmlTypeHint
	return r
}

func (r ApiPostConfigApacheSlingGetServletRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigApacheSlingGetServletExecute(r)
}

/*
PostConfigApacheSlingGetServlet Method for PostConfigApacheSlingGetServlet

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConfigApacheSlingGetServletRequest
*/
func (a *SlingApiService) PostConfigApacheSlingGetServlet(ctx _context.Context) ApiPostConfigApacheSlingGetServletRequest {
	return ApiPostConfigApacheSlingGetServletRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigApacheSlingGetServletExecute(r ApiPostConfigApacheSlingGetServletRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigApacheSlingGetServlet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.jsonMaximumresults != nil {
		localVarQueryParams.Add("json.maximumresults", parameterToString(*r.jsonMaximumresults, ""))
	}
	if r.jsonMaximumresultsTypeHint != nil {
		localVarQueryParams.Add("json.maximumresults@TypeHint", parameterToString(*r.jsonMaximumresultsTypeHint, ""))
	}
	if r.enableHtml != nil {
		localVarQueryParams.Add("enable.html", parameterToString(*r.enableHtml, ""))
	}
	if r.enableHtmlTypeHint != nil {
		localVarQueryParams.Add("enable.html@TypeHint", parameterToString(*r.enableHtmlTypeHint, ""))
	}
	if r.enableTxt != nil {
		localVarQueryParams.Add("enable.txt", parameterToString(*r.enableTxt, ""))
	}
	if r.enableTxtTypeHint != nil {
		localVarQueryParams.Add("enable.txt@TypeHint", parameterToString(*r.enableTxtTypeHint, ""))
	}
	if r.enableXml != nil {
		localVarQueryParams.Add("enable.xml", parameterToString(*r.enableXml, ""))
	}
	if r.enableXmlTypeHint != nil {
		localVarQueryParams.Add("enable.xml@TypeHint", parameterToString(*r.enableXmlTypeHint, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostConfigApacheSlingReferrerFilterRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	allowEmpty *bool
	allowEmptyTypeHint *string
	allowHosts *string
	allowHostsTypeHint *string
	allowHostsRegexp *string
	allowHostsRegexpTypeHint *string
	filterMethods *string
	filterMethodsTypeHint *string
}

func (r ApiPostConfigApacheSlingReferrerFilterRequest) AllowEmpty(allowEmpty bool) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.allowEmpty = &allowEmpty
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) AllowEmptyTypeHint(allowEmptyTypeHint string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.allowEmptyTypeHint = &allowEmptyTypeHint
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) AllowHosts(allowHosts string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.allowHosts = &allowHosts
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) AllowHostsTypeHint(allowHostsTypeHint string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.allowHostsTypeHint = &allowHostsTypeHint
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) AllowHostsRegexp(allowHostsRegexp string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.allowHostsRegexp = &allowHostsRegexp
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) AllowHostsRegexpTypeHint(allowHostsRegexpTypeHint string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.allowHostsRegexpTypeHint = &allowHostsRegexpTypeHint
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) FilterMethods(filterMethods string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.filterMethods = &filterMethods
	return r
}
func (r ApiPostConfigApacheSlingReferrerFilterRequest) FilterMethodsTypeHint(filterMethodsTypeHint string) ApiPostConfigApacheSlingReferrerFilterRequest {
	r.filterMethodsTypeHint = &filterMethodsTypeHint
	return r
}

func (r ApiPostConfigApacheSlingReferrerFilterRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigApacheSlingReferrerFilterExecute(r)
}

/*
PostConfigApacheSlingReferrerFilter Method for PostConfigApacheSlingReferrerFilter

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConfigApacheSlingReferrerFilterRequest
*/
func (a *SlingApiService) PostConfigApacheSlingReferrerFilter(ctx _context.Context) ApiPostConfigApacheSlingReferrerFilterRequest {
	return ApiPostConfigApacheSlingReferrerFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigApacheSlingReferrerFilterExecute(r ApiPostConfigApacheSlingReferrerFilterRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigApacheSlingReferrerFilter")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/org.apache.sling.security.impl.ReferrerFilter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.allowEmpty != nil {
		localVarQueryParams.Add("allow.empty", parameterToString(*r.allowEmpty, ""))
	}
	if r.allowEmptyTypeHint != nil {
		localVarQueryParams.Add("allow.empty@TypeHint", parameterToString(*r.allowEmptyTypeHint, ""))
	}
	if r.allowHosts != nil {
		localVarQueryParams.Add("allow.hosts", parameterToString(*r.allowHosts, ""))
	}
	if r.allowHostsTypeHint != nil {
		localVarQueryParams.Add("allow.hosts@TypeHint", parameterToString(*r.allowHostsTypeHint, ""))
	}
	if r.allowHostsRegexp != nil {
		localVarQueryParams.Add("allow.hosts.regexp", parameterToString(*r.allowHostsRegexp, ""))
	}
	if r.allowHostsRegexpTypeHint != nil {
		localVarQueryParams.Add("allow.hosts.regexp@TypeHint", parameterToString(*r.allowHostsRegexpTypeHint, ""))
	}
	if r.filterMethods != nil {
		localVarQueryParams.Add("filter.methods", parameterToString(*r.filterMethods, ""))
	}
	if r.filterMethodsTypeHint != nil {
		localVarQueryParams.Add("filter.methods@TypeHint", parameterToString(*r.filterMethodsTypeHint, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostConfigPropertyRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	configNodeName string
}


func (r ApiPostConfigPropertyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostConfigPropertyExecute(r)
}

/*
PostConfigProperty Method for PostConfigProperty

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configNodeName
 @return ApiPostConfigPropertyRequest
*/
func (a *SlingApiService) PostConfigProperty(ctx _context.Context, configNodeName string) ApiPostConfigPropertyRequest {
	return ApiPostConfigPropertyRequest{
		ApiService: a,
		ctx: ctx,
		configNodeName: configNodeName,
	}
}

// Execute executes the request
func (a *SlingApiService) PostConfigPropertyExecute(r ApiPostConfigPropertyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostConfigProperty")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apps/system/config/{configNodeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"configNodeName"+"}", _neturl.PathEscape(parameterToString(r.configNodeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostNodeRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path string
	name string
	operation *string
	deleteAuthorizable *string
	file **os.File
}

func (r ApiPostNodeRequest) Operation(operation string) ApiPostNodeRequest {
	r.operation = &operation
	return r
}
func (r ApiPostNodeRequest) DeleteAuthorizable(deleteAuthorizable string) ApiPostNodeRequest {
	r.deleteAuthorizable = &deleteAuthorizable
	return r
}
func (r ApiPostNodeRequest) File(file *os.File) ApiPostNodeRequest {
	r.file = &file
	return r
}

func (r ApiPostNodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostNodeExecute(r)
}

/*
PostNode Method for PostNode

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path
 @param name
 @return ApiPostNodeRequest
*/
func (a *SlingApiService) PostNode(ctx _context.Context, path string, name string) ApiPostNodeRequest {
	return ApiPostNodeRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) PostNodeExecute(r ApiPostNodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostNode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{path}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.operation != nil {
		localVarQueryParams.Add(":operation", parameterToString(*r.operation, ""))
	}
	if r.deleteAuthorizable != nil {
		localVarQueryParams.Add("deleteAuthorizable", parameterToString(*r.deleteAuthorizable, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormFileName = "file"
	var localVarFile *os.File
	if r.file != nil {
		localVarFile = *r.file
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostNodeRwRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path string
	name string
	addMembers *string
}

func (r ApiPostNodeRwRequest) AddMembers(addMembers string) ApiPostNodeRwRequest {
	r.addMembers = &addMembers
	return r
}

func (r ApiPostNodeRwRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostNodeRwExecute(r)
}

/*
PostNodeRw Method for PostNodeRw

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path
 @param name
 @return ApiPostNodeRwRequest
*/
func (a *SlingApiService) PostNodeRw(ctx _context.Context, path string, name string) ApiPostNodeRwRequest {
	return ApiPostNodeRwRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
		name: name,
	}
}

// Execute executes the request
func (a *SlingApiService) PostNodeRwExecute(r ApiPostNodeRwRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostNodeRw")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{path}/{name}.rw.html"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.addMembers != nil {
		localVarQueryParams.Add("addMembers", parameterToString(*r.addMembers, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPathRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path string
	jcrprimaryType *string
	name *string
}

func (r ApiPostPathRequest) JcrprimaryType(jcrprimaryType string) ApiPostPathRequest {
	r.jcrprimaryType = &jcrprimaryType
	return r
}
func (r ApiPostPathRequest) Name(name string) ApiPostPathRequest {
	r.name = &name
	return r
}

func (r ApiPostPathRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostPathExecute(r)
}

/*
PostPath Method for PostPath

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path
 @return ApiPostPathRequest
*/
func (a *SlingApiService) PostPath(ctx _context.Context, path string) ApiPostPathRequest {
	return ApiPostPathRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
	}
}

// Execute executes the request
func (a *SlingApiService) PostPathExecute(r ApiPostPathRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostPath")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{path}/"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.jcrprimaryType == nil {
		return nil, reportError("jcrprimaryType is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("jcr:primaryType", parameterToString(*r.jcrprimaryType, ""))
	localVarQueryParams.Add(":name", parameterToString(*r.name, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostQueryRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	path *string
	pLimit *float32
	var1Property *string
	var1PropertyValue *string
}

func (r ApiPostQueryRequest) Path(path string) ApiPostQueryRequest {
	r.path = &path
	return r
}
func (r ApiPostQueryRequest) PLimit(pLimit float32) ApiPostQueryRequest {
	r.pLimit = &pLimit
	return r
}
func (r ApiPostQueryRequest) Var1Property(var1Property string) ApiPostQueryRequest {
	r.var1Property = &var1Property
	return r
}
func (r ApiPostQueryRequest) Var1PropertyValue(var1PropertyValue string) ApiPostQueryRequest {
	r.var1PropertyValue = &var1PropertyValue
	return r
}

func (r ApiPostQueryRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PostQueryExecute(r)
}

/*
PostQuery Method for PostQuery

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostQueryRequest
*/
func (a *SlingApiService) PostQuery(ctx _context.Context) ApiPostQueryRequest {
	return ApiPostQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) PostQueryExecute(r ApiPostQueryRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostQuery")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bin/querybuilder.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.pLimit == nil {
		return localVarReturnValue, nil, reportError("pLimit is required and must be specified")
	}
	if r.var1Property == nil {
		return localVarReturnValue, nil, reportError("var1Property is required and must be specified")
	}
	if r.var1PropertyValue == nil {
		return localVarReturnValue, nil, reportError("var1PropertyValue is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	localVarQueryParams.Add("p.limit", parameterToString(*r.pLimit, ""))
	localVarQueryParams.Add("1_property", parameterToString(*r.var1Property, ""))
	localVarQueryParams.Add("1_property.value", parameterToString(*r.var1PropertyValue, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTreeActivationRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	ignoredeactivated *bool
	onlymodified *bool
	path *string
}

func (r ApiPostTreeActivationRequest) Ignoredeactivated(ignoredeactivated bool) ApiPostTreeActivationRequest {
	r.ignoredeactivated = &ignoredeactivated
	return r
}
func (r ApiPostTreeActivationRequest) Onlymodified(onlymodified bool) ApiPostTreeActivationRequest {
	r.onlymodified = &onlymodified
	return r
}
func (r ApiPostTreeActivationRequest) Path(path string) ApiPostTreeActivationRequest {
	r.path = &path
	return r
}

func (r ApiPostTreeActivationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostTreeActivationExecute(r)
}

/*
PostTreeActivation Method for PostTreeActivation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTreeActivationRequest
*/
func (a *SlingApiService) PostTreeActivation(ctx _context.Context) ApiPostTreeActivationRequest {
	return ApiPostTreeActivationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SlingApiService) PostTreeActivationExecute(r ApiPostTreeActivationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostTreeActivation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/replication/treeactivation.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ignoredeactivated == nil {
		return nil, reportError("ignoredeactivated is required and must be specified")
	}
	if r.onlymodified == nil {
		return nil, reportError("onlymodified is required and must be specified")
	}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("ignoredeactivated", parameterToString(*r.ignoredeactivated, ""))
	localVarQueryParams.Add("onlymodified", parameterToString(*r.onlymodified, ""))
	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostTruststoreRequest struct {
	ctx _context.Context
	ApiService *SlingApiService
	operation *string
	newPassword *string
	rePassword *string
	keyStoreType *string
	removeAlias *string
	certificate **os.File
}

func (r ApiPostTruststoreRequest) Operation(operation string) ApiPostTruststoreRequest {
	r.operation = &operation
	return r
}
func (r ApiPostTruststoreRequest) NewPassword(newPassword string) ApiPostTruststoreRequest {
	r.newPassword = &newPassword
	return r
}
func (r ApiPostTruststoreRequest) RePassword(rePassword string) ApiPostTruststoreRequest {
	r.rePassword = &rePassword
	return r
}
func (r ApiPostTruststoreRequest) KeyStoreType(keyStoreType string) ApiPostTruststoreRequest {
	r.keyStoreType = &keyStoreType
	return r
}
func (r ApiPostTruststoreRequest) RemoveAlias(removeAlias string) ApiPostTruststoreRequest {
	r.removeAlias = &removeAlias
	return r
}
func (r ApiPostTruststoreRequest) Certificate(certificate *os.File) ApiPostTruststoreRequest {
	r.certificate = &certificate
	return r
}

func (r ApiPostTruststoreRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PostTruststoreExecute(r)
}

/*
PostTruststore Method for PostTruststore

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTruststoreRequest
*/
func (a *SlingApiService) PostTruststore(ctx _context.Context) ApiPostTruststoreRequest {
	return ApiPostTruststoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) PostTruststoreExecute(r ApiPostTruststoreRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostTruststore")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/libs/granite/security/post/truststore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.operation != nil {
		localVarQueryParams.Add(":operation", parameterToString(*r.operation, ""))
	}
	if r.newPassword != nil {
		localVarQueryParams.Add("newPassword", parameterToString(*r.newPassword, ""))
	}
	if r.rePassword != nil {
		localVarQueryParams.Add("rePassword", parameterToString(*r.rePassword, ""))
	}
	if r.keyStoreType != nil {
		localVarQueryParams.Add("keyStoreType", parameterToString(*r.keyStoreType, ""))
	}
	if r.removeAlias != nil {
		localVarQueryParams.Add("removeAlias", parameterToString(*r.removeAlias, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormFileName = "certificate"
	var localVarFile *os.File
	if r.certificate != nil {
		localVarFile = *r.certificate
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTruststorePKCS12Request struct {
	ctx _context.Context
	ApiService *SlingApiService
	truststoreP12 **os.File
}

func (r ApiPostTruststorePKCS12Request) TruststoreP12(truststoreP12 *os.File) ApiPostTruststorePKCS12Request {
	r.truststoreP12 = &truststoreP12
	return r
}

func (r ApiPostTruststorePKCS12Request) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.PostTruststorePKCS12Execute(r)
}

/*
PostTruststorePKCS12 Method for PostTruststorePKCS12

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTruststorePKCS12Request
*/
func (a *SlingApiService) PostTruststorePKCS12(ctx _context.Context) ApiPostTruststorePKCS12Request {
	return ApiPostTruststorePKCS12Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *SlingApiService) PostTruststorePKCS12Execute(r ApiPostTruststorePKCS12Request) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlingApiService.PostTruststorePKCS12")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/etc/truststore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormFileName = "truststore.p12"
	var localVarFile *os.File
	if r.truststoreP12 != nil {
		localVarFile = *r.truststoreP12
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
