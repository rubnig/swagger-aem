/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { KeystoreInfo } from '../model/keystoreInfo';
import { TruststoreInfo } from '../model/truststoreInfo';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum SlingApiApiKeys {
}

export class SlingApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'aemAuth': new HttpBasicAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: SlingApiApiKeys, value: string) {
        (this.authentications as any)[SlingApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications.aemAuth.username = username;
    }

    set password(password: string) {
        this.authentications.aemAuth.password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @param runmode 
     * @param name 
     */
    public async deleteAgent (runmode: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     */
    public async deleteNode (path: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param runmode 
     * @param name 
     */
    public async getAgent (runmode: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param runmode 
     */
    public async getAgents (runmode: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}.-1.json'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public async getAuthorizableKeystore (intermediatePath: string, authorizableId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: KeystoreInfo;  }> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.json'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: KeystoreInfo;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "KeystoreInfo");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     */
    public async getKeystore (intermediatePath: string, authorizableId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RequestFile;  }> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}/keystore/store.p12'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RequestFile;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RequestFile");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     */
    public async getNode (path: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public async getPackage (group: string, name: string, version: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RequestFile;  }> {
        const localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RequestFile;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RequestFile");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param group 
     * @param name 
     * @param version 
     */
    public async getPackageFilter (group: string, name: string, version: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public async getQuery (path: string, pLimit: number, _1property: string, _1propertyValue: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/bin/querybuilder.json';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        if (pLimit !== undefined) {
            localVarQueryParameters['p.limit'] = ObjectSerializer.serialize(pLimit, "number");
        }

        if (_1property !== undefined) {
            localVarQueryParameters['1_property'] = ObjectSerializer.serialize(_1property, "string");
        }

        if (_1propertyValue !== undefined) {
            localVarQueryParameters['1_property.value'] = ObjectSerializer.serialize(_1propertyValue, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     */
    public async getTruststore (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RequestFile;  }> {
        const localVarPath = this.basePath + '/etc/truststore/truststore.p12';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RequestFile;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RequestFile");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     */
    public async getTruststoreInfo (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TruststoreInfo;  }> {
        const localVarPath = this.basePath + '/libs/granite/security/truststore.json';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TruststoreInfo;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TruststoreInfo");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param runmode 
     * @param name 
     * @param jcrcontentCqdistribute 
     * @param jcrcontentCqdistributeTypeHint 
     * @param jcrcontentCqname 
     * @param jcrcontentCqtemplate 
     * @param jcrcontentEnabled 
     * @param jcrcontentJcrdescription 
     * @param jcrcontentJcrlastModified 
     * @param jcrcontentJcrlastModifiedBy 
     * @param jcrcontentJcrmixinTypes 
     * @param jcrcontentJcrtitle 
     * @param jcrcontentLogLevel 
     * @param jcrcontentNoStatusUpdate 
     * @param jcrcontentNoVersioning 
     * @param jcrcontentProtocolConnectTimeout 
     * @param jcrcontentProtocolHTTPConnectionClosed 
     * @param jcrcontentProtocolHTTPExpired 
     * @param jcrcontentProtocolHTTPHeaders 
     * @param jcrcontentProtocolHTTPHeadersTypeHint 
     * @param jcrcontentProtocolHTTPMethod 
     * @param jcrcontentProtocolHTTPSRelaxed 
     * @param jcrcontentProtocolInterface 
     * @param jcrcontentProtocolSocketTimeout 
     * @param jcrcontentProtocolVersion 
     * @param jcrcontentProxyNTLMDomain 
     * @param jcrcontentProxyNTLMHost 
     * @param jcrcontentProxyHost 
     * @param jcrcontentProxyPassword 
     * @param jcrcontentProxyPort 
     * @param jcrcontentProxyUser 
     * @param jcrcontentQueueBatchMaxSize 
     * @param jcrcontentQueueBatchMode 
     * @param jcrcontentQueueBatchWaitTime 
     * @param jcrcontentRetryDelay 
     * @param jcrcontentReverseReplication 
     * @param jcrcontentSerializationType 
     * @param jcrcontentSlingresourceType 
     * @param jcrcontentSsl 
     * @param jcrcontentTransportNTLMDomain 
     * @param jcrcontentTransportNTLMHost 
     * @param jcrcontentTransportPassword 
     * @param jcrcontentTransportUri 
     * @param jcrcontentTransportUser 
     * @param jcrcontentTriggerDistribute 
     * @param jcrcontentTriggerModified 
     * @param jcrcontentTriggerOnOffTime 
     * @param jcrcontentTriggerReceive 
     * @param jcrcontentTriggerSpecific 
     * @param jcrcontentUserId 
     * @param jcrprimaryType 
     * @param operation 
     */
    public async postAgent (runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/agents.{runmode}/{name}'
            .replace('{' + 'runmode' + '}', encodeURIComponent(String(runmode)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'runmode' is not null or undefined
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        if (jcrcontentCqdistribute !== undefined) {
            localVarQueryParameters['jcr:content/cq:distribute'] = ObjectSerializer.serialize(jcrcontentCqdistribute, "boolean");
        }

        if (jcrcontentCqdistributeTypeHint !== undefined) {
            localVarQueryParameters['jcr:content/cq:distribute@TypeHint'] = ObjectSerializer.serialize(jcrcontentCqdistributeTypeHint, "string");
        }

        if (jcrcontentCqname !== undefined) {
            localVarQueryParameters['jcr:content/cq:name'] = ObjectSerializer.serialize(jcrcontentCqname, "string");
        }

        if (jcrcontentCqtemplate !== undefined) {
            localVarQueryParameters['jcr:content/cq:template'] = ObjectSerializer.serialize(jcrcontentCqtemplate, "string");
        }

        if (jcrcontentEnabled !== undefined) {
            localVarQueryParameters['jcr:content/enabled'] = ObjectSerializer.serialize(jcrcontentEnabled, "boolean");
        }

        if (jcrcontentJcrdescription !== undefined) {
            localVarQueryParameters['jcr:content/jcr:description'] = ObjectSerializer.serialize(jcrcontentJcrdescription, "string");
        }

        if (jcrcontentJcrlastModified !== undefined) {
            localVarQueryParameters['jcr:content/jcr:lastModified'] = ObjectSerializer.serialize(jcrcontentJcrlastModified, "string");
        }

        if (jcrcontentJcrlastModifiedBy !== undefined) {
            localVarQueryParameters['jcr:content/jcr:lastModifiedBy'] = ObjectSerializer.serialize(jcrcontentJcrlastModifiedBy, "string");
        }

        if (jcrcontentJcrmixinTypes !== undefined) {
            localVarQueryParameters['jcr:content/jcr:mixinTypes'] = ObjectSerializer.serialize(jcrcontentJcrmixinTypes, "string");
        }

        if (jcrcontentJcrtitle !== undefined) {
            localVarQueryParameters['jcr:content/jcr:title'] = ObjectSerializer.serialize(jcrcontentJcrtitle, "string");
        }

        if (jcrcontentLogLevel !== undefined) {
            localVarQueryParameters['jcr:content/logLevel'] = ObjectSerializer.serialize(jcrcontentLogLevel, "string");
        }

        if (jcrcontentNoStatusUpdate !== undefined) {
            localVarQueryParameters['jcr:content/noStatusUpdate'] = ObjectSerializer.serialize(jcrcontentNoStatusUpdate, "boolean");
        }

        if (jcrcontentNoVersioning !== undefined) {
            localVarQueryParameters['jcr:content/noVersioning'] = ObjectSerializer.serialize(jcrcontentNoVersioning, "boolean");
        }

        if (jcrcontentProtocolConnectTimeout !== undefined) {
            localVarQueryParameters['jcr:content/protocolConnectTimeout'] = ObjectSerializer.serialize(jcrcontentProtocolConnectTimeout, "number");
        }

        if (jcrcontentProtocolHTTPConnectionClosed !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPConnectionClosed'] = ObjectSerializer.serialize(jcrcontentProtocolHTTPConnectionClosed, "boolean");
        }

        if (jcrcontentProtocolHTTPExpired !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPExpired'] = ObjectSerializer.serialize(jcrcontentProtocolHTTPExpired, "string");
        }

        if (jcrcontentProtocolHTTPHeaders !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPHeaders'] = ObjectSerializer.serialize(jcrcontentProtocolHTTPHeaders, "Array<string>");
        }

        if (jcrcontentProtocolHTTPHeadersTypeHint !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPHeaders@TypeHint'] = ObjectSerializer.serialize(jcrcontentProtocolHTTPHeadersTypeHint, "string");
        }

        if (jcrcontentProtocolHTTPMethod !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPMethod'] = ObjectSerializer.serialize(jcrcontentProtocolHTTPMethod, "string");
        }

        if (jcrcontentProtocolHTTPSRelaxed !== undefined) {
            localVarQueryParameters['jcr:content/protocolHTTPSRelaxed'] = ObjectSerializer.serialize(jcrcontentProtocolHTTPSRelaxed, "boolean");
        }

        if (jcrcontentProtocolInterface !== undefined) {
            localVarQueryParameters['jcr:content/protocolInterface'] = ObjectSerializer.serialize(jcrcontentProtocolInterface, "string");
        }

        if (jcrcontentProtocolSocketTimeout !== undefined) {
            localVarQueryParameters['jcr:content/protocolSocketTimeout'] = ObjectSerializer.serialize(jcrcontentProtocolSocketTimeout, "number");
        }

        if (jcrcontentProtocolVersion !== undefined) {
            localVarQueryParameters['jcr:content/protocolVersion'] = ObjectSerializer.serialize(jcrcontentProtocolVersion, "string");
        }

        if (jcrcontentProxyNTLMDomain !== undefined) {
            localVarQueryParameters['jcr:content/proxyNTLMDomain'] = ObjectSerializer.serialize(jcrcontentProxyNTLMDomain, "string");
        }

        if (jcrcontentProxyNTLMHost !== undefined) {
            localVarQueryParameters['jcr:content/proxyNTLMHost'] = ObjectSerializer.serialize(jcrcontentProxyNTLMHost, "string");
        }

        if (jcrcontentProxyHost !== undefined) {
            localVarQueryParameters['jcr:content/proxyHost'] = ObjectSerializer.serialize(jcrcontentProxyHost, "string");
        }

        if (jcrcontentProxyPassword !== undefined) {
            localVarQueryParameters['jcr:content/proxyPassword'] = ObjectSerializer.serialize(jcrcontentProxyPassword, "string");
        }

        if (jcrcontentProxyPort !== undefined) {
            localVarQueryParameters['jcr:content/proxyPort'] = ObjectSerializer.serialize(jcrcontentProxyPort, "number");
        }

        if (jcrcontentProxyUser !== undefined) {
            localVarQueryParameters['jcr:content/proxyUser'] = ObjectSerializer.serialize(jcrcontentProxyUser, "string");
        }

        if (jcrcontentQueueBatchMaxSize !== undefined) {
            localVarQueryParameters['jcr:content/queueBatchMaxSize'] = ObjectSerializer.serialize(jcrcontentQueueBatchMaxSize, "number");
        }

        if (jcrcontentQueueBatchMode !== undefined) {
            localVarQueryParameters['jcr:content/queueBatchMode'] = ObjectSerializer.serialize(jcrcontentQueueBatchMode, "string");
        }

        if (jcrcontentQueueBatchWaitTime !== undefined) {
            localVarQueryParameters['jcr:content/queueBatchWaitTime'] = ObjectSerializer.serialize(jcrcontentQueueBatchWaitTime, "number");
        }

        if (jcrcontentRetryDelay !== undefined) {
            localVarQueryParameters['jcr:content/retryDelay'] = ObjectSerializer.serialize(jcrcontentRetryDelay, "string");
        }

        if (jcrcontentReverseReplication !== undefined) {
            localVarQueryParameters['jcr:content/reverseReplication'] = ObjectSerializer.serialize(jcrcontentReverseReplication, "boolean");
        }

        if (jcrcontentSerializationType !== undefined) {
            localVarQueryParameters['jcr:content/serializationType'] = ObjectSerializer.serialize(jcrcontentSerializationType, "string");
        }

        if (jcrcontentSlingresourceType !== undefined) {
            localVarQueryParameters['jcr:content/sling:resourceType'] = ObjectSerializer.serialize(jcrcontentSlingresourceType, "string");
        }

        if (jcrcontentSsl !== undefined) {
            localVarQueryParameters['jcr:content/ssl'] = ObjectSerializer.serialize(jcrcontentSsl, "string");
        }

        if (jcrcontentTransportNTLMDomain !== undefined) {
            localVarQueryParameters['jcr:content/transportNTLMDomain'] = ObjectSerializer.serialize(jcrcontentTransportNTLMDomain, "string");
        }

        if (jcrcontentTransportNTLMHost !== undefined) {
            localVarQueryParameters['jcr:content/transportNTLMHost'] = ObjectSerializer.serialize(jcrcontentTransportNTLMHost, "string");
        }

        if (jcrcontentTransportPassword !== undefined) {
            localVarQueryParameters['jcr:content/transportPassword'] = ObjectSerializer.serialize(jcrcontentTransportPassword, "string");
        }

        if (jcrcontentTransportUri !== undefined) {
            localVarQueryParameters['jcr:content/transportUri'] = ObjectSerializer.serialize(jcrcontentTransportUri, "string");
        }

        if (jcrcontentTransportUser !== undefined) {
            localVarQueryParameters['jcr:content/transportUser'] = ObjectSerializer.serialize(jcrcontentTransportUser, "string");
        }

        if (jcrcontentTriggerDistribute !== undefined) {
            localVarQueryParameters['jcr:content/triggerDistribute'] = ObjectSerializer.serialize(jcrcontentTriggerDistribute, "boolean");
        }

        if (jcrcontentTriggerModified !== undefined) {
            localVarQueryParameters['jcr:content/triggerModified'] = ObjectSerializer.serialize(jcrcontentTriggerModified, "boolean");
        }

        if (jcrcontentTriggerOnOffTime !== undefined) {
            localVarQueryParameters['jcr:content/triggerOnOffTime'] = ObjectSerializer.serialize(jcrcontentTriggerOnOffTime, "boolean");
        }

        if (jcrcontentTriggerReceive !== undefined) {
            localVarQueryParameters['jcr:content/triggerReceive'] = ObjectSerializer.serialize(jcrcontentTriggerReceive, "boolean");
        }

        if (jcrcontentTriggerSpecific !== undefined) {
            localVarQueryParameters['jcr:content/triggerSpecific'] = ObjectSerializer.serialize(jcrcontentTriggerSpecific, "boolean");
        }

        if (jcrcontentUserId !== undefined) {
            localVarQueryParameters['jcr:content/userId'] = ObjectSerializer.serialize(jcrcontentUserId, "string");
        }

        if (jcrprimaryType !== undefined) {
            localVarQueryParameters['jcr:primaryType'] = ObjectSerializer.serialize(jcrprimaryType, "string");
        }

        if (operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(operation, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param intermediatePath 
     * @param authorizableId 
     * @param operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     */
    public async postAuthorizableKeystore (intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: RequestFile, pk?: RequestFile, keyStore?: RequestFile, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: KeystoreInfo;  }> {
        const localVarPath = this.basePath + '/{intermediatePath}/{authorizableId}.ks.html'
            .replace('{' + 'intermediatePath' + '}', encodeURIComponent(String(intermediatePath)))
            .replace('{' + 'authorizableId' + '}', encodeURIComponent(String(authorizableId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        if (operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(operation, "string");
        }

        if (currentPassword !== undefined) {
            localVarQueryParameters['currentPassword'] = ObjectSerializer.serialize(currentPassword, "string");
        }

        if (newPassword !== undefined) {
            localVarQueryParameters['newPassword'] = ObjectSerializer.serialize(newPassword, "string");
        }

        if (rePassword !== undefined) {
            localVarQueryParameters['rePassword'] = ObjectSerializer.serialize(rePassword, "string");
        }

        if (keyPassword !== undefined) {
            localVarQueryParameters['keyPassword'] = ObjectSerializer.serialize(keyPassword, "string");
        }

        if (keyStorePass !== undefined) {
            localVarQueryParameters['keyStorePass'] = ObjectSerializer.serialize(keyStorePass, "string");
        }

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (newAlias !== undefined) {
            localVarQueryParameters['newAlias'] = ObjectSerializer.serialize(newAlias, "string");
        }

        if (removeAlias !== undefined) {
            localVarQueryParameters['removeAlias'] = ObjectSerializer.serialize(removeAlias, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (certChain !== undefined) {
            localVarFormParams['cert-chain'] = certChain;
        }
        localVarUseFormData = true;

        if (pk !== undefined) {
            localVarFormParams['pk'] = pk;
        }
        localVarUseFormData = true;

        if (keyStore !== undefined) {
            localVarFormParams['keyStore'] = keyStore;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: KeystoreInfo;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "KeystoreInfo");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param reppassword 
     * @param profileGivenName 
     */
    public async postAuthorizables (authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/libs/granite/security/post/authorizables';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/html'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'authorizableId' is not null or undefined
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }

        // verify required parameter 'intermediatePath' is not null or undefined
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        if (authorizableId !== undefined) {
            localVarQueryParameters['authorizableId'] = ObjectSerializer.serialize(authorizableId, "string");
        }

        if (intermediatePath !== undefined) {
            localVarQueryParameters['intermediatePath'] = ObjectSerializer.serialize(intermediatePath, "string");
        }

        if (createUser !== undefined) {
            localVarQueryParameters['createUser'] = ObjectSerializer.serialize(createUser, "string");
        }

        if (createGroup !== undefined) {
            localVarQueryParameters['createGroup'] = ObjectSerializer.serialize(createGroup, "string");
        }

        if (reppassword !== undefined) {
            localVarQueryParameters['rep:password'] = ObjectSerializer.serialize(reppassword, "string");
        }

        if (profileGivenName !== undefined) {
            localVarQueryParameters['profile/givenName'] = ObjectSerializer.serialize(profileGivenName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param keyStorePassword 
     * @param keyStorePasswordTypeHint 
     * @param serviceRanking 
     * @param serviceRankingTypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirectTypeHint 
     * @param createUser 
     * @param createUserTypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrlTypeHint 
     * @param userIDAttribute 
     * @param userIDAttributeTypeHint 
     * @param defaultGroups 
     * @param defaultGroupsTypeHint 
     * @param idpCertAlias 
     * @param idpCertAliasTypeHint 
     * @param addGroupMemberships 
     * @param addGroupMembershipsTypeHint 
     * @param path 
     * @param pathTypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributesTypeHint 
     * @param clockTolerance 
     * @param clockToleranceTypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttributeTypeHint 
     * @param idpUrl 
     * @param idpUrlTypeHint 
     * @param logoutUrl 
     * @param logoutUrlTypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityIdTypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURLTypeHint 
     * @param handleLogout 
     * @param handleLogoutTypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAliasTypeHint 
     * @param useEncryption 
     * @param useEncryptionTypeHint 
     * @param nameIdFormat 
     * @param nameIdFormatTypeHint 
     * @param digestMethod 
     * @param digestMethodTypeHint 
     * @param signatureMethod 
     * @param signatureMethodTypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePathTypeHint 
     */
    public async postConfigAdobeGraniteSamlAuthenticationHandler (keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (keyStorePassword !== undefined) {
            localVarQueryParameters['keyStorePassword'] = ObjectSerializer.serialize(keyStorePassword, "string");
        }

        if (keyStorePasswordTypeHint !== undefined) {
            localVarQueryParameters['keyStorePassword@TypeHint'] = ObjectSerializer.serialize(keyStorePasswordTypeHint, "string");
        }

        if (serviceRanking !== undefined) {
            localVarQueryParameters['service.ranking'] = ObjectSerializer.serialize(serviceRanking, "number");
        }

        if (serviceRankingTypeHint !== undefined) {
            localVarQueryParameters['service.ranking@TypeHint'] = ObjectSerializer.serialize(serviceRankingTypeHint, "string");
        }

        if (idpHttpRedirect !== undefined) {
            localVarQueryParameters['idpHttpRedirect'] = ObjectSerializer.serialize(idpHttpRedirect, "boolean");
        }

        if (idpHttpRedirectTypeHint !== undefined) {
            localVarQueryParameters['idpHttpRedirect@TypeHint'] = ObjectSerializer.serialize(idpHttpRedirectTypeHint, "string");
        }

        if (createUser !== undefined) {
            localVarQueryParameters['createUser'] = ObjectSerializer.serialize(createUser, "boolean");
        }

        if (createUserTypeHint !== undefined) {
            localVarQueryParameters['createUser@TypeHint'] = ObjectSerializer.serialize(createUserTypeHint, "string");
        }

        if (defaultRedirectUrl !== undefined) {
            localVarQueryParameters['defaultRedirectUrl'] = ObjectSerializer.serialize(defaultRedirectUrl, "string");
        }

        if (defaultRedirectUrlTypeHint !== undefined) {
            localVarQueryParameters['defaultRedirectUrl@TypeHint'] = ObjectSerializer.serialize(defaultRedirectUrlTypeHint, "string");
        }

        if (userIDAttribute !== undefined) {
            localVarQueryParameters['userIDAttribute'] = ObjectSerializer.serialize(userIDAttribute, "string");
        }

        if (userIDAttributeTypeHint !== undefined) {
            localVarQueryParameters['userIDAttribute@TypeHint'] = ObjectSerializer.serialize(userIDAttributeTypeHint, "string");
        }

        if (defaultGroups !== undefined) {
            localVarQueryParameters['defaultGroups'] = ObjectSerializer.serialize(defaultGroups, "Array<string>");
        }

        if (defaultGroupsTypeHint !== undefined) {
            localVarQueryParameters['defaultGroups@TypeHint'] = ObjectSerializer.serialize(defaultGroupsTypeHint, "string");
        }

        if (idpCertAlias !== undefined) {
            localVarQueryParameters['idpCertAlias'] = ObjectSerializer.serialize(idpCertAlias, "string");
        }

        if (idpCertAliasTypeHint !== undefined) {
            localVarQueryParameters['idpCertAlias@TypeHint'] = ObjectSerializer.serialize(idpCertAliasTypeHint, "string");
        }

        if (addGroupMemberships !== undefined) {
            localVarQueryParameters['addGroupMemberships'] = ObjectSerializer.serialize(addGroupMemberships, "boolean");
        }

        if (addGroupMembershipsTypeHint !== undefined) {
            localVarQueryParameters['addGroupMemberships@TypeHint'] = ObjectSerializer.serialize(addGroupMembershipsTypeHint, "string");
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "Array<string>");
        }

        if (pathTypeHint !== undefined) {
            localVarQueryParameters['path@TypeHint'] = ObjectSerializer.serialize(pathTypeHint, "string");
        }

        if (synchronizeAttributes !== undefined) {
            localVarQueryParameters['synchronizeAttributes'] = ObjectSerializer.serialize(synchronizeAttributes, "Array<string>");
        }

        if (synchronizeAttributesTypeHint !== undefined) {
            localVarQueryParameters['synchronizeAttributes@TypeHint'] = ObjectSerializer.serialize(synchronizeAttributesTypeHint, "string");
        }

        if (clockTolerance !== undefined) {
            localVarQueryParameters['clockTolerance'] = ObjectSerializer.serialize(clockTolerance, "number");
        }

        if (clockToleranceTypeHint !== undefined) {
            localVarQueryParameters['clockTolerance@TypeHint'] = ObjectSerializer.serialize(clockToleranceTypeHint, "string");
        }

        if (groupMembershipAttribute !== undefined) {
            localVarQueryParameters['groupMembershipAttribute'] = ObjectSerializer.serialize(groupMembershipAttribute, "string");
        }

        if (groupMembershipAttributeTypeHint !== undefined) {
            localVarQueryParameters['groupMembershipAttribute@TypeHint'] = ObjectSerializer.serialize(groupMembershipAttributeTypeHint, "string");
        }

        if (idpUrl !== undefined) {
            localVarQueryParameters['idpUrl'] = ObjectSerializer.serialize(idpUrl, "string");
        }

        if (idpUrlTypeHint !== undefined) {
            localVarQueryParameters['idpUrl@TypeHint'] = ObjectSerializer.serialize(idpUrlTypeHint, "string");
        }

        if (logoutUrl !== undefined) {
            localVarQueryParameters['logoutUrl'] = ObjectSerializer.serialize(logoutUrl, "string");
        }

        if (logoutUrlTypeHint !== undefined) {
            localVarQueryParameters['logoutUrl@TypeHint'] = ObjectSerializer.serialize(logoutUrlTypeHint, "string");
        }

        if (serviceProviderEntityId !== undefined) {
            localVarQueryParameters['serviceProviderEntityId'] = ObjectSerializer.serialize(serviceProviderEntityId, "string");
        }

        if (serviceProviderEntityIdTypeHint !== undefined) {
            localVarQueryParameters['serviceProviderEntityId@TypeHint'] = ObjectSerializer.serialize(serviceProviderEntityIdTypeHint, "string");
        }

        if (assertionConsumerServiceURL !== undefined) {
            localVarQueryParameters['assertionConsumerServiceURL'] = ObjectSerializer.serialize(assertionConsumerServiceURL, "string");
        }

        if (assertionConsumerServiceURLTypeHint !== undefined) {
            localVarQueryParameters['assertionConsumerServiceURL@TypeHint'] = ObjectSerializer.serialize(assertionConsumerServiceURLTypeHint, "string");
        }

        if (handleLogout !== undefined) {
            localVarQueryParameters['handleLogout'] = ObjectSerializer.serialize(handleLogout, "boolean");
        }

        if (handleLogoutTypeHint !== undefined) {
            localVarQueryParameters['handleLogout@TypeHint'] = ObjectSerializer.serialize(handleLogoutTypeHint, "string");
        }

        if (spPrivateKeyAlias !== undefined) {
            localVarQueryParameters['spPrivateKeyAlias'] = ObjectSerializer.serialize(spPrivateKeyAlias, "string");
        }

        if (spPrivateKeyAliasTypeHint !== undefined) {
            localVarQueryParameters['spPrivateKeyAlias@TypeHint'] = ObjectSerializer.serialize(spPrivateKeyAliasTypeHint, "string");
        }

        if (useEncryption !== undefined) {
            localVarQueryParameters['useEncryption'] = ObjectSerializer.serialize(useEncryption, "boolean");
        }

        if (useEncryptionTypeHint !== undefined) {
            localVarQueryParameters['useEncryption@TypeHint'] = ObjectSerializer.serialize(useEncryptionTypeHint, "string");
        }

        if (nameIdFormat !== undefined) {
            localVarQueryParameters['nameIdFormat'] = ObjectSerializer.serialize(nameIdFormat, "string");
        }

        if (nameIdFormatTypeHint !== undefined) {
            localVarQueryParameters['nameIdFormat@TypeHint'] = ObjectSerializer.serialize(nameIdFormatTypeHint, "string");
        }

        if (digestMethod !== undefined) {
            localVarQueryParameters['digestMethod'] = ObjectSerializer.serialize(digestMethod, "string");
        }

        if (digestMethodTypeHint !== undefined) {
            localVarQueryParameters['digestMethod@TypeHint'] = ObjectSerializer.serialize(digestMethodTypeHint, "string");
        }

        if (signatureMethod !== undefined) {
            localVarQueryParameters['signatureMethod'] = ObjectSerializer.serialize(signatureMethod, "string");
        }

        if (signatureMethodTypeHint !== undefined) {
            localVarQueryParameters['signatureMethod@TypeHint'] = ObjectSerializer.serialize(signatureMethodTypeHint, "string");
        }

        if (userIntermediatePath !== undefined) {
            localVarQueryParameters['userIntermediatePath'] = ObjectSerializer.serialize(userIntermediatePath, "string");
        }

        if (userIntermediatePathTypeHint !== undefined) {
            localVarQueryParameters['userIntermediatePath@TypeHint'] = ObjectSerializer.serialize(userIntermediatePathTypeHint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNioTypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystoreTypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePasswordTypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKeyTypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPasswordTypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststoreTypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePasswordTypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificateTypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnableTypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecureTypeHint 
     */
    public async postConfigApacheFelixJettyBasedHttpService (orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.felix.http';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (orgApacheFelixHttpsNio !== undefined) {
            localVarQueryParameters['org.apache.felix.https.nio'] = ObjectSerializer.serialize(orgApacheFelixHttpsNio, "boolean");
        }

        if (orgApacheFelixHttpsNioTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.nio@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsNioTypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystore !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystore, "string");
        }

        if (orgApacheFelixHttpsKeystoreTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreTypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystorePassword !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.password'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystorePassword, "string");
        }

        if (orgApacheFelixHttpsKeystorePasswordTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.password@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystorePasswordTypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystoreKey !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKey, "string");
        }

        if (orgApacheFelixHttpsKeystoreKeyTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKeyTypeHint, "string");
        }

        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key.password'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKeyPassword, "string");
        }

        if (orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.keystore.key.password@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, "string");
        }

        if (orgApacheFelixHttpsTruststore !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststore, "string");
        }

        if (orgApacheFelixHttpsTruststoreTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststoreTypeHint, "string");
        }

        if (orgApacheFelixHttpsTruststorePassword !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore.password'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststorePassword, "string");
        }

        if (orgApacheFelixHttpsTruststorePasswordTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.truststore.password@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsTruststorePasswordTypeHint, "string");
        }

        if (orgApacheFelixHttpsClientcertificate !== undefined) {
            localVarQueryParameters['org.apache.felix.https.clientcertificate'] = ObjectSerializer.serialize(orgApacheFelixHttpsClientcertificate, "string");
        }

        if (orgApacheFelixHttpsClientcertificateTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.clientcertificate@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsClientcertificateTypeHint, "string");
        }

        if (orgApacheFelixHttpsEnable !== undefined) {
            localVarQueryParameters['org.apache.felix.https.enable'] = ObjectSerializer.serialize(orgApacheFelixHttpsEnable, "boolean");
        }

        if (orgApacheFelixHttpsEnableTypeHint !== undefined) {
            localVarQueryParameters['org.apache.felix.https.enable@TypeHint'] = ObjectSerializer.serialize(orgApacheFelixHttpsEnableTypeHint, "string");
        }

        if (orgOsgiServiceHttpPortSecure !== undefined) {
            localVarQueryParameters['org.osgi.service.http.port.secure'] = ObjectSerializer.serialize(orgOsgiServiceHttpPortSecure, "string");
        }

        if (orgOsgiServiceHttpPortSecureTypeHint !== undefined) {
            localVarQueryParameters['org.osgi.service.http.port.secure@TypeHint'] = ObjectSerializer.serialize(orgOsgiServiceHttpPortSecureTypeHint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param proxyHost 
     * @param proxyHostTypeHint 
     * @param proxyPort 
     * @param proxyPortTypeHint 
     * @param proxyExceptions 
     * @param proxyExceptionsTypeHint 
     * @param proxyEnabled 
     * @param proxyEnabledTypeHint 
     * @param proxyUser 
     * @param proxyUserTypeHint 
     * @param proxyPassword 
     * @param proxyPasswordTypeHint 
     */
    public async postConfigApacheHttpComponentsProxyConfiguration (proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.http.proxyconfigurator.config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (proxyHost !== undefined) {
            localVarQueryParameters['proxy.host'] = ObjectSerializer.serialize(proxyHost, "string");
        }

        if (proxyHostTypeHint !== undefined) {
            localVarQueryParameters['proxy.host@TypeHint'] = ObjectSerializer.serialize(proxyHostTypeHint, "string");
        }

        if (proxyPort !== undefined) {
            localVarQueryParameters['proxy.port'] = ObjectSerializer.serialize(proxyPort, "number");
        }

        if (proxyPortTypeHint !== undefined) {
            localVarQueryParameters['proxy.port@TypeHint'] = ObjectSerializer.serialize(proxyPortTypeHint, "string");
        }

        if (proxyExceptions !== undefined) {
            localVarQueryParameters['proxy.exceptions'] = ObjectSerializer.serialize(proxyExceptions, "Array<string>");
        }

        if (proxyExceptionsTypeHint !== undefined) {
            localVarQueryParameters['proxy.exceptions@TypeHint'] = ObjectSerializer.serialize(proxyExceptionsTypeHint, "string");
        }

        if (proxyEnabled !== undefined) {
            localVarQueryParameters['proxy.enabled'] = ObjectSerializer.serialize(proxyEnabled, "boolean");
        }

        if (proxyEnabledTypeHint !== undefined) {
            localVarQueryParameters['proxy.enabled@TypeHint'] = ObjectSerializer.serialize(proxyEnabledTypeHint, "string");
        }

        if (proxyUser !== undefined) {
            localVarQueryParameters['proxy.user'] = ObjectSerializer.serialize(proxyUser, "string");
        }

        if (proxyUserTypeHint !== undefined) {
            localVarQueryParameters['proxy.user@TypeHint'] = ObjectSerializer.serialize(proxyUserTypeHint, "string");
        }

        if (proxyPassword !== undefined) {
            localVarQueryParameters['proxy.password'] = ObjectSerializer.serialize(proxyPassword, "string");
        }

        if (proxyPasswordTypeHint !== undefined) {
            localVarQueryParameters['proxy.password@TypeHint'] = ObjectSerializer.serialize(proxyPasswordTypeHint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param alias 
     * @param aliasTypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUriTypeHint 
     */
    public async postConfigApacheSlingDavExServlet (alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (aliasTypeHint !== undefined) {
            localVarQueryParameters['alias@TypeHint'] = ObjectSerializer.serialize(aliasTypeHint, "string");
        }

        if (davCreateAbsoluteUri !== undefined) {
            localVarQueryParameters['dav.create-absolute-uri'] = ObjectSerializer.serialize(davCreateAbsoluteUri, "boolean");
        }

        if (davCreateAbsoluteUriTypeHint !== undefined) {
            localVarQueryParameters['dav.create-absolute-uri@TypeHint'] = ObjectSerializer.serialize(davCreateAbsoluteUriTypeHint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param jsonMaximumresults 
     * @param jsonMaximumresultsTypeHint 
     * @param enableHtml 
     * @param enableHtmlTypeHint 
     * @param enableTxt 
     * @param enableTxtTypeHint 
     * @param enableXml 
     * @param enableXmlTypeHint 
     */
    public async postConfigApacheSlingGetServlet (jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (jsonMaximumresults !== undefined) {
            localVarQueryParameters['json.maximumresults'] = ObjectSerializer.serialize(jsonMaximumresults, "string");
        }

        if (jsonMaximumresultsTypeHint !== undefined) {
            localVarQueryParameters['json.maximumresults@TypeHint'] = ObjectSerializer.serialize(jsonMaximumresultsTypeHint, "string");
        }

        if (enableHtml !== undefined) {
            localVarQueryParameters['enable.html'] = ObjectSerializer.serialize(enableHtml, "boolean");
        }

        if (enableHtmlTypeHint !== undefined) {
            localVarQueryParameters['enable.html@TypeHint'] = ObjectSerializer.serialize(enableHtmlTypeHint, "string");
        }

        if (enableTxt !== undefined) {
            localVarQueryParameters['enable.txt'] = ObjectSerializer.serialize(enableTxt, "boolean");
        }

        if (enableTxtTypeHint !== undefined) {
            localVarQueryParameters['enable.txt@TypeHint'] = ObjectSerializer.serialize(enableTxtTypeHint, "string");
        }

        if (enableXml !== undefined) {
            localVarQueryParameters['enable.xml'] = ObjectSerializer.serialize(enableXml, "boolean");
        }

        if (enableXmlTypeHint !== undefined) {
            localVarQueryParameters['enable.xml@TypeHint'] = ObjectSerializer.serialize(enableXmlTypeHint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param allowEmpty 
     * @param allowEmptyTypeHint 
     * @param allowHosts 
     * @param allowHostsTypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexpTypeHint 
     * @param filterMethods 
     * @param filterMethodsTypeHint 
     */
    public async postConfigApacheSlingReferrerFilter (allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (allowEmpty !== undefined) {
            localVarQueryParameters['allow.empty'] = ObjectSerializer.serialize(allowEmpty, "boolean");
        }

        if (allowEmptyTypeHint !== undefined) {
            localVarQueryParameters['allow.empty@TypeHint'] = ObjectSerializer.serialize(allowEmptyTypeHint, "string");
        }

        if (allowHosts !== undefined) {
            localVarQueryParameters['allow.hosts'] = ObjectSerializer.serialize(allowHosts, "string");
        }

        if (allowHostsTypeHint !== undefined) {
            localVarQueryParameters['allow.hosts@TypeHint'] = ObjectSerializer.serialize(allowHostsTypeHint, "string");
        }

        if (allowHostsRegexp !== undefined) {
            localVarQueryParameters['allow.hosts.regexp'] = ObjectSerializer.serialize(allowHostsRegexp, "string");
        }

        if (allowHostsRegexpTypeHint !== undefined) {
            localVarQueryParameters['allow.hosts.regexp@TypeHint'] = ObjectSerializer.serialize(allowHostsRegexpTypeHint, "string");
        }

        if (filterMethods !== undefined) {
            localVarQueryParameters['filter.methods'] = ObjectSerializer.serialize(filterMethods, "string");
        }

        if (filterMethodsTypeHint !== undefined) {
            localVarQueryParameters['filter.methods@TypeHint'] = ObjectSerializer.serialize(filterMethodsTypeHint, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param configNodeName 
     */
    public async postConfigProperty (configNodeName: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/apps/system/config/{configNodeName}'
            .replace('{' + 'configNodeName' + '}', encodeURIComponent(String(configNodeName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'configNodeName' is not null or undefined
        if (configNodeName === null || configNodeName === undefined) {
            throw new Error('Required parameter configNodeName was null or undefined when calling postConfigProperty.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     * @param operation 
     * @param deleteAuthorizable 
     * @param file 
     */
    public async postNode (path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: RequestFile, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        if (operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(operation, "string");
        }

        if (deleteAuthorizable !== undefined) {
            localVarQueryParameters['deleteAuthorizable'] = ObjectSerializer.serialize(deleteAuthorizable, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param name 
     * @param addMembers 
     */
    public async postNodeRw (path: string, name: string, addMembers?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/{name}.rw.html'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        if (addMembers !== undefined) {
            localVarQueryParameters['addMembers'] = ObjectSerializer.serialize(addMembers, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param jcrprimaryType 
     * @param name 
     */
    public async postPath (path: string, jcrprimaryType: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/{path}/'
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }

        // verify required parameter 'jcrprimaryType' is not null or undefined
        if (jcrprimaryType === null || jcrprimaryType === undefined) {
            throw new Error('Required parameter jcrprimaryType was null or undefined when calling postPath.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postPath.');
        }

        if (jcrprimaryType !== undefined) {
            localVarQueryParameters['jcr:primaryType'] = ObjectSerializer.serialize(jcrprimaryType, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters[':name'] = ObjectSerializer.serialize(name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     */
    public async postQuery (path: string, pLimit: number, _1property: string, _1propertyValue: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/bin/querybuilder.json';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }

        // verify required parameter 'pLimit' is not null or undefined
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1property' is not null or undefined
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }

        // verify required parameter '_1propertyValue' is not null or undefined
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        if (pLimit !== undefined) {
            localVarQueryParameters['p.limit'] = ObjectSerializer.serialize(pLimit, "number");
        }

        if (_1property !== undefined) {
            localVarQueryParameters['1_property'] = ObjectSerializer.serialize(_1property, "string");
        }

        if (_1propertyValue !== undefined) {
            localVarQueryParameters['1_property.value'] = ObjectSerializer.serialize(_1propertyValue, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     */
    public async postTreeActivation (ignoredeactivated: boolean, onlymodified: boolean, path: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/etc/replication/treeactivation.html';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ignoredeactivated' is not null or undefined
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'onlymodified' is not null or undefined
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        if (ignoredeactivated !== undefined) {
            localVarQueryParameters['ignoredeactivated'] = ObjectSerializer.serialize(ignoredeactivated, "boolean");
        }

        if (onlymodified !== undefined) {
            localVarQueryParameters['onlymodified'] = ObjectSerializer.serialize(onlymodified, "boolean");
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     */
    public async postTruststore (operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: RequestFile, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/libs/granite/security/post/truststore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (operation !== undefined) {
            localVarQueryParameters[':operation'] = ObjectSerializer.serialize(operation, "string");
        }

        if (newPassword !== undefined) {
            localVarQueryParameters['newPassword'] = ObjectSerializer.serialize(newPassword, "string");
        }

        if (rePassword !== undefined) {
            localVarQueryParameters['rePassword'] = ObjectSerializer.serialize(rePassword, "string");
        }

        if (keyStoreType !== undefined) {
            localVarQueryParameters['keyStoreType'] = ObjectSerializer.serialize(keyStoreType, "string");
        }

        if (removeAlias !== undefined) {
            localVarQueryParameters['removeAlias'] = ObjectSerializer.serialize(removeAlias, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (certificate !== undefined) {
            localVarFormParams['certificate'] = certificate;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @param truststoreP12 
     */
    public async postTruststorePKCS12 (truststoreP12?: RequestFile, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/etc/truststore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (truststoreP12 !== undefined) {
            localVarFormParams['truststore.p12'] = truststoreP12;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.aemAuth.username && this.authentications.aemAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.aemAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
