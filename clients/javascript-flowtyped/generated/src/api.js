// @flow
/* eslint-disable no-use-before-define */
/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type BundleData = {
    /**
     * Bundle ID
     * @type {number}
     * @memberof BundleData
     */
    id?: number;
    /**
     * Bundle name
     * @type {string}
     * @memberof BundleData
     */
    name?: string;
    /**
     * Is bundle a fragment
     * @type {boolean}
     * @memberof BundleData
     */
    fragment?: boolean;
    /**
     * Numeric raw bundle state value
     * @type {number}
     * @memberof BundleData
     */
    stateRaw?: number;
    /**
     * Bundle state value
     * @type {string}
     * @memberof BundleData
     */
    state?: string;
    /**
     * Bundle version
     * @type {string}
     * @memberof BundleData
     */
    version?: string;
    /**
     * Bundle symbolic name
     * @type {string}
     * @memberof BundleData
     */
    symbolicName?: string;
    /**
     * Bundle category
     * @type {string}
     * @memberof BundleData
     */
    category?: string;
    /**
     * 
     * @type {Array<BundleDataProp>}
     * @memberof BundleData
     */
    props?: Array<BundleDataProp>;
}


/**
 * 
 * @export
 */
export type BundleDataProp = {
    /**
     * Bundle data key
     * @type {string}
     * @memberof BundleDataProp
     */
    key?: string;
    /**
     * Bundle data value
     * @type {string}
     * @memberof BundleDataProp
     */
    value?: string;
}


/**
 * 
 * @export
 */
export type BundleInfo = {
    /**
     * Status description of all bundles
     * @type {string}
     * @memberof BundleInfo
     */
    status?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof BundleInfo
     */
    s?: Array<number>;
    /**
     * 
     * @type {Array<BundleData>}
     * @memberof BundleInfo
     */
    data?: Array<BundleData>;
}


/**
 * 
 * @export
 */
export type InstallStatus = {
    /**
     * 
     * @type {InstallStatusStatus}
     * @memberof InstallStatus
     */
    status?: InstallStatusStatus;
}


/**
 * 
 * @export
 */
export type InstallStatusStatus = {
    /**
     * 
     * @type {boolean}
     * @memberof InstallStatusStatus
     */
    finished?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InstallStatusStatus
     */
    itemCount?: number;
}


/**
 * 
 * @export
 */
export type KeystoreChainItems = {
    /**
     * e.g. \"CN=localhost\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    subject?: string;
    /**
     * e.g. \"CN=Admin\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    issuer?: string;
    /**
     * e.g. \"Sun Jul 01 12:00:00 AEST 2018\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    notBefore?: string;
    /**
     * e.g. \"Sun Jun 30 23:59:50 AEST 2019\"
     * @type {string}
     * @memberof KeystoreChainItems
     */
    notAfter?: string;
    /**
     * 18165099476682912368
     * @type {number}
     * @memberof KeystoreChainItems
     */
    serialNumber?: number;
}


/**
 * 
 * @export
 */
export type KeystoreInfo = {
    /**
     * 
     * @type {Array<KeystoreItems>}
     * @memberof KeystoreInfo
     */
    aliases?: Array<KeystoreItems>;
    /**
     * False if truststore don\'t exist
     * @type {boolean}
     * @memberof KeystoreInfo
     */
    exists?: boolean;
}


/**
 * 
 * @export
 */
export type KeystoreItems = {
    /**
     * Keystore alias name
     * @type {string}
     * @memberof KeystoreItems
     */
    alias?: string;
    /**
     * e.g. \"privateKey\"
     * @type {string}
     * @memberof KeystoreItems
     */
    entryType?: string;
    /**
     * e.g. \"RSA\"
     * @type {string}
     * @memberof KeystoreItems
     */
    algorithm?: string;
    /**
     * e.g. \"PKCS#8\"
     * @type {string}
     * @memberof KeystoreItems
     */
    format?: string;
    /**
     * 
     * @type {Array<KeystoreChainItems>}
     * @memberof KeystoreItems
     */
    chain?: Array<KeystoreChainItems>;
}


/**
 * 
 * @export
 */
export type SamlConfigurationInfo = {
    /**
     * Persistent Identity (PID)
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    pid?: string;
    /**
     * Title
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    title?: string;
    /**
     * Title
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    description?: string;
    /**
     * needed for configuration binding
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    bundle_location?: string;
    /**
     * needed for configuraiton binding
     * @type {string}
     * @memberof SamlConfigurationInfo
     */
    service_location?: string;
    /**
     * 
     * @type {SamlConfigurationProperties}
     * @memberof SamlConfigurationInfo
     */
    properties?: SamlConfigurationProperties;
}


/**
 * 
 * @export
 */
export type SamlConfigurationProperties = {
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    path?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsLong}
     * @memberof SamlConfigurationProperties
     */
    service_ranking?: SamlConfigurationPropertyItemsLong;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    idpUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    idpCertAlias?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    idpHttpRedirect?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    serviceProviderEntityId?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    assertionConsumerServiceURL?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    spPrivateKeyAlias?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    keyStorePassword?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    defaultRedirectUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    userIDAttribute?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    useEncryption?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    createUser?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    addGroupMemberships?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    groupMembershipAttribute?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    defaultGroups?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    nameIdFormat?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsArray}
     * @memberof SamlConfigurationProperties
     */
    synchronizeAttributes?: SamlConfigurationPropertyItemsArray;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsBoolean}
     * @memberof SamlConfigurationProperties
     */
    handleLogout?: SamlConfigurationPropertyItemsBoolean;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    logoutUrl?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsLong}
     * @memberof SamlConfigurationProperties
     */
    clockTolerance?: SamlConfigurationPropertyItemsLong;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    digestMethod?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    signatureMethod?: SamlConfigurationPropertyItemsString;
    /**
     * 
     * @type {SamlConfigurationPropertyItemsString}
     * @memberof SamlConfigurationProperties
     */
    userIntermediatePath?: SamlConfigurationPropertyItemsString;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsArray = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    is_set?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    type?: number;
    /**
     * Property value
     * @type {Array<string>}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    values?: Array<string>;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsArray
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsBoolean = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    is_set?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    type?: number;
    /**
     * Property value
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    value?: boolean;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsBoolean
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsLong = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    is_set?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    type?: number;
    /**
     * Property value
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    value?: number;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsLong
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type SamlConfigurationPropertyItemsString = {
    /**
     * property name
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    name?: string;
    /**
     * True if optional
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsString
     */
    optional?: boolean;
    /**
     * True if property is set
     * @type {boolean}
     * @memberof SamlConfigurationPropertyItemsString
     */
    is_set?: boolean;
    /**
     * Property type, 1=String, 3=long, 11=boolean, 12=Password
     * @type {number}
     * @memberof SamlConfigurationPropertyItemsString
     */
    type?: number;
    /**
     * Property value
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    value?: string;
    /**
     * Property description
     * @type {string}
     * @memberof SamlConfigurationPropertyItemsString
     */
    description?: string;
}


/**
 * 
 * @export
 */
export type TruststoreInfo = {
    /**
     * 
     * @type {Array<TruststoreItems>}
     * @memberof TruststoreInfo
     */
    aliases?: Array<TruststoreItems>;
    /**
     * False if truststore don\'t exist
     * @type {boolean}
     * @memberof TruststoreInfo
     */
    exists?: boolean;
}


/**
 * 
 * @export
 */
export type TruststoreItems = {
    /**
     * Truststore alias name
     * @type {string}
     * @memberof TruststoreItems
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof TruststoreItems
     */
    entryType?: string;
    /**
     * e.g. \"CN=localhost\"
     * @type {string}
     * @memberof TruststoreItems
     */
    subject?: string;
    /**
     * e.g. \"CN=Admin\"
     * @type {string}
     * @memberof TruststoreItems
     */
    issuer?: string;
    /**
     * e.g. \"Sun Jul 01 12:00:00 AEST 2018\"
     * @type {string}
     * @memberof TruststoreItems
     */
    notBefore?: string;
    /**
     * e.g. \"Sun Jun 30 23:59:50 AEST 2019\"
     * @type {string}
     * @memberof TruststoreItems
     */
    notAfter?: string;
    /**
     * 18165099476682912368
     * @type {number}
     * @memberof TruststoreItems
     */
    serialNumber?: number;
}




/**
 * ConsoleApi - fetch parameter creator
 * @export
 */
export const ConsoleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemProductInfo(options: RequestOptions): FetchArgs {
            const localVarPath = `/system/console/status-productinfo.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getBundleInfo(name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getBundleInfo.');
            }
            const localVarPath = `/system/console/bundles/{name}.json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getConfigMgr(options: RequestOptions): FetchArgs {
            const localVarPath = `/system/console/configMgr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postBundle.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling postBundle.');
            }
            const localVarPath = `/system/console/bundles/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = ((action:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling postJmxRepository.');
            }
            const localVarPath = `/system/console/jmx/com.adobe.granite:type=Repository/op/{action}`
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options: RequestOptions): FetchArgs {
            const localVarPath = `/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (post !== undefined) {
                localVarQueryParameter['post'] = ((post:any):string);
            }

            if (apply !== undefined) {
                localVarQueryParameter['apply'] = ((apply:any):string);
            }

            if (_delete !== undefined) {
                localVarQueryParameter['delete'] = ((_delete:any):string);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = ((action:any):string);
            }

            if ($location !== undefined) {
                localVarQueryParameter['$location'] = (($location:any):string);
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (serviceRanking !== undefined) {
                localVarQueryParameter['service.ranking'] = ((serviceRanking:any):string);
            }

            if (idpUrl !== undefined) {
                localVarQueryParameter['idpUrl'] = ((idpUrl:any):string);
            }

            if (idpCertAlias !== undefined) {
                localVarQueryParameter['idpCertAlias'] = ((idpCertAlias:any):string);
            }

            if (idpHttpRedirect !== undefined) {
                localVarQueryParameter['idpHttpRedirect'] = ((idpHttpRedirect:any):string);
            }

            if (serviceProviderEntityId !== undefined) {
                localVarQueryParameter['serviceProviderEntityId'] = ((serviceProviderEntityId:any):string);
            }

            if (assertionConsumerServiceURL !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL'] = ((assertionConsumerServiceURL:any):string);
            }

            if (spPrivateKeyAlias !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias'] = ((spPrivateKeyAlias:any):string);
            }

            if (keyStorePassword !== undefined) {
                localVarQueryParameter['keyStorePassword'] = ((keyStorePassword:any):string);
            }

            if (defaultRedirectUrl !== undefined) {
                localVarQueryParameter['defaultRedirectUrl'] = ((defaultRedirectUrl:any):string);
            }

            if (userIDAttribute !== undefined) {
                localVarQueryParameter['userIDAttribute'] = ((userIDAttribute:any):string);
            }

            if (useEncryption !== undefined) {
                localVarQueryParameter['useEncryption'] = ((useEncryption:any):string);
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = ((createUser:any):string);
            }

            if (addGroupMemberships !== undefined) {
                localVarQueryParameter['addGroupMemberships'] = ((addGroupMemberships:any):string);
            }

            if (groupMembershipAttribute !== undefined) {
                localVarQueryParameter['groupMembershipAttribute'] = ((groupMembershipAttribute:any):string);
            }

            if (defaultGroups) {
                localVarQueryParameter['defaultGroups'] = defaultGroups;
            }

            if (nameIdFormat !== undefined) {
                localVarQueryParameter['nameIdFormat'] = ((nameIdFormat:any):string);
            }

            if (synchronizeAttributes) {
                localVarQueryParameter['synchronizeAttributes'] = synchronizeAttributes;
            }

            if (handleLogout !== undefined) {
                localVarQueryParameter['handleLogout'] = ((handleLogout:any):string);
            }

            if (logoutUrl !== undefined) {
                localVarQueryParameter['logoutUrl'] = ((logoutUrl:any):string);
            }

            if (clockTolerance !== undefined) {
                localVarQueryParameter['clockTolerance'] = ((clockTolerance:any):string);
            }

            if (digestMethod !== undefined) {
                localVarQueryParameter['digestMethod'] = ((digestMethod:any):string);
            }

            if (signatureMethod !== undefined) {
                localVarQueryParameter['signatureMethod'] = ((signatureMethod:any):string);
            }

            if (userIntermediatePath !== undefined) {
                localVarQueryParameter['userIntermediatePath'] = ((userIntermediatePath:any):string);
            }

            if (propertylist) {
                localVarQueryParameter['propertylist'] = propertylist.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ConsoleApiType = { 
    getAemProductInfo(options?: RequestOptions): Promise<Array<string>>,

    getBundleInfo(name: string, options?: RequestOptions): Promise<BundleInfo>,

    getConfigMgr(options?: RequestOptions): Promise<string>,

    postBundle(name: string, action: string, options?: RequestOptions): Promise<Response>,

    postJmxRepository(action: string, options?: RequestOptions): Promise<Response>,

    postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: RequestOptions): Promise<SamlConfigurationInfo>,
}

/**
 * ConsoleApi - factory function to inject configuration 
 * @export
 */
export const ConsoleApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ConsoleApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemProductInfo(options?: RequestOptions = {}): Promise<Array<string>> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getAemProductInfo(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getBundleInfo(name: string, options?: RequestOptions = {}): Promise<BundleInfo> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getBundleInfo(name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getConfigMgr(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getConfigMgr(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postBundle(name: string, action: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postBundle(name, action, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postJmxRepository(action: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postJmxRepository(action, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSamlConfiguration(post?: boolean, apply?: boolean, _delete?: boolean, action?: string, $location?: string, path?: Array<string>, serviceRanking?: number, idpUrl?: string, idpCertAlias?: string, idpHttpRedirect?: boolean, serviceProviderEntityId?: string, assertionConsumerServiceURL?: string, spPrivateKeyAlias?: string, keyStorePassword?: string, defaultRedirectUrl?: string, userIDAttribute?: string, useEncryption?: boolean, createUser?: boolean, addGroupMemberships?: boolean, groupMembershipAttribute?: string, defaultGroups?: Array<string>, nameIdFormat?: string, synchronizeAttributes?: Array<string>, handleLogout?: boolean, logoutUrl?: string, clockTolerance?: number, digestMethod?: string, signatureMethod?: string, userIntermediatePath?: string, propertylist?: Array<string>, options?: RequestOptions = {}): Promise<SamlConfigurationInfo> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).postSamlConfiguration(post, apply, _delete, action, $location, path, serviceRanking, idpUrl, idpCertAlias, idpHttpRedirect, serviceProviderEntityId, assertionConsumerServiceURL, spPrivateKeyAlias, keyStorePassword, defaultRedirectUrl, userIDAttribute, useEncryption, createUser, addGroupMemberships, groupMembershipAttribute, defaultGroups, nameIdFormat, synchronizeAttributes, handleLogout, logoutUrl, clockTolerance, digestMethod, signatureMethod, userIntermediatePath, propertylist, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CqApi - fetch parameter creator
 * @export
 */
export const CqApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getLoginPage(options: RequestOptions): FetchArgs {
            const localVarPath = `/libs/granite/core/content/login.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postCqActions.');
            }
            // verify required parameter 'changelog' is not null or undefined
            if (changelog === null || changelog === undefined) {
                throw new RequiredError('changelog','Required parameter changelog was null or undefined when calling postCqActions.');
            }
            const localVarPath = `/.cqactions.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorizableId !== undefined) {
                localVarQueryParameter['authorizableId'] = ((authorizableId:any):string);
            }

            if (changelog !== undefined) {
                localVarQueryParameter['changelog'] = ((changelog:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CqApiType = { 
    getLoginPage(options?: RequestOptions): Promise<string>,

    postCqActions(authorizableId: string, changelog: string, options?: RequestOptions): Promise<Response>,
}

/**
 * CqApi - factory function to inject configuration 
 * @export
 */
export const CqApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CqApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getLoginPage(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CqApiFetchParamCreator(configuration).getLoginPage(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postCqActions(authorizableId: string, changelog: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CqApiFetchParamCreator(configuration).postCqActions(authorizableId, changelog, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CrxApi - fetch parameter creator
 * @export
 */
export const CrxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getCrxdeStatus(options: RequestOptions): FetchArgs {
            const localVarPath = `/crx/server/crx.default/jcr:root/.1.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getInstallStatus(options: RequestOptions): FetchArgs {
            const localVarPath = `/crx/packmgr/installstatus.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options: RequestOptions): FetchArgs {
            const localVarPath = `/crx/packmgr/service/script.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling postPackageService.');
            }
            const localVarPath = `/crx/packmgr/service.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cmd !== undefined) {
                localVarQueryParameter['cmd'] = ((cmd:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPackageServiceJson.');
            }
            // verify required parameter 'cmd' is not null or undefined
            if (cmd === null || cmd === undefined) {
                throw new RequiredError('cmd','Required parameter cmd was null or undefined when calling postPackageServiceJson.');
            }
            const localVarPath = `/crx/packmgr/service/.json/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cmd !== undefined) {
                localVarQueryParameter['cmd'] = ((cmd:any):string);
            }

            if (groupName !== undefined) {
                localVarQueryParameter['groupName'] = ((groupName:any):string);
            }

            if (packageName !== undefined) {
                localVarQueryParameter['packageName'] = ((packageName:any):string);
            }

            if (packageVersion !== undefined) {
                localVarQueryParameter['packageVersion'] = ((packageVersion:any):string);
            }

            if (charset !== undefined) {
                localVarQueryParameter['_charset_'] = ((charset:any):string);
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = ((force:any):string);
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = ((recursive:any):string);
            }

            if (_package !== undefined) {
                localVarFormParams.set('package', ((_package:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupName' is not null or undefined
            if (groupName === null || groupName === undefined) {
                throw new RequiredError('groupName','Required parameter groupName was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'packageName' is not null or undefined
            if (packageName === null || packageName === undefined) {
                throw new RequiredError('packageName','Required parameter packageName was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling postPackageUpdate.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPackageUpdate.');
            }
            const localVarPath = `/crx/packmgr/update.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupName !== undefined) {
                localVarQueryParameter['groupName'] = ((groupName:any):string);
            }

            if (packageName !== undefined) {
                localVarQueryParameter['packageName'] = ((packageName:any):string);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = ((version:any):string);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (charset !== undefined) {
                localVarQueryParameter['_charset_'] = ((charset:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'old' is not null or undefined
            if (old === null || old === undefined) {
                throw new RequiredError('old','Required parameter old was null or undefined when calling postSetPassword.');
            }
            // verify required parameter 'plain' is not null or undefined
            if (plain === null || plain === undefined) {
                throw new RequiredError('plain','Required parameter plain was null or undefined when calling postSetPassword.');
            }
            // verify required parameter 'verify' is not null or undefined
            if (verify === null || verify === undefined) {
                throw new RequiredError('verify','Required parameter verify was null or undefined when calling postSetPassword.');
            }
            const localVarPath = `/crx/explorer/ui/setpassword.jsp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (old !== undefined) {
                localVarQueryParameter['old'] = ((old:any):string);
            }

            if (plain !== undefined) {
                localVarQueryParameter['plain'] = ((plain:any):string);
            }

            if (verify !== undefined) {
                localVarQueryParameter['verify'] = ((verify:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CrxApiType = { 
    getCrxdeStatus(options?: RequestOptions): Promise<string>,

    getInstallStatus(options?: RequestOptions): Promise<InstallStatus>,

    getPackageManagerServlet(options?: RequestOptions): Promise<Response>,

    postPackageService(cmd: string, options?: RequestOptions): Promise<string>,

    postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: RequestOptions): Promise<string>,

    postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: RequestOptions): Promise<string>,

    postSetPassword(old: string, plain: string, verify: string, options?: RequestOptions): Promise<string>,
}

/**
 * CrxApi - factory function to inject configuration 
 * @export
 */
export const CrxApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CrxApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getCrxdeStatus(options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getCrxdeStatus(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getInstallStatus(options?: RequestOptions = {}): Promise<InstallStatus> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getInstallStatus(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageManagerServlet(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).getPackageManagerServlet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageService(cmd: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageService(cmd, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageServiceJson(path: string, cmd: string, groupName?: string, packageName?: string, packageVersion?: string, charset?: string, force?: boolean, recursive?: boolean, _package?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageServiceJson(path, cmd, groupName, packageName, packageVersion, charset, force, recursive, _package, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPackageUpdate(groupName: string, packageName: string, version: string, path: string, filter?: string, charset?: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postPackageUpdate(groupName, packageName, version, path, filter, charset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postSetPassword(old: string, plain: string, verify: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CrxApiFetchParamCreator(configuration).postSetPassword(old, plain, verify, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CustomApi - fetch parameter creator
 * @export
 */
export const CustomApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/system/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = ((tags:any):string);
            }

            if (combineTagsOr !== undefined) {
                localVarQueryParameter['combineTagsOr'] = ((combineTagsOr:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnoredTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/com.shinesolutions.healthcheck.hc.impl.ActiveBundleHealthCheck`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (bundlesIgnored) {
                localVarQueryParameter['bundles.ignored'] = bundlesIgnored;
            }

            if (bundlesIgnoredTypeHint !== undefined) {
                localVarQueryParameter['bundles.ignored@TypeHint'] = ((bundlesIgnoredTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizablesTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/com.shinesolutions.aem.passwordreset.Activator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (pwdresetAuthorizables) {
                localVarQueryParameter['pwdreset.authorizables'] = pwdresetAuthorizables;
            }

            if (pwdresetAuthorizablesTypeHint !== undefined) {
                localVarQueryParameter['pwdreset.authorizables@TypeHint'] = ((pwdresetAuthorizablesTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CustomApiType = { 
    getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: RequestOptions): Promise<string>,

    postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnoredTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizablesTypeHint?: string, options?: RequestOptions): Promise<Response>,
}

/**
 * CustomApi - factory function to inject configuration 
 * @export
 */
export const CustomApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CustomApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        getAemHealthCheck(tags?: string, combineTagsOr?: boolean, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).getAemHealthCheck(tags, combineTagsOr, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemHealthCheckServlet(bundlesIgnored?: Array<string>, bundlesIgnoredTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).postConfigAemHealthCheckServlet(bundlesIgnored, bundlesIgnoredTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAemPasswordReset(pwdresetAuthorizables?: Array<string>, pwdresetAuthorizablesTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = CustomApiFetchParamCreator(configuration).postConfigAemPasswordReset(pwdresetAuthorizables, pwdresetAuthorizablesTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * GraniteApi - fetch parameter creator
 * @export
 */
export const GraniteApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        sslSetup(keystorePassword: string, keystorePasswordConfirm: string, truststorePassword: string, truststorePasswordConfirm: string, httpsHostname: string, httpsPort: string, privatekeyFile?: any, certificateFile?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'keystorePassword' is not null or undefined
            if (keystorePassword === null || keystorePassword === undefined) {
                throw new RequiredError('keystorePassword','Required parameter keystorePassword was null or undefined when calling sslSetup.');
            }
            // verify required parameter 'keystorePasswordConfirm' is not null or undefined
            if (keystorePasswordConfirm === null || keystorePasswordConfirm === undefined) {
                throw new RequiredError('keystorePasswordConfirm','Required parameter keystorePasswordConfirm was null or undefined when calling sslSetup.');
            }
            // verify required parameter 'truststorePassword' is not null or undefined
            if (truststorePassword === null || truststorePassword === undefined) {
                throw new RequiredError('truststorePassword','Required parameter truststorePassword was null or undefined when calling sslSetup.');
            }
            // verify required parameter 'truststorePasswordConfirm' is not null or undefined
            if (truststorePasswordConfirm === null || truststorePasswordConfirm === undefined) {
                throw new RequiredError('truststorePasswordConfirm','Required parameter truststorePasswordConfirm was null or undefined when calling sslSetup.');
            }
            // verify required parameter 'httpsHostname' is not null or undefined
            if (httpsHostname === null || httpsHostname === undefined) {
                throw new RequiredError('httpsHostname','Required parameter httpsHostname was null or undefined when calling sslSetup.');
            }
            // verify required parameter 'httpsPort' is not null or undefined
            if (httpsPort === null || httpsPort === undefined) {
                throw new RequiredError('httpsPort','Required parameter httpsPort was null or undefined when calling sslSetup.');
            }
            const localVarPath = `/libs/granite/security/post/sslSetup.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keystorePassword !== undefined) {
                localVarQueryParameter['keystorePassword'] = ((keystorePassword:any):string);
            }

            if (keystorePasswordConfirm !== undefined) {
                localVarQueryParameter['keystorePasswordConfirm'] = ((keystorePasswordConfirm:any):string);
            }

            if (truststorePassword !== undefined) {
                localVarQueryParameter['truststorePassword'] = ((truststorePassword:any):string);
            }

            if (truststorePasswordConfirm !== undefined) {
                localVarQueryParameter['truststorePasswordConfirm'] = ((truststorePasswordConfirm:any):string);
            }

            if (httpsHostname !== undefined) {
                localVarQueryParameter['httpsHostname'] = ((httpsHostname:any):string);
            }

            if (httpsPort !== undefined) {
                localVarQueryParameter['httpsPort'] = ((httpsPort:any):string);
            }

            if (privatekeyFile !== undefined) {
                localVarFormParams.set('privatekeyFile', ((privatekeyFile:any):string));
            }

            if (certificateFile !== undefined) {
                localVarFormParams.set('certificateFile', ((certificateFile:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type GraniteApiType = { 
    sslSetup(keystorePassword: string, keystorePasswordConfirm: string, truststorePassword: string, truststorePasswordConfirm: string, httpsHostname: string, httpsPort: string, privatekeyFile?: any, certificateFile?: any, options?: RequestOptions): Promise<string>,
}

/**
 * GraniteApi - factory function to inject configuration 
 * @export
 */
export const GraniteApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): GraniteApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        sslSetup(keystorePassword: string, keystorePasswordConfirm: string, truststorePassword: string, truststorePasswordConfirm: string, httpsHostname: string, httpsPort: string, privatekeyFile?: any, certificateFile?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = GraniteApiFetchParamCreator(configuration).sslSetup(keystorePassword, keystorePasswordConfirm, truststorePassword, truststorePasswordConfirm, httpsHostname, httpsPort, privatekeyFile, certificateFile, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SlingApi - fetch parameter creator
 * @export
 */
export const SlingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling deleteAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling deleteNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling getAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling getAgents.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}.-1.json`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}.ks.json`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling getKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling getKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}/keystore/store.p12`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getPackage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackage.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getPackage.');
            }
            const localVarPath = `/etc/packages/{group}/{name}-{version}.zip`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getPackageFilter.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackageFilter.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getPackageFilter.');
            }
            const localVarPath = `/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getQuery.');
            }
            // verify required parameter 'pLimit' is not null or undefined
            if (pLimit === null || pLimit === undefined) {
                throw new RequiredError('pLimit','Required parameter pLimit was null or undefined when calling getQuery.');
            }
            // verify required parameter '_1property' is not null or undefined
            if (_1property === null || _1property === undefined) {
                throw new RequiredError('_1property','Required parameter _1property was null or undefined when calling getQuery.');
            }
            // verify required parameter '_1propertyValue' is not null or undefined
            if (_1propertyValue === null || _1propertyValue === undefined) {
                throw new RequiredError('_1propertyValue','Required parameter _1propertyValue was null or undefined when calling getQuery.');
            }
            const localVarPath = `/bin/querybuilder.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            if (pLimit !== undefined) {
                localVarQueryParameter['p.limit'] = ((pLimit:any):string);
            }

            if (_1property !== undefined) {
                localVarQueryParameter['1_property'] = ((_1property:any):string);
            }

            if (_1propertyValue !== undefined) {
                localVarQueryParameter['1_property.value'] = ((_1propertyValue:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststore(options: RequestOptions): FetchArgs {
            const localVarPath = `/etc/truststore/truststore.p12`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststoreInfo(options: RequestOptions): FetchArgs {
            const localVarPath = `/libs/granite/security/truststore.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'runmode' is not null or undefined
            if (runmode === null || runmode === undefined) {
                throw new RequiredError('runmode','Required parameter runmode was null or undefined when calling postAgent.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postAgent.');
            }
            const localVarPath = `/etc/replication/agents.{runmode}/{name}`
                .replace(`{${"runmode"}}`, encodeURIComponent(String(runmode)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jcrcontentCqdistribute !== undefined) {
                localVarQueryParameter['jcr:content/cq:distribute'] = ((jcrcontentCqdistribute:any):string);
            }

            if (jcrcontentCqdistributeTypeHint !== undefined) {
                localVarQueryParameter['jcr:content/cq:distribute@TypeHint'] = ((jcrcontentCqdistributeTypeHint:any):string);
            }

            if (jcrcontentCqname !== undefined) {
                localVarQueryParameter['jcr:content/cq:name'] = ((jcrcontentCqname:any):string);
            }

            if (jcrcontentCqtemplate !== undefined) {
                localVarQueryParameter['jcr:content/cq:template'] = ((jcrcontentCqtemplate:any):string);
            }

            if (jcrcontentEnabled !== undefined) {
                localVarQueryParameter['jcr:content/enabled'] = ((jcrcontentEnabled:any):string);
            }

            if (jcrcontentJcrdescription !== undefined) {
                localVarQueryParameter['jcr:content/jcr:description'] = ((jcrcontentJcrdescription:any):string);
            }

            if (jcrcontentJcrlastModified !== undefined) {
                localVarQueryParameter['jcr:content/jcr:lastModified'] = ((jcrcontentJcrlastModified:any):string);
            }

            if (jcrcontentJcrlastModifiedBy !== undefined) {
                localVarQueryParameter['jcr:content/jcr:lastModifiedBy'] = ((jcrcontentJcrlastModifiedBy:any):string);
            }

            if (jcrcontentJcrmixinTypes !== undefined) {
                localVarQueryParameter['jcr:content/jcr:mixinTypes'] = ((jcrcontentJcrmixinTypes:any):string);
            }

            if (jcrcontentJcrtitle !== undefined) {
                localVarQueryParameter['jcr:content/jcr:title'] = ((jcrcontentJcrtitle:any):string);
            }

            if (jcrcontentLogLevel !== undefined) {
                localVarQueryParameter['jcr:content/logLevel'] = ((jcrcontentLogLevel:any):string);
            }

            if (jcrcontentNoStatusUpdate !== undefined) {
                localVarQueryParameter['jcr:content/noStatusUpdate'] = ((jcrcontentNoStatusUpdate:any):string);
            }

            if (jcrcontentNoVersioning !== undefined) {
                localVarQueryParameter['jcr:content/noVersioning'] = ((jcrcontentNoVersioning:any):string);
            }

            if (jcrcontentProtocolConnectTimeout !== undefined) {
                localVarQueryParameter['jcr:content/protocolConnectTimeout'] = ((jcrcontentProtocolConnectTimeout:any):string);
            }

            if (jcrcontentProtocolHTTPConnectionClosed !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPConnectionClosed'] = ((jcrcontentProtocolHTTPConnectionClosed:any):string);
            }

            if (jcrcontentProtocolHTTPExpired !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPExpired'] = ((jcrcontentProtocolHTTPExpired:any):string);
            }

            if (jcrcontentProtocolHTTPHeaders) {
                localVarQueryParameter['jcr:content/protocolHTTPHeaders'] = jcrcontentProtocolHTTPHeaders;
            }

            if (jcrcontentProtocolHTTPHeadersTypeHint !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPHeaders@TypeHint'] = ((jcrcontentProtocolHTTPHeadersTypeHint:any):string);
            }

            if (jcrcontentProtocolHTTPMethod !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPMethod'] = ((jcrcontentProtocolHTTPMethod:any):string);
            }

            if (jcrcontentProtocolHTTPSRelaxed !== undefined) {
                localVarQueryParameter['jcr:content/protocolHTTPSRelaxed'] = ((jcrcontentProtocolHTTPSRelaxed:any):string);
            }

            if (jcrcontentProtocolInterface !== undefined) {
                localVarQueryParameter['jcr:content/protocolInterface'] = ((jcrcontentProtocolInterface:any):string);
            }

            if (jcrcontentProtocolSocketTimeout !== undefined) {
                localVarQueryParameter['jcr:content/protocolSocketTimeout'] = ((jcrcontentProtocolSocketTimeout:any):string);
            }

            if (jcrcontentProtocolVersion !== undefined) {
                localVarQueryParameter['jcr:content/protocolVersion'] = ((jcrcontentProtocolVersion:any):string);
            }

            if (jcrcontentProxyNTLMDomain !== undefined) {
                localVarQueryParameter['jcr:content/proxyNTLMDomain'] = ((jcrcontentProxyNTLMDomain:any):string);
            }

            if (jcrcontentProxyNTLMHost !== undefined) {
                localVarQueryParameter['jcr:content/proxyNTLMHost'] = ((jcrcontentProxyNTLMHost:any):string);
            }

            if (jcrcontentProxyHost !== undefined) {
                localVarQueryParameter['jcr:content/proxyHost'] = ((jcrcontentProxyHost:any):string);
            }

            if (jcrcontentProxyPassword !== undefined) {
                localVarQueryParameter['jcr:content/proxyPassword'] = ((jcrcontentProxyPassword:any):string);
            }

            if (jcrcontentProxyPort !== undefined) {
                localVarQueryParameter['jcr:content/proxyPort'] = ((jcrcontentProxyPort:any):string);
            }

            if (jcrcontentProxyUser !== undefined) {
                localVarQueryParameter['jcr:content/proxyUser'] = ((jcrcontentProxyUser:any):string);
            }

            if (jcrcontentQueueBatchMaxSize !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchMaxSize'] = ((jcrcontentQueueBatchMaxSize:any):string);
            }

            if (jcrcontentQueueBatchMode !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchMode'] = ((jcrcontentQueueBatchMode:any):string);
            }

            if (jcrcontentQueueBatchWaitTime !== undefined) {
                localVarQueryParameter['jcr:content/queueBatchWaitTime'] = ((jcrcontentQueueBatchWaitTime:any):string);
            }

            if (jcrcontentRetryDelay !== undefined) {
                localVarQueryParameter['jcr:content/retryDelay'] = ((jcrcontentRetryDelay:any):string);
            }

            if (jcrcontentReverseReplication !== undefined) {
                localVarQueryParameter['jcr:content/reverseReplication'] = ((jcrcontentReverseReplication:any):string);
            }

            if (jcrcontentSerializationType !== undefined) {
                localVarQueryParameter['jcr:content/serializationType'] = ((jcrcontentSerializationType:any):string);
            }

            if (jcrcontentSlingresourceType !== undefined) {
                localVarQueryParameter['jcr:content/sling:resourceType'] = ((jcrcontentSlingresourceType:any):string);
            }

            if (jcrcontentSsl !== undefined) {
                localVarQueryParameter['jcr:content/ssl'] = ((jcrcontentSsl:any):string);
            }

            if (jcrcontentTransportNTLMDomain !== undefined) {
                localVarQueryParameter['jcr:content/transportNTLMDomain'] = ((jcrcontentTransportNTLMDomain:any):string);
            }

            if (jcrcontentTransportNTLMHost !== undefined) {
                localVarQueryParameter['jcr:content/transportNTLMHost'] = ((jcrcontentTransportNTLMHost:any):string);
            }

            if (jcrcontentTransportPassword !== undefined) {
                localVarQueryParameter['jcr:content/transportPassword'] = ((jcrcontentTransportPassword:any):string);
            }

            if (jcrcontentTransportUri !== undefined) {
                localVarQueryParameter['jcr:content/transportUri'] = ((jcrcontentTransportUri:any):string);
            }

            if (jcrcontentTransportUser !== undefined) {
                localVarQueryParameter['jcr:content/transportUser'] = ((jcrcontentTransportUser:any):string);
            }

            if (jcrcontentTriggerDistribute !== undefined) {
                localVarQueryParameter['jcr:content/triggerDistribute'] = ((jcrcontentTriggerDistribute:any):string);
            }

            if (jcrcontentTriggerModified !== undefined) {
                localVarQueryParameter['jcr:content/triggerModified'] = ((jcrcontentTriggerModified:any):string);
            }

            if (jcrcontentTriggerOnOffTime !== undefined) {
                localVarQueryParameter['jcr:content/triggerOnOffTime'] = ((jcrcontentTriggerOnOffTime:any):string);
            }

            if (jcrcontentTriggerReceive !== undefined) {
                localVarQueryParameter['jcr:content/triggerReceive'] = ((jcrcontentTriggerReceive:any):string);
            }

            if (jcrcontentTriggerSpecific !== undefined) {
                localVarQueryParameter['jcr:content/triggerSpecific'] = ((jcrcontentTriggerSpecific:any):string);
            }

            if (jcrcontentUserId !== undefined) {
                localVarQueryParameter['jcr:content/userId'] = ((jcrcontentUserId:any):string);
            }

            if (jcrprimaryType !== undefined) {
                localVarQueryParameter['jcr:primaryType'] = ((jcrprimaryType:any):string);
            }

            if (operation !== undefined) {
                localVarQueryParameter[':operation'] = ((operation:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
            }
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
            }
            const localVarPath = `/{intermediatePath}/{authorizableId}.ks.html`
                .replace(`{${"intermediatePath"}}`, encodeURIComponent(String(intermediatePath)))
                .replace(`{${"authorizableId"}}`, encodeURIComponent(String(authorizableId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (operation !== undefined) {
                localVarQueryParameter[':operation'] = ((operation:any):string);
            }

            if (currentPassword !== undefined) {
                localVarQueryParameter['currentPassword'] = ((currentPassword:any):string);
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = ((newPassword:any):string);
            }

            if (rePassword !== undefined) {
                localVarQueryParameter['rePassword'] = ((rePassword:any):string);
            }

            if (keyPassword !== undefined) {
                localVarQueryParameter['keyPassword'] = ((keyPassword:any):string);
            }

            if (keyStorePass !== undefined) {
                localVarQueryParameter['keyStorePass'] = ((keyStorePass:any):string);
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = ((alias:any):string);
            }

            if (newAlias !== undefined) {
                localVarQueryParameter['newAlias'] = ((newAlias:any):string);
            }

            if (removeAlias !== undefined) {
                localVarQueryParameter['removeAlias'] = ((removeAlias:any):string);
            }

            if (certChain !== undefined) {
                localVarFormParams.set('cert-chain', ((certChain:any):string));
            }

            if (pk !== undefined) {
                localVarFormParams.set('pk', ((pk:any):string));
            }

            if (keyStore !== undefined) {
                localVarFormParams.set('keyStore', ((keyStore:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorizableId' is not null or undefined
            if (authorizableId === null || authorizableId === undefined) {
                throw new RequiredError('authorizableId','Required parameter authorizableId was null or undefined when calling postAuthorizables.');
            }
            // verify required parameter 'intermediatePath' is not null or undefined
            if (intermediatePath === null || intermediatePath === undefined) {
                throw new RequiredError('intermediatePath','Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
            }
            const localVarPath = `/libs/granite/security/post/authorizables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (authorizableId !== undefined) {
                localVarQueryParameter['authorizableId'] = ((authorizableId:any):string);
            }

            if (intermediatePath !== undefined) {
                localVarQueryParameter['intermediatePath'] = ((intermediatePath:any):string);
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = ((createUser:any):string);
            }

            if (createGroup !== undefined) {
                localVarQueryParameter['createGroup'] = ((createGroup:any):string);
            }

            if (reppassword !== undefined) {
                localVarQueryParameter['rep:password'] = ((reppassword:any):string);
            }

            if (profileGivenName !== undefined) {
                localVarQueryParameter['profile/givenName'] = ((profileGivenName:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyStorePassword !== undefined) {
                localVarQueryParameter['keyStorePassword'] = ((keyStorePassword:any):string);
            }

            if (keyStorePasswordTypeHint !== undefined) {
                localVarQueryParameter['keyStorePassword@TypeHint'] = ((keyStorePasswordTypeHint:any):string);
            }

            if (serviceRanking !== undefined) {
                localVarQueryParameter['service.ranking'] = ((serviceRanking:any):string);
            }

            if (serviceRankingTypeHint !== undefined) {
                localVarQueryParameter['service.ranking@TypeHint'] = ((serviceRankingTypeHint:any):string);
            }

            if (idpHttpRedirect !== undefined) {
                localVarQueryParameter['idpHttpRedirect'] = ((idpHttpRedirect:any):string);
            }

            if (idpHttpRedirectTypeHint !== undefined) {
                localVarQueryParameter['idpHttpRedirect@TypeHint'] = ((idpHttpRedirectTypeHint:any):string);
            }

            if (createUser !== undefined) {
                localVarQueryParameter['createUser'] = ((createUser:any):string);
            }

            if (createUserTypeHint !== undefined) {
                localVarQueryParameter['createUser@TypeHint'] = ((createUserTypeHint:any):string);
            }

            if (defaultRedirectUrl !== undefined) {
                localVarQueryParameter['defaultRedirectUrl'] = ((defaultRedirectUrl:any):string);
            }

            if (defaultRedirectUrlTypeHint !== undefined) {
                localVarQueryParameter['defaultRedirectUrl@TypeHint'] = ((defaultRedirectUrlTypeHint:any):string);
            }

            if (userIDAttribute !== undefined) {
                localVarQueryParameter['userIDAttribute'] = ((userIDAttribute:any):string);
            }

            if (userIDAttributeTypeHint !== undefined) {
                localVarQueryParameter['userIDAttribute@TypeHint'] = ((userIDAttributeTypeHint:any):string);
            }

            if (defaultGroups) {
                localVarQueryParameter['defaultGroups'] = defaultGroups;
            }

            if (defaultGroupsTypeHint !== undefined) {
                localVarQueryParameter['defaultGroups@TypeHint'] = ((defaultGroupsTypeHint:any):string);
            }

            if (idpCertAlias !== undefined) {
                localVarQueryParameter['idpCertAlias'] = ((idpCertAlias:any):string);
            }

            if (idpCertAliasTypeHint !== undefined) {
                localVarQueryParameter['idpCertAlias@TypeHint'] = ((idpCertAliasTypeHint:any):string);
            }

            if (addGroupMemberships !== undefined) {
                localVarQueryParameter['addGroupMemberships'] = ((addGroupMemberships:any):string);
            }

            if (addGroupMembershipsTypeHint !== undefined) {
                localVarQueryParameter['addGroupMemberships@TypeHint'] = ((addGroupMembershipsTypeHint:any):string);
            }

            if (path) {
                localVarQueryParameter['path'] = path;
            }

            if (pathTypeHint !== undefined) {
                localVarQueryParameter['path@TypeHint'] = ((pathTypeHint:any):string);
            }

            if (synchronizeAttributes) {
                localVarQueryParameter['synchronizeAttributes'] = synchronizeAttributes;
            }

            if (synchronizeAttributesTypeHint !== undefined) {
                localVarQueryParameter['synchronizeAttributes@TypeHint'] = ((synchronizeAttributesTypeHint:any):string);
            }

            if (clockTolerance !== undefined) {
                localVarQueryParameter['clockTolerance'] = ((clockTolerance:any):string);
            }

            if (clockToleranceTypeHint !== undefined) {
                localVarQueryParameter['clockTolerance@TypeHint'] = ((clockToleranceTypeHint:any):string);
            }

            if (groupMembershipAttribute !== undefined) {
                localVarQueryParameter['groupMembershipAttribute'] = ((groupMembershipAttribute:any):string);
            }

            if (groupMembershipAttributeTypeHint !== undefined) {
                localVarQueryParameter['groupMembershipAttribute@TypeHint'] = ((groupMembershipAttributeTypeHint:any):string);
            }

            if (idpUrl !== undefined) {
                localVarQueryParameter['idpUrl'] = ((idpUrl:any):string);
            }

            if (idpUrlTypeHint !== undefined) {
                localVarQueryParameter['idpUrl@TypeHint'] = ((idpUrlTypeHint:any):string);
            }

            if (logoutUrl !== undefined) {
                localVarQueryParameter['logoutUrl'] = ((logoutUrl:any):string);
            }

            if (logoutUrlTypeHint !== undefined) {
                localVarQueryParameter['logoutUrl@TypeHint'] = ((logoutUrlTypeHint:any):string);
            }

            if (serviceProviderEntityId !== undefined) {
                localVarQueryParameter['serviceProviderEntityId'] = ((serviceProviderEntityId:any):string);
            }

            if (serviceProviderEntityIdTypeHint !== undefined) {
                localVarQueryParameter['serviceProviderEntityId@TypeHint'] = ((serviceProviderEntityIdTypeHint:any):string);
            }

            if (assertionConsumerServiceURL !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL'] = ((assertionConsumerServiceURL:any):string);
            }

            if (assertionConsumerServiceURLTypeHint !== undefined) {
                localVarQueryParameter['assertionConsumerServiceURL@TypeHint'] = ((assertionConsumerServiceURLTypeHint:any):string);
            }

            if (handleLogout !== undefined) {
                localVarQueryParameter['handleLogout'] = ((handleLogout:any):string);
            }

            if (handleLogoutTypeHint !== undefined) {
                localVarQueryParameter['handleLogout@TypeHint'] = ((handleLogoutTypeHint:any):string);
            }

            if (spPrivateKeyAlias !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias'] = ((spPrivateKeyAlias:any):string);
            }

            if (spPrivateKeyAliasTypeHint !== undefined) {
                localVarQueryParameter['spPrivateKeyAlias@TypeHint'] = ((spPrivateKeyAliasTypeHint:any):string);
            }

            if (useEncryption !== undefined) {
                localVarQueryParameter['useEncryption'] = ((useEncryption:any):string);
            }

            if (useEncryptionTypeHint !== undefined) {
                localVarQueryParameter['useEncryption@TypeHint'] = ((useEncryptionTypeHint:any):string);
            }

            if (nameIdFormat !== undefined) {
                localVarQueryParameter['nameIdFormat'] = ((nameIdFormat:any):string);
            }

            if (nameIdFormatTypeHint !== undefined) {
                localVarQueryParameter['nameIdFormat@TypeHint'] = ((nameIdFormatTypeHint:any):string);
            }

            if (digestMethod !== undefined) {
                localVarQueryParameter['digestMethod'] = ((digestMethod:any):string);
            }

            if (digestMethodTypeHint !== undefined) {
                localVarQueryParameter['digestMethod@TypeHint'] = ((digestMethodTypeHint:any):string);
            }

            if (signatureMethod !== undefined) {
                localVarQueryParameter['signatureMethod'] = ((signatureMethod:any):string);
            }

            if (signatureMethodTypeHint !== undefined) {
                localVarQueryParameter['signatureMethod@TypeHint'] = ((signatureMethodTypeHint:any):string);
            }

            if (userIntermediatePath !== undefined) {
                localVarQueryParameter['userIntermediatePath'] = ((userIntermediatePath:any):string);
            }

            if (userIntermediatePathTypeHint !== undefined) {
                localVarQueryParameter['userIntermediatePath@TypeHint'] = ((userIntermediatePathTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.felix.http`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (orgApacheFelixHttpsNio !== undefined) {
                localVarQueryParameter['org.apache.felix.https.nio'] = ((orgApacheFelixHttpsNio:any):string);
            }

            if (orgApacheFelixHttpsNioTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.nio@TypeHint'] = ((orgApacheFelixHttpsNioTypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystore !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore'] = ((orgApacheFelixHttpsKeystore:any):string);
            }

            if (orgApacheFelixHttpsKeystoreTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore@TypeHint'] = ((orgApacheFelixHttpsKeystoreTypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystorePassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.password'] = ((orgApacheFelixHttpsKeystorePassword:any):string);
            }

            if (orgApacheFelixHttpsKeystorePasswordTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.password@TypeHint'] = ((orgApacheFelixHttpsKeystorePasswordTypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKey !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key'] = ((orgApacheFelixHttpsKeystoreKey:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKeyTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key@TypeHint'] = ((orgApacheFelixHttpsKeystoreKeyTypeHint:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key.password'] = ((orgApacheFelixHttpsKeystoreKeyPassword:any):string);
            }

            if (orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.keystore.key.password@TypeHint'] = ((orgApacheFelixHttpsKeystoreKeyPasswordTypeHint:any):string);
            }

            if (orgApacheFelixHttpsTruststore !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore'] = ((orgApacheFelixHttpsTruststore:any):string);
            }

            if (orgApacheFelixHttpsTruststoreTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore@TypeHint'] = ((orgApacheFelixHttpsTruststoreTypeHint:any):string);
            }

            if (orgApacheFelixHttpsTruststorePassword !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore.password'] = ((orgApacheFelixHttpsTruststorePassword:any):string);
            }

            if (orgApacheFelixHttpsTruststorePasswordTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.truststore.password@TypeHint'] = ((orgApacheFelixHttpsTruststorePasswordTypeHint:any):string);
            }

            if (orgApacheFelixHttpsClientcertificate !== undefined) {
                localVarQueryParameter['org.apache.felix.https.clientcertificate'] = ((orgApacheFelixHttpsClientcertificate:any):string);
            }

            if (orgApacheFelixHttpsClientcertificateTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.clientcertificate@TypeHint'] = ((orgApacheFelixHttpsClientcertificateTypeHint:any):string);
            }

            if (orgApacheFelixHttpsEnable !== undefined) {
                localVarQueryParameter['org.apache.felix.https.enable'] = ((orgApacheFelixHttpsEnable:any):string);
            }

            if (orgApacheFelixHttpsEnableTypeHint !== undefined) {
                localVarQueryParameter['org.apache.felix.https.enable@TypeHint'] = ((orgApacheFelixHttpsEnableTypeHint:any):string);
            }

            if (orgOsgiServiceHttpPortSecure !== undefined) {
                localVarQueryParameter['org.osgi.service.http.port.secure'] = ((orgOsgiServiceHttpPortSecure:any):string);
            }

            if (orgOsgiServiceHttpPortSecureTypeHint !== undefined) {
                localVarQueryParameter['org.osgi.service.http.port.secure@TypeHint'] = ((orgOsgiServiceHttpPortSecureTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.http.proxyconfigurator.config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (proxyHost !== undefined) {
                localVarQueryParameter['proxy.host'] = ((proxyHost:any):string);
            }

            if (proxyHostTypeHint !== undefined) {
                localVarQueryParameter['proxy.host@TypeHint'] = ((proxyHostTypeHint:any):string);
            }

            if (proxyPort !== undefined) {
                localVarQueryParameter['proxy.port'] = ((proxyPort:any):string);
            }

            if (proxyPortTypeHint !== undefined) {
                localVarQueryParameter['proxy.port@TypeHint'] = ((proxyPortTypeHint:any):string);
            }

            if (proxyExceptions) {
                localVarQueryParameter['proxy.exceptions'] = proxyExceptions;
            }

            if (proxyExceptionsTypeHint !== undefined) {
                localVarQueryParameter['proxy.exceptions@TypeHint'] = ((proxyExceptionsTypeHint:any):string);
            }

            if (proxyEnabled !== undefined) {
                localVarQueryParameter['proxy.enabled'] = ((proxyEnabled:any):string);
            }

            if (proxyEnabledTypeHint !== undefined) {
                localVarQueryParameter['proxy.enabled@TypeHint'] = ((proxyEnabledTypeHint:any):string);
            }

            if (proxyUser !== undefined) {
                localVarQueryParameter['proxy.user'] = ((proxyUser:any):string);
            }

            if (proxyUserTypeHint !== undefined) {
                localVarQueryParameter['proxy.user@TypeHint'] = ((proxyUserTypeHint:any):string);
            }

            if (proxyPassword !== undefined) {
                localVarQueryParameter['proxy.password'] = ((proxyPassword:any):string);
            }

            if (proxyPasswordTypeHint !== undefined) {
                localVarQueryParameter['proxy.password@TypeHint'] = ((proxyPasswordTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (alias !== undefined) {
                localVarQueryParameter['alias'] = ((alias:any):string);
            }

            if (aliasTypeHint !== undefined) {
                localVarQueryParameter['alias@TypeHint'] = ((aliasTypeHint:any):string);
            }

            if (davCreateAbsoluteUri !== undefined) {
                localVarQueryParameter['dav.create-absolute-uri'] = ((davCreateAbsoluteUri:any):string);
            }

            if (davCreateAbsoluteUriTypeHint !== undefined) {
                localVarQueryParameter['dav.create-absolute-uri@TypeHint'] = ((davCreateAbsoluteUriTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jsonMaximumresults !== undefined) {
                localVarQueryParameter['json.maximumresults'] = ((jsonMaximumresults:any):string);
            }

            if (jsonMaximumresultsTypeHint !== undefined) {
                localVarQueryParameter['json.maximumresults@TypeHint'] = ((jsonMaximumresultsTypeHint:any):string);
            }

            if (enableHtml !== undefined) {
                localVarQueryParameter['enable.html'] = ((enableHtml:any):string);
            }

            if (enableHtmlTypeHint !== undefined) {
                localVarQueryParameter['enable.html@TypeHint'] = ((enableHtmlTypeHint:any):string);
            }

            if (enableTxt !== undefined) {
                localVarQueryParameter['enable.txt'] = ((enableTxt:any):string);
            }

            if (enableTxtTypeHint !== undefined) {
                localVarQueryParameter['enable.txt@TypeHint'] = ((enableTxtTypeHint:any):string);
            }

            if (enableXml !== undefined) {
                localVarQueryParameter['enable.xml'] = ((enableXml:any):string);
            }

            if (enableXmlTypeHint !== undefined) {
                localVarQueryParameter['enable.xml@TypeHint'] = ((enableXmlTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (allowEmpty !== undefined) {
                localVarQueryParameter['allow.empty'] = ((allowEmpty:any):string);
            }

            if (allowEmptyTypeHint !== undefined) {
                localVarQueryParameter['allow.empty@TypeHint'] = ((allowEmptyTypeHint:any):string);
            }

            if (allowHosts !== undefined) {
                localVarQueryParameter['allow.hosts'] = ((allowHosts:any):string);
            }

            if (allowHostsTypeHint !== undefined) {
                localVarQueryParameter['allow.hosts@TypeHint'] = ((allowHostsTypeHint:any):string);
            }

            if (allowHostsRegexp !== undefined) {
                localVarQueryParameter['allow.hosts.regexp'] = ((allowHostsRegexp:any):string);
            }

            if (allowHostsRegexpTypeHint !== undefined) {
                localVarQueryParameter['allow.hosts.regexp@TypeHint'] = ((allowHostsRegexpTypeHint:any):string);
            }

            if (filterMethods !== undefined) {
                localVarQueryParameter['filter.methods'] = ((filterMethods:any):string);
            }

            if (filterMethodsTypeHint !== undefined) {
                localVarQueryParameter['filter.methods@TypeHint'] = ((filterMethodsTypeHint:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigProperty(configNodeName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'configNodeName' is not null or undefined
            if (configNodeName === null || configNodeName === undefined) {
                throw new RequiredError('configNodeName','Required parameter configNodeName was null or undefined when calling postConfigProperty.');
            }
            const localVarPath = `/apps/system/config/{configNodeName}`
                .replace(`{${"configNodeName"}}`, encodeURIComponent(String(configNodeName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postNode.');
            }
            const localVarPath = `/{path}/{name}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (operation !== undefined) {
                localVarQueryParameter[':operation'] = ((operation:any):string);
            }

            if (deleteAuthorizable !== undefined) {
                localVarQueryParameter['deleteAuthorizable'] = ((deleteAuthorizable:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postNodeRw.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postNodeRw.');
            }
            const localVarPath = `/{path}/{name}.rw.html`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (addMembers !== undefined) {
                localVarQueryParameter['addMembers'] = ((addMembers:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPath(path: string, jcrprimaryType: string, name: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postPath.');
            }
            // verify required parameter 'jcrprimaryType' is not null or undefined
            if (jcrprimaryType === null || jcrprimaryType === undefined) {
                throw new RequiredError('jcrprimaryType','Required parameter jcrprimaryType was null or undefined when calling postPath.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postPath.');
            }
            const localVarPath = `/{path}/`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jcrprimaryType !== undefined) {
                localVarQueryParameter['jcr:primaryType'] = ((jcrprimaryType:any):string);
            }

            if (name !== undefined) {
                localVarQueryParameter[':name'] = ((name:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postQuery.');
            }
            // verify required parameter 'pLimit' is not null or undefined
            if (pLimit === null || pLimit === undefined) {
                throw new RequiredError('pLimit','Required parameter pLimit was null or undefined when calling postQuery.');
            }
            // verify required parameter '_1property' is not null or undefined
            if (_1property === null || _1property === undefined) {
                throw new RequiredError('_1property','Required parameter _1property was null or undefined when calling postQuery.');
            }
            // verify required parameter '_1propertyValue' is not null or undefined
            if (_1propertyValue === null || _1propertyValue === undefined) {
                throw new RequiredError('_1propertyValue','Required parameter _1propertyValue was null or undefined when calling postQuery.');
            }
            const localVarPath = `/bin/querybuilder.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            if (pLimit !== undefined) {
                localVarQueryParameter['p.limit'] = ((pLimit:any):string);
            }

            if (_1property !== undefined) {
                localVarQueryParameter['1_property'] = ((_1property:any):string);
            }

            if (_1propertyValue !== undefined) {
                localVarQueryParameter['1_property.value'] = ((_1propertyValue:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'ignoredeactivated' is not null or undefined
            if (ignoredeactivated === null || ignoredeactivated === undefined) {
                throw new RequiredError('ignoredeactivated','Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
            }
            // verify required parameter 'onlymodified' is not null or undefined
            if (onlymodified === null || onlymodified === undefined) {
                throw new RequiredError('onlymodified','Required parameter onlymodified was null or undefined when calling postTreeActivation.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling postTreeActivation.');
            }
            const localVarPath = `/etc/replication/treeactivation.html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ignoredeactivated !== undefined) {
                localVarQueryParameter['ignoredeactivated'] = ((ignoredeactivated:any):string);
            }

            if (onlymodified !== undefined) {
                localVarQueryParameter['onlymodified'] = ((onlymodified:any):string);
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = ((path:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options: RequestOptions): FetchArgs {
            const localVarPath = `/libs/granite/security/post/truststore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (operation !== undefined) {
                localVarQueryParameter[':operation'] = ((operation:any):string);
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['newPassword'] = ((newPassword:any):string);
            }

            if (rePassword !== undefined) {
                localVarQueryParameter['rePassword'] = ((rePassword:any):string);
            }

            if (keyStoreType !== undefined) {
                localVarQueryParameter['keyStoreType'] = ((keyStoreType:any):string);
            }

            if (removeAlias !== undefined) {
                localVarQueryParameter['removeAlias'] = ((removeAlias:any):string);
            }

            if (certificate !== undefined) {
                localVarFormParams.set('certificate', ((certificate:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options: RequestOptions): FetchArgs {
            const localVarPath = `/etc/truststore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication aemAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (truststoreP12 !== undefined) {
                localVarFormParams.set('truststore.p12', ((truststoreP12:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SlingApiType = { 
    deleteAgent(runmode: string, name: string, options?: RequestOptions): Promise<Response>,

    deleteNode(path: string, name: string, options?: RequestOptions): Promise<Response>,

    getAgent(runmode: string, name: string, options?: RequestOptions): Promise<Response>,

    getAgents(runmode: string, options?: RequestOptions): Promise<string>,

    getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions): Promise<KeystoreInfo>,

    getKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions): Promise<any>,

    getNode(path: string, name: string, options?: RequestOptions): Promise<Response>,

    getPackage(group: string, name: string, version: string, options?: RequestOptions): Promise<any>,

    getPackageFilter(group: string, name: string, version: string, options?: RequestOptions): Promise<string>,

    getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions): Promise<string>,

    getTruststore(options?: RequestOptions): Promise<any>,

    getTruststoreInfo(options?: RequestOptions): Promise<TruststoreInfo>,

    postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, options?: RequestOptions): Promise<Response>,

    postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: RequestOptions): Promise<KeystoreInfo>,

    postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, options?: RequestOptions): Promise<string>,

    postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, options?: RequestOptions): Promise<Response>,

    postConfigProperty(configNodeName: string, options?: RequestOptions): Promise<Response>,

    postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: any, options?: RequestOptions): Promise<Response>,

    postNodeRw(path: string, name: string, addMembers?: string, options?: RequestOptions): Promise<Response>,

    postPath(path: string, jcrprimaryType: string, name: string, options?: RequestOptions): Promise<Response>,

    postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions): Promise<string>,

    postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: RequestOptions): Promise<Response>,

    postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: RequestOptions): Promise<string>,

    postTruststorePKCS12(truststoreP12?: any, options?: RequestOptions): Promise<string>,
}

/**
 * SlingApi - factory function to inject configuration 
 * @export
 */
export const SlingApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SlingApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        deleteAgent(runmode: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).deleteAgent(runmode, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        deleteNode(path: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).deleteNode(path, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgent(runmode: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAgent(runmode, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAgents(runmode: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAgents(runmode, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getAuthorizableKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions = {}): Promise<KeystoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getAuthorizableKeystore(intermediatePath, authorizableId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getKeystore(intermediatePath: string, authorizableId: string, options?: RequestOptions = {}): Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getKeystore(intermediatePath, authorizableId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getNode(path: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getNode(path, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackage(group: string, name: string, version: string, options?: RequestOptions = {}): Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getPackage(group, name, version, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getPackageFilter(group: string, name: string, version: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getPackageFilter(group, name, version, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getQuery(path, pLimit, _1property, _1propertyValue, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststore(options?: RequestOptions = {}): Promise<any> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getTruststore(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        getTruststoreInfo(options?: RequestOptions = {}): Promise<TruststoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).getTruststoreInfo(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAgent(runmode, name, jcrcontentCqdistribute, jcrcontentCqdistributeTypeHint, jcrcontentCqname, jcrcontentCqtemplate, jcrcontentEnabled, jcrcontentJcrdescription, jcrcontentJcrlastModified, jcrcontentJcrlastModifiedBy, jcrcontentJcrmixinTypes, jcrcontentJcrtitle, jcrcontentLogLevel, jcrcontentNoStatusUpdate, jcrcontentNoVersioning, jcrcontentProtocolConnectTimeout, jcrcontentProtocolHTTPConnectionClosed, jcrcontentProtocolHTTPExpired, jcrcontentProtocolHTTPHeaders, jcrcontentProtocolHTTPHeadersTypeHint, jcrcontentProtocolHTTPMethod, jcrcontentProtocolHTTPSRelaxed, jcrcontentProtocolInterface, jcrcontentProtocolSocketTimeout, jcrcontentProtocolVersion, jcrcontentProxyNTLMDomain, jcrcontentProxyNTLMHost, jcrcontentProxyHost, jcrcontentProxyPassword, jcrcontentProxyPort, jcrcontentProxyUser, jcrcontentQueueBatchMaxSize, jcrcontentQueueBatchMode, jcrcontentQueueBatchWaitTime, jcrcontentRetryDelay, jcrcontentReverseReplication, jcrcontentSerializationType, jcrcontentSlingresourceType, jcrcontentSsl, jcrcontentTransportNTLMDomain, jcrcontentTransportNTLMHost, jcrcontentTransportPassword, jcrcontentTransportUri, jcrcontentTransportUser, jcrcontentTriggerDistribute, jcrcontentTriggerModified, jcrcontentTriggerOnOffTime, jcrcontentTriggerReceive, jcrcontentTriggerSpecific, jcrcontentUserId, jcrprimaryType, operation, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: any, pk?: any, keyStore?: any, options?: RequestOptions = {}): Promise<KeystoreInfo> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAuthorizableKeystore(intermediatePath, authorizableId, operation, currentPassword, newPassword, rePassword, keyPassword, keyStorePass, alias, newAlias, removeAlias, certChain, pk, keyStore, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postAuthorizables(authorizableId, intermediatePath, createUser, createGroup, reppassword, profileGivenName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword, keyStorePasswordTypeHint, serviceRanking, serviceRankingTypeHint, idpHttpRedirect, idpHttpRedirectTypeHint, createUser, createUserTypeHint, defaultRedirectUrl, defaultRedirectUrlTypeHint, userIDAttribute, userIDAttributeTypeHint, defaultGroups, defaultGroupsTypeHint, idpCertAlias, idpCertAliasTypeHint, addGroupMemberships, addGroupMembershipsTypeHint, path, pathTypeHint, synchronizeAttributes, synchronizeAttributesTypeHint, clockTolerance, clockToleranceTypeHint, groupMembershipAttribute, groupMembershipAttributeTypeHint, idpUrl, idpUrlTypeHint, logoutUrl, logoutUrlTypeHint, serviceProviderEntityId, serviceProviderEntityIdTypeHint, assertionConsumerServiceURL, assertionConsumerServiceURLTypeHint, handleLogout, handleLogoutTypeHint, spPrivateKeyAlias, spPrivateKeyAliasTypeHint, useEncryption, useEncryptionTypeHint, nameIdFormat, nameIdFormatTypeHint, digestMethod, digestMethodTypeHint, signatureMethod, signatureMethodTypeHint, userIntermediatePath, userIntermediatePathTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio, orgApacheFelixHttpsNioTypeHint, orgApacheFelixHttpsKeystore, orgApacheFelixHttpsKeystoreTypeHint, orgApacheFelixHttpsKeystorePassword, orgApacheFelixHttpsKeystorePasswordTypeHint, orgApacheFelixHttpsKeystoreKey, orgApacheFelixHttpsKeystoreKeyTypeHint, orgApacheFelixHttpsKeystoreKeyPassword, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, orgApacheFelixHttpsTruststore, orgApacheFelixHttpsTruststoreTypeHint, orgApacheFelixHttpsTruststorePassword, orgApacheFelixHttpsTruststorePasswordTypeHint, orgApacheFelixHttpsClientcertificate, orgApacheFelixHttpsClientcertificateTypeHint, orgApacheFelixHttpsEnable, orgApacheFelixHttpsEnableTypeHint, orgOsgiServiceHttpPortSecure, orgOsgiServiceHttpPortSecureTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheHttpComponentsProxyConfiguration(proxyHost, proxyHostTypeHint, proxyPort, proxyPortTypeHint, proxyExceptions, proxyExceptionsTypeHint, proxyEnabled, proxyEnabledTypeHint, proxyUser, proxyUserTypeHint, proxyPassword, proxyPasswordTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingDavExServlet(alias, aliasTypeHint, davCreateAbsoluteUri, davCreateAbsoluteUriTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingGetServlet(jsonMaximumresults, jsonMaximumresultsTypeHint, enableHtml, enableHtmlTypeHint, enableTxt, enableTxtTypeHint, enableXml, enableXmlTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigApacheSlingReferrerFilter(allowEmpty, allowEmptyTypeHint, allowHosts, allowHostsTypeHint, allowHostsRegexp, allowHostsRegexpTypeHint, filterMethods, filterMethodsTypeHint, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postConfigProperty(configNodeName: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postConfigProperty(configNodeName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: any, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postNode(path, name, operation, deleteAuthorizable, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postNodeRw(path: string, name: string, addMembers?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postNodeRw(path, name, addMembers, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postPath(path: string, jcrprimaryType: string, name: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postPath(path, jcrprimaryType, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postQuery(path, pLimit, _1property, _1propertyValue, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTreeActivation(ignoredeactivated, onlymodified, path, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTruststore(operation, newPassword, rePassword, keyStoreType, removeAlias, certificate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        postTruststorePKCS12(truststoreP12?: any, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SlingApiFetchParamCreator(configuration).postTruststorePKCS12(truststoreP12, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    ConsoleApi: ConsoleApiType,

    CqApi: CqApiType,

    CrxApi: CrxApiType,

    CustomApi: CustomApiType,

    GraniteApi: GraniteApiType,

    SlingApi: SlingApiType,
 }
