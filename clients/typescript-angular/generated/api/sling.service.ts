/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { KeystoreInfo } from '../model/models';
import { TruststoreInfo } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class SlingService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * @param runmode 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAgent(runmode: string, name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public deleteAgent(runmode: string, name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public deleteAgent(runmode: string, name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public deleteAgent(runmode: string, name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling deleteAgent.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAgent.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteNode(path: string, name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public deleteNode(path: string, name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public deleteNode(path: string, name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public deleteNode(path: string, name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling deleteNode.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param runmode 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAgent(runmode: string, name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getAgent(runmode: string, name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getAgent(runmode: string, name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getAgent(runmode: string, name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgent.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAgent.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param runmode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAgents(runmode: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<string>;
    public getAgents(runmode: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<string>>;
    public getAgents(runmode: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<string>>;
    public getAgents(runmode: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling getAgents.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<string>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}.-1.json`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param intermediatePath 
     * @param authorizableId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<KeystoreInfo>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpResponse<KeystoreInfo>>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpEvent<KeystoreInfo>>;
    public getAuthorizableKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain'}): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/plain'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<KeystoreInfo>(`${this.configuration.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.json`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param intermediatePath 
     * @param authorizableId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<Blob>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<HttpResponse<Blob>>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<HttpEvent<Blob>>;
    public getKeystore(intermediatePath: string, authorizableId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling getKeystore.');
        }
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling getKeystore.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/octet-stream'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<Blob>(`${this.configuration.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}/keystore/store.p12`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNode(path: string, name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getNode(path: string, name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getNode(path: string, name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getNode(path: string, name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getNode.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNode.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param group 
     * @param name 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPackage(group: string, name: string, version: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<Blob>;
    public getPackage(group: string, name: string, version: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<HttpResponse<Blob>>;
    public getPackage(group: string, name: string, version: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<HttpEvent<Blob>>;
    public getPackage(group: string, name: string, version: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackage.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackage.');
        }
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackage.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/octet-stream'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<Blob>(`${this.configuration.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param group 
     * @param name 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPackageFilter(group: string, name: string, version: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<string>;
    public getPackageFilter(group: string, name: string, version: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<string>>;
    public getPackageFilter(group: string, name: string, version: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<string>>;
    public getPackageFilter(group: string, name: string, version: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getPackageFilter.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getPackageFilter.');
        }
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getPackageFilter.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<string>(`${this.configuration.basePath}/etc/packages/${encodeURIComponent(String(group))}/${encodeURIComponent(String(name))}-${encodeURIComponent(String(version))}.zip/jcr:content/vlt:definition/filter.tidy.2.json`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<string>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<string>>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<string>>;
    public getQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getQuery.');
        }
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling getQuery.');
        }
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling getQuery.');
        }
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling getQuery.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (path !== undefined && path !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>path, 'path');
        }
        if (pLimit !== undefined && pLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pLimit, 'p.limit');
        }
        if (_1property !== undefined && _1property !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_1property, '1_property');
        }
        if (_1propertyValue !== undefined && _1propertyValue !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_1propertyValue, '1_property.value');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<string>(`${this.configuration.basePath}/bin/querybuilder.json`,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTruststore(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<Blob>;
    public getTruststore(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<HttpResponse<Blob>>;
    public getTruststore(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<HttpEvent<Blob>>;
    public getTruststore(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/octet-stream'}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/octet-stream'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<Blob>(`${this.configuration.basePath}/etc/truststore/truststore.p12`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTruststoreInfo(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<TruststoreInfo>;
    public getTruststoreInfo(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<TruststoreInfo>>;
    public getTruststoreInfo(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<TruststoreInfo>>;
    public getTruststoreInfo(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<TruststoreInfo>(`${this.configuration.basePath}/libs/granite/security/truststore.json`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param runmode 
     * @param name 
     * @param jcrcontentCqdistribute 
     * @param jcrcontentCqdistributeTypeHint 
     * @param jcrcontentCqname 
     * @param jcrcontentCqtemplate 
     * @param jcrcontentEnabled 
     * @param jcrcontentJcrdescription 
     * @param jcrcontentJcrlastModified 
     * @param jcrcontentJcrlastModifiedBy 
     * @param jcrcontentJcrmixinTypes 
     * @param jcrcontentJcrtitle 
     * @param jcrcontentLogLevel 
     * @param jcrcontentNoStatusUpdate 
     * @param jcrcontentNoVersioning 
     * @param jcrcontentProtocolConnectTimeout 
     * @param jcrcontentProtocolHTTPConnectionClosed 
     * @param jcrcontentProtocolHTTPExpired 
     * @param jcrcontentProtocolHTTPHeaders 
     * @param jcrcontentProtocolHTTPHeadersTypeHint 
     * @param jcrcontentProtocolHTTPMethod 
     * @param jcrcontentProtocolHTTPSRelaxed 
     * @param jcrcontentProtocolInterface 
     * @param jcrcontentProtocolSocketTimeout 
     * @param jcrcontentProtocolVersion 
     * @param jcrcontentProxyNTLMDomain 
     * @param jcrcontentProxyNTLMHost 
     * @param jcrcontentProxyHost 
     * @param jcrcontentProxyPassword 
     * @param jcrcontentProxyPort 
     * @param jcrcontentProxyUser 
     * @param jcrcontentQueueBatchMaxSize 
     * @param jcrcontentQueueBatchMode 
     * @param jcrcontentQueueBatchWaitTime 
     * @param jcrcontentRetryDelay 
     * @param jcrcontentReverseReplication 
     * @param jcrcontentSerializationType 
     * @param jcrcontentSlingresourceType 
     * @param jcrcontentSsl 
     * @param jcrcontentTransportNTLMDomain 
     * @param jcrcontentTransportNTLMHost 
     * @param jcrcontentTransportPassword 
     * @param jcrcontentTransportUri 
     * @param jcrcontentTransportUser 
     * @param jcrcontentTriggerDistribute 
     * @param jcrcontentTriggerModified 
     * @param jcrcontentTriggerOnOffTime 
     * @param jcrcontentTriggerReceive 
     * @param jcrcontentTriggerSpecific 
     * @param jcrcontentUserId 
     * @param jcrprimaryType 
     * @param operation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postAgent(runmode: string, name: string, jcrcontentCqdistribute?: boolean, jcrcontentCqdistributeTypeHint?: string, jcrcontentCqname?: string, jcrcontentCqtemplate?: string, jcrcontentEnabled?: boolean, jcrcontentJcrdescription?: string, jcrcontentJcrlastModified?: string, jcrcontentJcrlastModifiedBy?: string, jcrcontentJcrmixinTypes?: string, jcrcontentJcrtitle?: string, jcrcontentLogLevel?: string, jcrcontentNoStatusUpdate?: boolean, jcrcontentNoVersioning?: boolean, jcrcontentProtocolConnectTimeout?: number, jcrcontentProtocolHTTPConnectionClosed?: boolean, jcrcontentProtocolHTTPExpired?: string, jcrcontentProtocolHTTPHeaders?: Array<string>, jcrcontentProtocolHTTPHeadersTypeHint?: string, jcrcontentProtocolHTTPMethod?: string, jcrcontentProtocolHTTPSRelaxed?: boolean, jcrcontentProtocolInterface?: string, jcrcontentProtocolSocketTimeout?: number, jcrcontentProtocolVersion?: string, jcrcontentProxyNTLMDomain?: string, jcrcontentProxyNTLMHost?: string, jcrcontentProxyHost?: string, jcrcontentProxyPassword?: string, jcrcontentProxyPort?: number, jcrcontentProxyUser?: string, jcrcontentQueueBatchMaxSize?: number, jcrcontentQueueBatchMode?: string, jcrcontentQueueBatchWaitTime?: number, jcrcontentRetryDelay?: string, jcrcontentReverseReplication?: boolean, jcrcontentSerializationType?: string, jcrcontentSlingresourceType?: string, jcrcontentSsl?: string, jcrcontentTransportNTLMDomain?: string, jcrcontentTransportNTLMHost?: string, jcrcontentTransportPassword?: string, jcrcontentTransportUri?: string, jcrcontentTransportUser?: string, jcrcontentTriggerDistribute?: boolean, jcrcontentTriggerModified?: boolean, jcrcontentTriggerOnOffTime?: boolean, jcrcontentTriggerReceive?: boolean, jcrcontentTriggerSpecific?: boolean, jcrcontentUserId?: string, jcrprimaryType?: string, operation?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (runmode === null || runmode === undefined) {
            throw new Error('Required parameter runmode was null or undefined when calling postAgent.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAgent.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (jcrcontentCqdistribute !== undefined && jcrcontentCqdistribute !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentCqdistribute, 'jcr:content/cq:distribute');
        }
        if (jcrcontentCqdistributeTypeHint !== undefined && jcrcontentCqdistributeTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentCqdistributeTypeHint, 'jcr:content/cq:distribute@TypeHint');
        }
        if (jcrcontentCqname !== undefined && jcrcontentCqname !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentCqname, 'jcr:content/cq:name');
        }
        if (jcrcontentCqtemplate !== undefined && jcrcontentCqtemplate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentCqtemplate, 'jcr:content/cq:template');
        }
        if (jcrcontentEnabled !== undefined && jcrcontentEnabled !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentEnabled, 'jcr:content/enabled');
        }
        if (jcrcontentJcrdescription !== undefined && jcrcontentJcrdescription !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentJcrdescription, 'jcr:content/jcr:description');
        }
        if (jcrcontentJcrlastModified !== undefined && jcrcontentJcrlastModified !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentJcrlastModified, 'jcr:content/jcr:lastModified');
        }
        if (jcrcontentJcrlastModifiedBy !== undefined && jcrcontentJcrlastModifiedBy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentJcrlastModifiedBy, 'jcr:content/jcr:lastModifiedBy');
        }
        if (jcrcontentJcrmixinTypes !== undefined && jcrcontentJcrmixinTypes !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentJcrmixinTypes, 'jcr:content/jcr:mixinTypes');
        }
        if (jcrcontentJcrtitle !== undefined && jcrcontentJcrtitle !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentJcrtitle, 'jcr:content/jcr:title');
        }
        if (jcrcontentLogLevel !== undefined && jcrcontentLogLevel !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentLogLevel, 'jcr:content/logLevel');
        }
        if (jcrcontentNoStatusUpdate !== undefined && jcrcontentNoStatusUpdate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentNoStatusUpdate, 'jcr:content/noStatusUpdate');
        }
        if (jcrcontentNoVersioning !== undefined && jcrcontentNoVersioning !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentNoVersioning, 'jcr:content/noVersioning');
        }
        if (jcrcontentProtocolConnectTimeout !== undefined && jcrcontentProtocolConnectTimeout !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolConnectTimeout, 'jcr:content/protocolConnectTimeout');
        }
        if (jcrcontentProtocolHTTPConnectionClosed !== undefined && jcrcontentProtocolHTTPConnectionClosed !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolHTTPConnectionClosed, 'jcr:content/protocolHTTPConnectionClosed');
        }
        if (jcrcontentProtocolHTTPExpired !== undefined && jcrcontentProtocolHTTPExpired !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolHTTPExpired, 'jcr:content/protocolHTTPExpired');
        }
        if (jcrcontentProtocolHTTPHeaders) {
            jcrcontentProtocolHTTPHeaders.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'jcr:content/protocolHTTPHeaders');
            })
        }
        if (jcrcontentProtocolHTTPHeadersTypeHint !== undefined && jcrcontentProtocolHTTPHeadersTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolHTTPHeadersTypeHint, 'jcr:content/protocolHTTPHeaders@TypeHint');
        }
        if (jcrcontentProtocolHTTPMethod !== undefined && jcrcontentProtocolHTTPMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolHTTPMethod, 'jcr:content/protocolHTTPMethod');
        }
        if (jcrcontentProtocolHTTPSRelaxed !== undefined && jcrcontentProtocolHTTPSRelaxed !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolHTTPSRelaxed, 'jcr:content/protocolHTTPSRelaxed');
        }
        if (jcrcontentProtocolInterface !== undefined && jcrcontentProtocolInterface !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolInterface, 'jcr:content/protocolInterface');
        }
        if (jcrcontentProtocolSocketTimeout !== undefined && jcrcontentProtocolSocketTimeout !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolSocketTimeout, 'jcr:content/protocolSocketTimeout');
        }
        if (jcrcontentProtocolVersion !== undefined && jcrcontentProtocolVersion !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProtocolVersion, 'jcr:content/protocolVersion');
        }
        if (jcrcontentProxyNTLMDomain !== undefined && jcrcontentProxyNTLMDomain !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProxyNTLMDomain, 'jcr:content/proxyNTLMDomain');
        }
        if (jcrcontentProxyNTLMHost !== undefined && jcrcontentProxyNTLMHost !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProxyNTLMHost, 'jcr:content/proxyNTLMHost');
        }
        if (jcrcontentProxyHost !== undefined && jcrcontentProxyHost !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProxyHost, 'jcr:content/proxyHost');
        }
        if (jcrcontentProxyPassword !== undefined && jcrcontentProxyPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProxyPassword, 'jcr:content/proxyPassword');
        }
        if (jcrcontentProxyPort !== undefined && jcrcontentProxyPort !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProxyPort, 'jcr:content/proxyPort');
        }
        if (jcrcontentProxyUser !== undefined && jcrcontentProxyUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentProxyUser, 'jcr:content/proxyUser');
        }
        if (jcrcontentQueueBatchMaxSize !== undefined && jcrcontentQueueBatchMaxSize !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentQueueBatchMaxSize, 'jcr:content/queueBatchMaxSize');
        }
        if (jcrcontentQueueBatchMode !== undefined && jcrcontentQueueBatchMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentQueueBatchMode, 'jcr:content/queueBatchMode');
        }
        if (jcrcontentQueueBatchWaitTime !== undefined && jcrcontentQueueBatchWaitTime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentQueueBatchWaitTime, 'jcr:content/queueBatchWaitTime');
        }
        if (jcrcontentRetryDelay !== undefined && jcrcontentRetryDelay !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentRetryDelay, 'jcr:content/retryDelay');
        }
        if (jcrcontentReverseReplication !== undefined && jcrcontentReverseReplication !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentReverseReplication, 'jcr:content/reverseReplication');
        }
        if (jcrcontentSerializationType !== undefined && jcrcontentSerializationType !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentSerializationType, 'jcr:content/serializationType');
        }
        if (jcrcontentSlingresourceType !== undefined && jcrcontentSlingresourceType !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentSlingresourceType, 'jcr:content/sling:resourceType');
        }
        if (jcrcontentSsl !== undefined && jcrcontentSsl !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentSsl, 'jcr:content/ssl');
        }
        if (jcrcontentTransportNTLMDomain !== undefined && jcrcontentTransportNTLMDomain !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTransportNTLMDomain, 'jcr:content/transportNTLMDomain');
        }
        if (jcrcontentTransportNTLMHost !== undefined && jcrcontentTransportNTLMHost !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTransportNTLMHost, 'jcr:content/transportNTLMHost');
        }
        if (jcrcontentTransportPassword !== undefined && jcrcontentTransportPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTransportPassword, 'jcr:content/transportPassword');
        }
        if (jcrcontentTransportUri !== undefined && jcrcontentTransportUri !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTransportUri, 'jcr:content/transportUri');
        }
        if (jcrcontentTransportUser !== undefined && jcrcontentTransportUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTransportUser, 'jcr:content/transportUser');
        }
        if (jcrcontentTriggerDistribute !== undefined && jcrcontentTriggerDistribute !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTriggerDistribute, 'jcr:content/triggerDistribute');
        }
        if (jcrcontentTriggerModified !== undefined && jcrcontentTriggerModified !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTriggerModified, 'jcr:content/triggerModified');
        }
        if (jcrcontentTriggerOnOffTime !== undefined && jcrcontentTriggerOnOffTime !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTriggerOnOffTime, 'jcr:content/triggerOnOffTime');
        }
        if (jcrcontentTriggerReceive !== undefined && jcrcontentTriggerReceive !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTriggerReceive, 'jcr:content/triggerReceive');
        }
        if (jcrcontentTriggerSpecific !== undefined && jcrcontentTriggerSpecific !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentTriggerSpecific, 'jcr:content/triggerSpecific');
        }
        if (jcrcontentUserId !== undefined && jcrcontentUserId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrcontentUserId, 'jcr:content/userId');
        }
        if (jcrprimaryType !== undefined && jcrprimaryType !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrprimaryType, 'jcr:primaryType');
        }
        if (operation !== undefined && operation !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>operation, ':operation');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/etc/replication/agents.${encodeURIComponent(String(runmode))}/${encodeURIComponent(String(name))}`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param intermediatePath 
     * @param authorizableId 
     * @param operation 
     * @param currentPassword 
     * @param newPassword 
     * @param rePassword 
     * @param keyPassword 
     * @param keyStorePass 
     * @param alias 
     * @param newAlias 
     * @param removeAlias 
     * @param certChain 
     * @param pk 
     * @param keyStore 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<KeystoreInfo>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpResponse<KeystoreInfo>>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpEvent<KeystoreInfo>>;
    public postAuthorizableKeystore(intermediatePath: string, authorizableId: string, operation?: string, currentPassword?: string, newPassword?: string, rePassword?: string, keyPassword?: string, keyStorePass?: string, alias?: string, newAlias?: string, removeAlias?: string, certChain?: Blob, pk?: Blob, keyStore?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain'}): Observable<any> {
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (operation !== undefined && operation !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>operation, ':operation');
        }
        if (currentPassword !== undefined && currentPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>currentPassword, 'currentPassword');
        }
        if (newPassword !== undefined && newPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>newPassword, 'newPassword');
        }
        if (rePassword !== undefined && rePassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>rePassword, 'rePassword');
        }
        if (keyPassword !== undefined && keyPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>keyPassword, 'keyPassword');
        }
        if (keyStorePass !== undefined && keyStorePass !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>keyStorePass, 'keyStorePass');
        }
        if (alias !== undefined && alias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>alias, 'alias');
        }
        if (newAlias !== undefined && newAlias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>newAlias, 'newAlias');
        }
        if (removeAlias !== undefined && removeAlias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>removeAlias, 'removeAlias');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/plain'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<KeystoreInfo>(`${this.configuration.basePath}/${encodeURIComponent(String(intermediatePath))}/${encodeURIComponent(String(authorizableId))}.ks.html`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param authorizableId 
     * @param intermediatePath 
     * @param createUser 
     * @param createGroup 
     * @param reppassword 
     * @param profileGivenName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/html'}): Observable<string>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/html'}): Observable<HttpResponse<string>>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/html'}): Observable<HttpEvent<string>>;
    public postAuthorizables(authorizableId: string, intermediatePath: string, createUser?: string, createGroup?: string, reppassword?: string, profileGivenName?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/html'}): Observable<any> {
        if (authorizableId === null || authorizableId === undefined) {
            throw new Error('Required parameter authorizableId was null or undefined when calling postAuthorizables.');
        }
        if (intermediatePath === null || intermediatePath === undefined) {
            throw new Error('Required parameter intermediatePath was null or undefined when calling postAuthorizables.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (authorizableId !== undefined && authorizableId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>authorizableId, 'authorizableId');
        }
        if (intermediatePath !== undefined && intermediatePath !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>intermediatePath, 'intermediatePath');
        }
        if (createUser !== undefined && createUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>createUser, 'createUser');
        }
        if (createGroup !== undefined && createGroup !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>createGroup, 'createGroup');
        }
        if (reppassword !== undefined && reppassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>reppassword, 'rep:password');
        }
        if (profileGivenName !== undefined && profileGivenName !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>profileGivenName, 'profile/givenName');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/html'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<string>(`${this.configuration.basePath}/libs/granite/security/post/authorizables`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param keyStorePassword 
     * @param keyStorePasswordTypeHint 
     * @param serviceRanking 
     * @param serviceRankingTypeHint 
     * @param idpHttpRedirect 
     * @param idpHttpRedirectTypeHint 
     * @param createUser 
     * @param createUserTypeHint 
     * @param defaultRedirectUrl 
     * @param defaultRedirectUrlTypeHint 
     * @param userIDAttribute 
     * @param userIDAttributeTypeHint 
     * @param defaultGroups 
     * @param defaultGroupsTypeHint 
     * @param idpCertAlias 
     * @param idpCertAliasTypeHint 
     * @param addGroupMemberships 
     * @param addGroupMembershipsTypeHint 
     * @param path 
     * @param pathTypeHint 
     * @param synchronizeAttributes 
     * @param synchronizeAttributesTypeHint 
     * @param clockTolerance 
     * @param clockToleranceTypeHint 
     * @param groupMembershipAttribute 
     * @param groupMembershipAttributeTypeHint 
     * @param idpUrl 
     * @param idpUrlTypeHint 
     * @param logoutUrl 
     * @param logoutUrlTypeHint 
     * @param serviceProviderEntityId 
     * @param serviceProviderEntityIdTypeHint 
     * @param assertionConsumerServiceURL 
     * @param assertionConsumerServiceURLTypeHint 
     * @param handleLogout 
     * @param handleLogoutTypeHint 
     * @param spPrivateKeyAlias 
     * @param spPrivateKeyAliasTypeHint 
     * @param useEncryption 
     * @param useEncryptionTypeHint 
     * @param nameIdFormat 
     * @param nameIdFormatTypeHint 
     * @param digestMethod 
     * @param digestMethodTypeHint 
     * @param signatureMethod 
     * @param signatureMethodTypeHint 
     * @param userIntermediatePath 
     * @param userIntermediatePathTypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigAdobeGraniteSamlAuthenticationHandler(keyStorePassword?: string, keyStorePasswordTypeHint?: string, serviceRanking?: number, serviceRankingTypeHint?: string, idpHttpRedirect?: boolean, idpHttpRedirectTypeHint?: string, createUser?: boolean, createUserTypeHint?: string, defaultRedirectUrl?: string, defaultRedirectUrlTypeHint?: string, userIDAttribute?: string, userIDAttributeTypeHint?: string, defaultGroups?: Array<string>, defaultGroupsTypeHint?: string, idpCertAlias?: string, idpCertAliasTypeHint?: string, addGroupMemberships?: boolean, addGroupMembershipsTypeHint?: string, path?: Array<string>, pathTypeHint?: string, synchronizeAttributes?: Array<string>, synchronizeAttributesTypeHint?: string, clockTolerance?: number, clockToleranceTypeHint?: string, groupMembershipAttribute?: string, groupMembershipAttributeTypeHint?: string, idpUrl?: string, idpUrlTypeHint?: string, logoutUrl?: string, logoutUrlTypeHint?: string, serviceProviderEntityId?: string, serviceProviderEntityIdTypeHint?: string, assertionConsumerServiceURL?: string, assertionConsumerServiceURLTypeHint?: string, handleLogout?: boolean, handleLogoutTypeHint?: string, spPrivateKeyAlias?: string, spPrivateKeyAliasTypeHint?: string, useEncryption?: boolean, useEncryptionTypeHint?: string, nameIdFormat?: string, nameIdFormatTypeHint?: string, digestMethod?: string, digestMethodTypeHint?: string, signatureMethod?: string, signatureMethodTypeHint?: string, userIntermediatePath?: string, userIntermediatePathTypeHint?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (keyStorePassword !== undefined && keyStorePassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>keyStorePassword, 'keyStorePassword');
        }
        if (keyStorePasswordTypeHint !== undefined && keyStorePasswordTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>keyStorePasswordTypeHint, 'keyStorePassword@TypeHint');
        }
        if (serviceRanking !== undefined && serviceRanking !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>serviceRanking, 'service.ranking');
        }
        if (serviceRankingTypeHint !== undefined && serviceRankingTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>serviceRankingTypeHint, 'service.ranking@TypeHint');
        }
        if (idpHttpRedirect !== undefined && idpHttpRedirect !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idpHttpRedirect, 'idpHttpRedirect');
        }
        if (idpHttpRedirectTypeHint !== undefined && idpHttpRedirectTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idpHttpRedirectTypeHint, 'idpHttpRedirect@TypeHint');
        }
        if (createUser !== undefined && createUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>createUser, 'createUser');
        }
        if (createUserTypeHint !== undefined && createUserTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>createUserTypeHint, 'createUser@TypeHint');
        }
        if (defaultRedirectUrl !== undefined && defaultRedirectUrl !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>defaultRedirectUrl, 'defaultRedirectUrl');
        }
        if (defaultRedirectUrlTypeHint !== undefined && defaultRedirectUrlTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>defaultRedirectUrlTypeHint, 'defaultRedirectUrl@TypeHint');
        }
        if (userIDAttribute !== undefined && userIDAttribute !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userIDAttribute, 'userIDAttribute');
        }
        if (userIDAttributeTypeHint !== undefined && userIDAttributeTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userIDAttributeTypeHint, 'userIDAttribute@TypeHint');
        }
        if (defaultGroups) {
            defaultGroups.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'defaultGroups');
            })
        }
        if (defaultGroupsTypeHint !== undefined && defaultGroupsTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>defaultGroupsTypeHint, 'defaultGroups@TypeHint');
        }
        if (idpCertAlias !== undefined && idpCertAlias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idpCertAlias, 'idpCertAlias');
        }
        if (idpCertAliasTypeHint !== undefined && idpCertAliasTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idpCertAliasTypeHint, 'idpCertAlias@TypeHint');
        }
        if (addGroupMemberships !== undefined && addGroupMemberships !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>addGroupMemberships, 'addGroupMemberships');
        }
        if (addGroupMembershipsTypeHint !== undefined && addGroupMembershipsTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>addGroupMembershipsTypeHint, 'addGroupMemberships@TypeHint');
        }
        if (path) {
            path.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'path');
            })
        }
        if (pathTypeHint !== undefined && pathTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pathTypeHint, 'path@TypeHint');
        }
        if (synchronizeAttributes) {
            synchronizeAttributes.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'synchronizeAttributes');
            })
        }
        if (synchronizeAttributesTypeHint !== undefined && synchronizeAttributesTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>synchronizeAttributesTypeHint, 'synchronizeAttributes@TypeHint');
        }
        if (clockTolerance !== undefined && clockTolerance !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clockTolerance, 'clockTolerance');
        }
        if (clockToleranceTypeHint !== undefined && clockToleranceTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>clockToleranceTypeHint, 'clockTolerance@TypeHint');
        }
        if (groupMembershipAttribute !== undefined && groupMembershipAttribute !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>groupMembershipAttribute, 'groupMembershipAttribute');
        }
        if (groupMembershipAttributeTypeHint !== undefined && groupMembershipAttributeTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>groupMembershipAttributeTypeHint, 'groupMembershipAttribute@TypeHint');
        }
        if (idpUrl !== undefined && idpUrl !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idpUrl, 'idpUrl');
        }
        if (idpUrlTypeHint !== undefined && idpUrlTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>idpUrlTypeHint, 'idpUrl@TypeHint');
        }
        if (logoutUrl !== undefined && logoutUrl !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>logoutUrl, 'logoutUrl');
        }
        if (logoutUrlTypeHint !== undefined && logoutUrlTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>logoutUrlTypeHint, 'logoutUrl@TypeHint');
        }
        if (serviceProviderEntityId !== undefined && serviceProviderEntityId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>serviceProviderEntityId, 'serviceProviderEntityId');
        }
        if (serviceProviderEntityIdTypeHint !== undefined && serviceProviderEntityIdTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>serviceProviderEntityIdTypeHint, 'serviceProviderEntityId@TypeHint');
        }
        if (assertionConsumerServiceURL !== undefined && assertionConsumerServiceURL !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>assertionConsumerServiceURL, 'assertionConsumerServiceURL');
        }
        if (assertionConsumerServiceURLTypeHint !== undefined && assertionConsumerServiceURLTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>assertionConsumerServiceURLTypeHint, 'assertionConsumerServiceURL@TypeHint');
        }
        if (handleLogout !== undefined && handleLogout !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>handleLogout, 'handleLogout');
        }
        if (handleLogoutTypeHint !== undefined && handleLogoutTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>handleLogoutTypeHint, 'handleLogout@TypeHint');
        }
        if (spPrivateKeyAlias !== undefined && spPrivateKeyAlias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>spPrivateKeyAlias, 'spPrivateKeyAlias');
        }
        if (spPrivateKeyAliasTypeHint !== undefined && spPrivateKeyAliasTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>spPrivateKeyAliasTypeHint, 'spPrivateKeyAlias@TypeHint');
        }
        if (useEncryption !== undefined && useEncryption !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>useEncryption, 'useEncryption');
        }
        if (useEncryptionTypeHint !== undefined && useEncryptionTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>useEncryptionTypeHint, 'useEncryption@TypeHint');
        }
        if (nameIdFormat !== undefined && nameIdFormat !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>nameIdFormat, 'nameIdFormat');
        }
        if (nameIdFormatTypeHint !== undefined && nameIdFormatTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>nameIdFormatTypeHint, 'nameIdFormat@TypeHint');
        }
        if (digestMethod !== undefined && digestMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>digestMethod, 'digestMethod');
        }
        if (digestMethodTypeHint !== undefined && digestMethodTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>digestMethodTypeHint, 'digestMethod@TypeHint');
        }
        if (signatureMethod !== undefined && signatureMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>signatureMethod, 'signatureMethod');
        }
        if (signatureMethodTypeHint !== undefined && signatureMethodTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>signatureMethodTypeHint, 'signatureMethod@TypeHint');
        }
        if (userIntermediatePath !== undefined && userIntermediatePath !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userIntermediatePath, 'userIntermediatePath');
        }
        if (userIntermediatePathTypeHint !== undefined && userIntermediatePathTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userIntermediatePathTypeHint, 'userIntermediatePath@TypeHint');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param orgApacheFelixHttpsNio 
     * @param orgApacheFelixHttpsNioTypeHint 
     * @param orgApacheFelixHttpsKeystore 
     * @param orgApacheFelixHttpsKeystoreTypeHint 
     * @param orgApacheFelixHttpsKeystorePassword 
     * @param orgApacheFelixHttpsKeystorePasswordTypeHint 
     * @param orgApacheFelixHttpsKeystoreKey 
     * @param orgApacheFelixHttpsKeystoreKeyTypeHint 
     * @param orgApacheFelixHttpsKeystoreKeyPassword 
     * @param orgApacheFelixHttpsKeystoreKeyPasswordTypeHint 
     * @param orgApacheFelixHttpsTruststore 
     * @param orgApacheFelixHttpsTruststoreTypeHint 
     * @param orgApacheFelixHttpsTruststorePassword 
     * @param orgApacheFelixHttpsTruststorePasswordTypeHint 
     * @param orgApacheFelixHttpsClientcertificate 
     * @param orgApacheFelixHttpsClientcertificateTypeHint 
     * @param orgApacheFelixHttpsEnable 
     * @param orgApacheFelixHttpsEnableTypeHint 
     * @param orgOsgiServiceHttpPortSecure 
     * @param orgOsgiServiceHttpPortSecureTypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigApacheFelixJettyBasedHttpService(orgApacheFelixHttpsNio?: boolean, orgApacheFelixHttpsNioTypeHint?: string, orgApacheFelixHttpsKeystore?: string, orgApacheFelixHttpsKeystoreTypeHint?: string, orgApacheFelixHttpsKeystorePassword?: string, orgApacheFelixHttpsKeystorePasswordTypeHint?: string, orgApacheFelixHttpsKeystoreKey?: string, orgApacheFelixHttpsKeystoreKeyTypeHint?: string, orgApacheFelixHttpsKeystoreKeyPassword?: string, orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string, orgApacheFelixHttpsTruststore?: string, orgApacheFelixHttpsTruststoreTypeHint?: string, orgApacheFelixHttpsTruststorePassword?: string, orgApacheFelixHttpsTruststorePasswordTypeHint?: string, orgApacheFelixHttpsClientcertificate?: string, orgApacheFelixHttpsClientcertificateTypeHint?: string, orgApacheFelixHttpsEnable?: boolean, orgApacheFelixHttpsEnableTypeHint?: string, orgOsgiServiceHttpPortSecure?: string, orgOsgiServiceHttpPortSecureTypeHint?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (orgApacheFelixHttpsNio !== undefined && orgApacheFelixHttpsNio !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsNio, 'org.apache.felix.https.nio');
        }
        if (orgApacheFelixHttpsNioTypeHint !== undefined && orgApacheFelixHttpsNioTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsNioTypeHint, 'org.apache.felix.https.nio@TypeHint');
        }
        if (orgApacheFelixHttpsKeystore !== undefined && orgApacheFelixHttpsKeystore !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystore, 'org.apache.felix.https.keystore');
        }
        if (orgApacheFelixHttpsKeystoreTypeHint !== undefined && orgApacheFelixHttpsKeystoreTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystoreTypeHint, 'org.apache.felix.https.keystore@TypeHint');
        }
        if (orgApacheFelixHttpsKeystorePassword !== undefined && orgApacheFelixHttpsKeystorePassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystorePassword, 'org.apache.felix.https.keystore.password');
        }
        if (orgApacheFelixHttpsKeystorePasswordTypeHint !== undefined && orgApacheFelixHttpsKeystorePasswordTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystorePasswordTypeHint, 'org.apache.felix.https.keystore.password@TypeHint');
        }
        if (orgApacheFelixHttpsKeystoreKey !== undefined && orgApacheFelixHttpsKeystoreKey !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystoreKey, 'org.apache.felix.https.keystore.key');
        }
        if (orgApacheFelixHttpsKeystoreKeyTypeHint !== undefined && orgApacheFelixHttpsKeystoreKeyTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystoreKeyTypeHint, 'org.apache.felix.https.keystore.key@TypeHint');
        }
        if (orgApacheFelixHttpsKeystoreKeyPassword !== undefined && orgApacheFelixHttpsKeystoreKeyPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystoreKeyPassword, 'org.apache.felix.https.keystore.key.password');
        }
        if (orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== undefined && orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsKeystoreKeyPasswordTypeHint, 'org.apache.felix.https.keystore.key.password@TypeHint');
        }
        if (orgApacheFelixHttpsTruststore !== undefined && orgApacheFelixHttpsTruststore !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsTruststore, 'org.apache.felix.https.truststore');
        }
        if (orgApacheFelixHttpsTruststoreTypeHint !== undefined && orgApacheFelixHttpsTruststoreTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsTruststoreTypeHint, 'org.apache.felix.https.truststore@TypeHint');
        }
        if (orgApacheFelixHttpsTruststorePassword !== undefined && orgApacheFelixHttpsTruststorePassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsTruststorePassword, 'org.apache.felix.https.truststore.password');
        }
        if (orgApacheFelixHttpsTruststorePasswordTypeHint !== undefined && orgApacheFelixHttpsTruststorePasswordTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsTruststorePasswordTypeHint, 'org.apache.felix.https.truststore.password@TypeHint');
        }
        if (orgApacheFelixHttpsClientcertificate !== undefined && orgApacheFelixHttpsClientcertificate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsClientcertificate, 'org.apache.felix.https.clientcertificate');
        }
        if (orgApacheFelixHttpsClientcertificateTypeHint !== undefined && orgApacheFelixHttpsClientcertificateTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsClientcertificateTypeHint, 'org.apache.felix.https.clientcertificate@TypeHint');
        }
        if (orgApacheFelixHttpsEnable !== undefined && orgApacheFelixHttpsEnable !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsEnable, 'org.apache.felix.https.enable');
        }
        if (orgApacheFelixHttpsEnableTypeHint !== undefined && orgApacheFelixHttpsEnableTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgApacheFelixHttpsEnableTypeHint, 'org.apache.felix.https.enable@TypeHint');
        }
        if (orgOsgiServiceHttpPortSecure !== undefined && orgOsgiServiceHttpPortSecure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgOsgiServiceHttpPortSecure, 'org.osgi.service.http.port.secure');
        }
        if (orgOsgiServiceHttpPortSecureTypeHint !== undefined && orgOsgiServiceHttpPortSecureTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>orgOsgiServiceHttpPortSecureTypeHint, 'org.osgi.service.http.port.secure@TypeHint');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.felix.http`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param proxyHost 
     * @param proxyHostTypeHint 
     * @param proxyPort 
     * @param proxyPortTypeHint 
     * @param proxyExceptions 
     * @param proxyExceptionsTypeHint 
     * @param proxyEnabled 
     * @param proxyEnabledTypeHint 
     * @param proxyUser 
     * @param proxyUserTypeHint 
     * @param proxyPassword 
     * @param proxyPasswordTypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigApacheHttpComponentsProxyConfiguration(proxyHost?: string, proxyHostTypeHint?: string, proxyPort?: number, proxyPortTypeHint?: string, proxyExceptions?: Array<string>, proxyExceptionsTypeHint?: string, proxyEnabled?: boolean, proxyEnabledTypeHint?: string, proxyUser?: string, proxyUserTypeHint?: string, proxyPassword?: string, proxyPasswordTypeHint?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (proxyHost !== undefined && proxyHost !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyHost, 'proxy.host');
        }
        if (proxyHostTypeHint !== undefined && proxyHostTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyHostTypeHint, 'proxy.host@TypeHint');
        }
        if (proxyPort !== undefined && proxyPort !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyPort, 'proxy.port');
        }
        if (proxyPortTypeHint !== undefined && proxyPortTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyPortTypeHint, 'proxy.port@TypeHint');
        }
        if (proxyExceptions) {
            proxyExceptions.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'proxy.exceptions');
            })
        }
        if (proxyExceptionsTypeHint !== undefined && proxyExceptionsTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyExceptionsTypeHint, 'proxy.exceptions@TypeHint');
        }
        if (proxyEnabled !== undefined && proxyEnabled !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyEnabled, 'proxy.enabled');
        }
        if (proxyEnabledTypeHint !== undefined && proxyEnabledTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyEnabledTypeHint, 'proxy.enabled@TypeHint');
        }
        if (proxyUser !== undefined && proxyUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyUser, 'proxy.user');
        }
        if (proxyUserTypeHint !== undefined && proxyUserTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyUserTypeHint, 'proxy.user@TypeHint');
        }
        if (proxyPassword !== undefined && proxyPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyPassword, 'proxy.password');
        }
        if (proxyPasswordTypeHint !== undefined && proxyPasswordTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>proxyPasswordTypeHint, 'proxy.password@TypeHint');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.http.proxyconfigurator.config`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param alias 
     * @param aliasTypeHint 
     * @param davCreateAbsoluteUri 
     * @param davCreateAbsoluteUriTypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigApacheSlingDavExServlet(alias?: string, aliasTypeHint?: string, davCreateAbsoluteUri?: boolean, davCreateAbsoluteUriTypeHint?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (alias !== undefined && alias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>alias, 'alias');
        }
        if (aliasTypeHint !== undefined && aliasTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>aliasTypeHint, 'alias@TypeHint');
        }
        if (davCreateAbsoluteUri !== undefined && davCreateAbsoluteUri !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>davCreateAbsoluteUri, 'dav.create-absolute-uri');
        }
        if (davCreateAbsoluteUriTypeHint !== undefined && davCreateAbsoluteUriTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>davCreateAbsoluteUriTypeHint, 'dav.create-absolute-uri@TypeHint');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param jsonMaximumresults 
     * @param jsonMaximumresultsTypeHint 
     * @param enableHtml 
     * @param enableHtmlTypeHint 
     * @param enableTxt 
     * @param enableTxtTypeHint 
     * @param enableXml 
     * @param enableXmlTypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigApacheSlingGetServlet(jsonMaximumresults?: string, jsonMaximumresultsTypeHint?: string, enableHtml?: boolean, enableHtmlTypeHint?: string, enableTxt?: boolean, enableTxtTypeHint?: string, enableXml?: boolean, enableXmlTypeHint?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (jsonMaximumresults !== undefined && jsonMaximumresults !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jsonMaximumresults, 'json.maximumresults');
        }
        if (jsonMaximumresultsTypeHint !== undefined && jsonMaximumresultsTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jsonMaximumresultsTypeHint, 'json.maximumresults@TypeHint');
        }
        if (enableHtml !== undefined && enableHtml !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableHtml, 'enable.html');
        }
        if (enableHtmlTypeHint !== undefined && enableHtmlTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableHtmlTypeHint, 'enable.html@TypeHint');
        }
        if (enableTxt !== undefined && enableTxt !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableTxt, 'enable.txt');
        }
        if (enableTxtTypeHint !== undefined && enableTxtTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableTxtTypeHint, 'enable.txt@TypeHint');
        }
        if (enableXml !== undefined && enableXml !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableXml, 'enable.xml');
        }
        if (enableXmlTypeHint !== undefined && enableXmlTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableXmlTypeHint, 'enable.xml@TypeHint');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param allowEmpty 
     * @param allowEmptyTypeHint 
     * @param allowHosts 
     * @param allowHostsTypeHint 
     * @param allowHostsRegexp 
     * @param allowHostsRegexpTypeHint 
     * @param filterMethods 
     * @param filterMethodsTypeHint 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigApacheSlingReferrerFilter(allowEmpty?: boolean, allowEmptyTypeHint?: string, allowHosts?: string, allowHostsTypeHint?: string, allowHostsRegexp?: string, allowHostsRegexpTypeHint?: string, filterMethods?: string, filterMethodsTypeHint?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (allowEmpty !== undefined && allowEmpty !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowEmpty, 'allow.empty');
        }
        if (allowEmptyTypeHint !== undefined && allowEmptyTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowEmptyTypeHint, 'allow.empty@TypeHint');
        }
        if (allowHosts !== undefined && allowHosts !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowHosts, 'allow.hosts');
        }
        if (allowHostsTypeHint !== undefined && allowHostsTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowHostsTypeHint, 'allow.hosts@TypeHint');
        }
        if (allowHostsRegexp !== undefined && allowHostsRegexp !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowHostsRegexp, 'allow.hosts.regexp');
        }
        if (allowHostsRegexpTypeHint !== undefined && allowHostsRegexpTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowHostsRegexpTypeHint, 'allow.hosts.regexp@TypeHint');
        }
        if (filterMethods !== undefined && filterMethods !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>filterMethods, 'filter.methods');
        }
        if (filterMethodsTypeHint !== undefined && filterMethodsTypeHint !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>filterMethodsTypeHint, 'filter.methods@TypeHint');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param configNodeName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConfigProperty(configNodeName: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postConfigProperty(configNodeName: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postConfigProperty(configNodeName: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postConfigProperty(configNodeName: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (configNodeName === null || configNodeName === undefined) {
            throw new Error('Required parameter configNodeName was null or undefined when calling postConfigProperty.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/apps/system/config/${encodeURIComponent(String(configNodeName))}`,
            null,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param name 
     * @param operation 
     * @param deleteAuthorizable 
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postNode(path: string, name: string, operation?: string, deleteAuthorizable?: string, file?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNode.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNode.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (operation !== undefined && operation !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>operation, ':operation');
        }
        if (deleteAuthorizable !== undefined && deleteAuthorizable !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deleteAuthorizable, 'deleteAuthorizable');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param name 
     * @param addMembers 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postNodeRw(path: string, name: string, addMembers?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postNodeRw.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postNodeRw.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (addMembers !== undefined && addMembers !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>addMembers, 'addMembers');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/${encodeURIComponent(String(name))}.rw.html`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param jcrprimaryType 
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postPath(path: string, jcrprimaryType: string, name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postPath(path: string, jcrprimaryType: string, name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postPath(path: string, jcrprimaryType: string, name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postPath(path: string, jcrprimaryType: string, name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postPath.');
        }
        if (jcrprimaryType === null || jcrprimaryType === undefined) {
            throw new Error('Required parameter jcrprimaryType was null or undefined when calling postPath.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postPath.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (jcrprimaryType !== undefined && jcrprimaryType !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>jcrprimaryType, 'jcr:primaryType');
        }
        if (name !== undefined && name !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>name, ':name');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/${encodeURIComponent(String(path))}/`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param path 
     * @param pLimit 
     * @param _1property 
     * @param _1propertyValue 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<string>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<string>>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<string>>;
    public postQuery(path: string, pLimit: number, _1property: string, _1propertyValue: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postQuery.');
        }
        if (pLimit === null || pLimit === undefined) {
            throw new Error('Required parameter pLimit was null or undefined when calling postQuery.');
        }
        if (_1property === null || _1property === undefined) {
            throw new Error('Required parameter _1property was null or undefined when calling postQuery.');
        }
        if (_1propertyValue === null || _1propertyValue === undefined) {
            throw new Error('Required parameter _1propertyValue was null or undefined when calling postQuery.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (path !== undefined && path !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>path, 'path');
        }
        if (pLimit !== undefined && pLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pLimit, 'p.limit');
        }
        if (_1property !== undefined && _1property !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_1property, '1_property');
        }
        if (_1propertyValue !== undefined && _1propertyValue !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_1propertyValue, '1_property.value');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<string>(`${this.configuration.basePath}/bin/querybuilder.json`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param ignoredeactivated 
     * @param onlymodified 
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public postTreeActivation(ignoredeactivated: boolean, onlymodified: boolean, path: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (ignoredeactivated === null || ignoredeactivated === undefined) {
            throw new Error('Required parameter ignoredeactivated was null or undefined when calling postTreeActivation.');
        }
        if (onlymodified === null || onlymodified === undefined) {
            throw new Error('Required parameter onlymodified was null or undefined when calling postTreeActivation.');
        }
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling postTreeActivation.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ignoredeactivated !== undefined && ignoredeactivated !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ignoredeactivated, 'ignoredeactivated');
        }
        if (onlymodified !== undefined && onlymodified !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>onlymodified, 'onlymodified');
        }
        if (path !== undefined && path !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>path, 'path');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/etc/replication/treeactivation.html`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param operation 
     * @param newPassword 
     * @param rePassword 
     * @param keyStoreType 
     * @param removeAlias 
     * @param certificate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<string>;
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpResponse<string>>;
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpEvent<string>>;
    public postTruststore(operation?: string, newPassword?: string, rePassword?: string, keyStoreType?: string, removeAlias?: string, certificate?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain'}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (operation !== undefined && operation !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>operation, ':operation');
        }
        if (newPassword !== undefined && newPassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>newPassword, 'newPassword');
        }
        if (rePassword !== undefined && rePassword !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>rePassword, 'rePassword');
        }
        if (keyStoreType !== undefined && keyStoreType !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>keyStoreType, 'keyStoreType');
        }
        if (removeAlias !== undefined && removeAlias !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>removeAlias, 'removeAlias');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/plain'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<string>(`${this.configuration.basePath}/libs/granite/security/post/truststore`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param truststoreP12 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<string>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpResponse<string>>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain'}): Observable<HttpEvent<string>>;
    public postTruststorePKCS12(truststoreP12?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain'}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (aemAuth) required
        localVarCredential = this.configuration.lookupCredential('aemAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/plain'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<string>(`${this.configuration.basePath}/etc/truststore`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
