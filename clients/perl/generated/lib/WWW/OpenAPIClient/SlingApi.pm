=begin comment

Adobe Experience Manager (AEM) API

Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API

The version of the OpenAPI document: 3.5.0-pre.0
Contact: opensource@shinesolutions.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::SlingApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# delete_agent
#
# 
# 
# @param string $runmode  (required)
# @param string $name  (required)
{
    my $params = {
    'runmode' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_agent' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_agent {
    my ($self, %args) = @_;

    # verify the required parameter 'runmode' is set
    unless (exists $args{'runmode'}) {
      croak("Missing the required parameter 'runmode' when calling delete_agent");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_agent");
    }

    # parse inputs
    my $_resource_path = '/etc/replication/agents.{runmode}/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'runmode'}) {
        my $_base_variable = "{" . "runmode" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'runmode'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_node
#
# 
# 
# @param string $path  (required)
# @param string $name  (required)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_node' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_node {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling delete_node");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_node");
    }

    # parse inputs
    my $_resource_path = '/{path}/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_agent
#
# 
# 
# @param string $runmode  (required)
# @param string $name  (required)
{
    my $params = {
    'runmode' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_agent' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub get_agent {
    my ($self, %args) = @_;

    # verify the required parameter 'runmode' is set
    unless (exists $args{'runmode'}) {
      croak("Missing the required parameter 'runmode' when calling get_agent");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling get_agent");
    }

    # parse inputs
    my $_resource_path = '/etc/replication/agents.{runmode}/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'runmode'}) {
        my $_base_variable = "{" . "runmode" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'runmode'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_agents
#
# 
# 
# @param string $runmode  (required)
{
    my $params = {
    'runmode' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_agents' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_agents {
    my ($self, %args) = @_;

    # verify the required parameter 'runmode' is set
    unless (exists $args{'runmode'}) {
      croak("Missing the required parameter 'runmode' when calling get_agents");
    }

    # parse inputs
    my $_resource_path = '/etc/replication/agents.{runmode}.-1.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'runmode'}) {
        my $_base_variable = "{" . "runmode" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'runmode'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_authorizable_keystore
#
# 
# 
# @param string $intermediate_path  (required)
# @param string $authorizable_id  (required)
{
    my $params = {
    'intermediate_path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'authorizable_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_authorizable_keystore' } = { 
        summary => '',
        params => $params,
        returns => 'KeystoreInfo',
        };
}
# @return KeystoreInfo
#
sub get_authorizable_keystore {
    my ($self, %args) = @_;

    # verify the required parameter 'intermediate_path' is set
    unless (exists $args{'intermediate_path'}) {
      croak("Missing the required parameter 'intermediate_path' when calling get_authorizable_keystore");
    }

    # verify the required parameter 'authorizable_id' is set
    unless (exists $args{'authorizable_id'}) {
      croak("Missing the required parameter 'authorizable_id' when calling get_authorizable_keystore");
    }

    # parse inputs
    my $_resource_path = '/{intermediatePath}/{authorizableId}.ks.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'intermediate_path'}) {
        my $_base_variable = "{" . "intermediatePath" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'intermediate_path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'authorizable_id'}) {
        my $_base_variable = "{" . "authorizableId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'authorizable_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('KeystoreInfo', $response);
    return $_response_object;
}

#
# get_keystore
#
# 
# 
# @param string $intermediate_path  (required)
# @param string $authorizable_id  (required)
{
    my $params = {
    'intermediate_path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'authorizable_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_keystore' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_keystore {
    my ($self, %args) = @_;

    # verify the required parameter 'intermediate_path' is set
    unless (exists $args{'intermediate_path'}) {
      croak("Missing the required parameter 'intermediate_path' when calling get_keystore");
    }

    # verify the required parameter 'authorizable_id' is set
    unless (exists $args{'authorizable_id'}) {
      croak("Missing the required parameter 'authorizable_id' when calling get_keystore");
    }

    # parse inputs
    my $_resource_path = '/{intermediatePath}/{authorizableId}/keystore/store.p12';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'intermediate_path'}) {
        my $_base_variable = "{" . "intermediatePath" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'intermediate_path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'authorizable_id'}) {
        my $_base_variable = "{" . "authorizableId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'authorizable_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_node
#
# 
# 
# @param string $path  (required)
# @param string $name  (required)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_node' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub get_node {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling get_node");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling get_node");
    }

    # parse inputs
    my $_resource_path = '/{path}/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_package
#
# 
# 
# @param string $group  (required)
# @param string $name  (required)
# @param string $version  (required)
{
    my $params = {
    'group' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'version' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_package' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_package {
    my ($self, %args) = @_;

    # verify the required parameter 'group' is set
    unless (exists $args{'group'}) {
      croak("Missing the required parameter 'group' when calling get_package");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling get_package");
    }

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_package");
    }

    # parse inputs
    my $_resource_path = '/etc/packages/{group}/{name}-{version}.zip';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'group'}) {
        my $_base_variable = "{" . "group" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'group'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_package_filter
#
# 
# 
# @param string $group  (required)
# @param string $name  (required)
# @param string $version  (required)
{
    my $params = {
    'group' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'version' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_package_filter' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_package_filter {
    my ($self, %args) = @_;

    # verify the required parameter 'group' is set
    unless (exists $args{'group'}) {
      croak("Missing the required parameter 'group' when calling get_package_filter");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling get_package_filter");
    }

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_package_filter");
    }

    # parse inputs
    my $_resource_path = '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'group'}) {
        my $_base_variable = "{" . "group" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'group'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_query
#
# 
# 
# @param string $path  (required)
# @param double $p/limit  (required)
# @param string $_1_property  (required)
# @param string $_1_property/value  (required)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'p/limit' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    '_1_property' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    '_1_property/value' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_query' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_query {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling get_query");
    }

    # verify the required parameter 'p/limit' is set
    unless (exists $args{'p/limit'}) {
      croak("Missing the required parameter 'p/limit' when calling get_query");
    }

    # verify the required parameter '_1_property' is set
    unless (exists $args{'_1_property'}) {
      croak("Missing the required parameter '_1_property' when calling get_query");
    }

    # verify the required parameter '_1_property/value' is set
    unless (exists $args{'_1_property/value'}) {
      croak("Missing the required parameter '_1_property/value' when calling get_query");
    }

    # parse inputs
    my $_resource_path = '/bin/querybuilder.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # query params
    if ( exists $args{'p/limit'}) {
        $query_params->{'p.limit'} = $self->{api_client}->to_query_value($args{'p/limit'});
    }

    # query params
    if ( exists $args{'_1_property'}) {
        $query_params->{'1_property'} = $self->{api_client}->to_query_value($args{'_1_property'});
    }

    # query params
    if ( exists $args{'_1_property/value'}) {
        $query_params->{'1_property.value'} = $self->{api_client}->to_query_value($args{'_1_property/value'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_truststore
#
# 
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_truststore' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_truststore {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/etc/truststore/truststore.p12';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_truststore_info
#
# 
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_truststore_info' } = { 
        summary => '',
        params => $params,
        returns => 'TruststoreInfo',
        };
}
# @return TruststoreInfo
#
sub get_truststore_info {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/libs/granite/security/truststore.json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('TruststoreInfo', $response);
    return $_response_object;
}

#
# post_agent
#
# 
# 
# @param string $runmode  (required)
# @param string $name  (required)
# @param boolean $jcr:content/cq:distribute  (optional)
# @param string $jcr:content/cq:distribute@type_hint  (optional)
# @param string $jcr:content/cq:name  (optional)
# @param string $jcr:content/cq:template  (optional)
# @param boolean $jcr:content/enabled  (optional)
# @param string $jcr:content/jcr:description  (optional)
# @param string $jcr:content/jcr:last_modified  (optional)
# @param string $jcr:content/jcr:last_modified_by  (optional)
# @param string $jcr:content/jcr:mixin_types  (optional)
# @param string $jcr:content/jcr:title  (optional)
# @param string $jcr:content/log_level  (optional)
# @param boolean $jcr:content/no_status_update  (optional)
# @param boolean $jcr:content/no_versioning  (optional)
# @param double $jcr:content/protocol_connect_timeout  (optional)
# @param boolean $jcr:content/protocol_http_connection_closed  (optional)
# @param string $jcr:content/protocol_http_expired  (optional)
# @param ARRAY[string] $jcr:content/protocol_http_headers  (optional)
# @param string $jcr:content/protocol_http_headers@type_hint  (optional)
# @param string $jcr:content/protocol_http_method  (optional)
# @param boolean $jcr:content/protocol_https_relaxed  (optional)
# @param string $jcr:content/protocol_interface  (optional)
# @param double $jcr:content/protocol_socket_timeout  (optional)
# @param string $jcr:content/protocol_version  (optional)
# @param string $jcr:content/proxy_ntlm_domain  (optional)
# @param string $jcr:content/proxy_ntlm_host  (optional)
# @param string $jcr:content/proxy_host  (optional)
# @param string $jcr:content/proxy_password  (optional)
# @param double $jcr:content/proxy_port  (optional)
# @param string $jcr:content/proxy_user  (optional)
# @param double $jcr:content/queue_batch_max_size  (optional)
# @param string $jcr:content/queue_batch_mode  (optional)
# @param double $jcr:content/queue_batch_wait_time  (optional)
# @param string $jcr:content/retry_delay  (optional)
# @param boolean $jcr:content/reverse_replication  (optional)
# @param string $jcr:content/serialization_type  (optional)
# @param string $jcr:content/sling:resource_type  (optional)
# @param string $jcr:content/ssl  (optional)
# @param string $jcr:content/transport_ntlm_domain  (optional)
# @param string $jcr:content/transport_ntlm_host  (optional)
# @param string $jcr:content/transport_password  (optional)
# @param string $jcr:content/transport_uri  (optional)
# @param string $jcr:content/transport_user  (optional)
# @param boolean $jcr:content/trigger_distribute  (optional)
# @param boolean $jcr:content/trigger_modified  (optional)
# @param boolean $jcr:content/trigger_on_off_time  (optional)
# @param boolean $jcr:content/trigger_receive  (optional)
# @param boolean $jcr:content/trigger_specific  (optional)
# @param string $jcr:content/user_id  (optional)
# @param string $jcr:primary_type  (optional)
# @param string $:operation  (optional)
{
    my $params = {
    'runmode' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'jcr:content/cq:distribute' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/cq:distribute@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/cq:name' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/cq:template' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/enabled' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/jcr:description' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/jcr:last_modified' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/jcr:last_modified_by' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/jcr:mixin_types' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/jcr:title' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/log_level' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/no_status_update' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/no_versioning' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_connect_timeout' => {
        data_type => 'double',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_http_connection_closed' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_http_expired' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_http_headers' => {
        data_type => 'ARRAY[string]',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_http_headers@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_http_method' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_https_relaxed' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_interface' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_socket_timeout' => {
        data_type => 'double',
        description => '',
        required => '0',
    },
    'jcr:content/protocol_version' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/proxy_ntlm_domain' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/proxy_ntlm_host' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/proxy_host' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/proxy_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/proxy_port' => {
        data_type => 'double',
        description => '',
        required => '0',
    },
    'jcr:content/proxy_user' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/queue_batch_max_size' => {
        data_type => 'double',
        description => '',
        required => '0',
    },
    'jcr:content/queue_batch_mode' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/queue_batch_wait_time' => {
        data_type => 'double',
        description => '',
        required => '0',
    },
    'jcr:content/retry_delay' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/reverse_replication' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/serialization_type' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/sling:resource_type' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/ssl' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/transport_ntlm_domain' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/transport_ntlm_host' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/transport_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/transport_uri' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/transport_user' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:content/trigger_distribute' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/trigger_modified' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/trigger_on_off_time' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/trigger_receive' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/trigger_specific' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'jcr:content/user_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'jcr:primary_type' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    ':operation' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_agent' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_agent {
    my ($self, %args) = @_;

    # verify the required parameter 'runmode' is set
    unless (exists $args{'runmode'}) {
      croak("Missing the required parameter 'runmode' when calling post_agent");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling post_agent");
    }

    # parse inputs
    my $_resource_path = '/etc/replication/agents.{runmode}/{name}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'jcr:content/cq:distribute'}) {
        $query_params->{'jcr:content/cq:distribute'} = $self->{api_client}->to_query_value($args{'jcr:content/cq:distribute'});
    }

    # query params
    if ( exists $args{'jcr:content/cq:distribute@type_hint'}) {
        $query_params->{'jcr:content/cq:distribute@TypeHint'} = $self->{api_client}->to_query_value($args{'jcr:content/cq:distribute@type_hint'});
    }

    # query params
    if ( exists $args{'jcr:content/cq:name'}) {
        $query_params->{'jcr:content/cq:name'} = $self->{api_client}->to_query_value($args{'jcr:content/cq:name'});
    }

    # query params
    if ( exists $args{'jcr:content/cq:template'}) {
        $query_params->{'jcr:content/cq:template'} = $self->{api_client}->to_query_value($args{'jcr:content/cq:template'});
    }

    # query params
    if ( exists $args{'jcr:content/enabled'}) {
        $query_params->{'jcr:content/enabled'} = $self->{api_client}->to_query_value($args{'jcr:content/enabled'});
    }

    # query params
    if ( exists $args{'jcr:content/jcr:description'}) {
        $query_params->{'jcr:content/jcr:description'} = $self->{api_client}->to_query_value($args{'jcr:content/jcr:description'});
    }

    # query params
    if ( exists $args{'jcr:content/jcr:last_modified'}) {
        $query_params->{'jcr:content/jcr:lastModified'} = $self->{api_client}->to_query_value($args{'jcr:content/jcr:last_modified'});
    }

    # query params
    if ( exists $args{'jcr:content/jcr:last_modified_by'}) {
        $query_params->{'jcr:content/jcr:lastModifiedBy'} = $self->{api_client}->to_query_value($args{'jcr:content/jcr:last_modified_by'});
    }

    # query params
    if ( exists $args{'jcr:content/jcr:mixin_types'}) {
        $query_params->{'jcr:content/jcr:mixinTypes'} = $self->{api_client}->to_query_value($args{'jcr:content/jcr:mixin_types'});
    }

    # query params
    if ( exists $args{'jcr:content/jcr:title'}) {
        $query_params->{'jcr:content/jcr:title'} = $self->{api_client}->to_query_value($args{'jcr:content/jcr:title'});
    }

    # query params
    if ( exists $args{'jcr:content/log_level'}) {
        $query_params->{'jcr:content/logLevel'} = $self->{api_client}->to_query_value($args{'jcr:content/log_level'});
    }

    # query params
    if ( exists $args{'jcr:content/no_status_update'}) {
        $query_params->{'jcr:content/noStatusUpdate'} = $self->{api_client}->to_query_value($args{'jcr:content/no_status_update'});
    }

    # query params
    if ( exists $args{'jcr:content/no_versioning'}) {
        $query_params->{'jcr:content/noVersioning'} = $self->{api_client}->to_query_value($args{'jcr:content/no_versioning'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_connect_timeout'}) {
        $query_params->{'jcr:content/protocolConnectTimeout'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_connect_timeout'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_http_connection_closed'}) {
        $query_params->{'jcr:content/protocolHTTPConnectionClosed'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_http_connection_closed'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_http_expired'}) {
        $query_params->{'jcr:content/protocolHTTPExpired'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_http_expired'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_http_headers'}) {
        $query_params->{'jcr:content/protocolHTTPHeaders'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_http_headers'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_http_headers@type_hint'}) {
        $query_params->{'jcr:content/protocolHTTPHeaders@TypeHint'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_http_headers@type_hint'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_http_method'}) {
        $query_params->{'jcr:content/protocolHTTPMethod'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_http_method'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_https_relaxed'}) {
        $query_params->{'jcr:content/protocolHTTPSRelaxed'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_https_relaxed'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_interface'}) {
        $query_params->{'jcr:content/protocolInterface'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_interface'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_socket_timeout'}) {
        $query_params->{'jcr:content/protocolSocketTimeout'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_socket_timeout'});
    }

    # query params
    if ( exists $args{'jcr:content/protocol_version'}) {
        $query_params->{'jcr:content/protocolVersion'} = $self->{api_client}->to_query_value($args{'jcr:content/protocol_version'});
    }

    # query params
    if ( exists $args{'jcr:content/proxy_ntlm_domain'}) {
        $query_params->{'jcr:content/proxyNTLMDomain'} = $self->{api_client}->to_query_value($args{'jcr:content/proxy_ntlm_domain'});
    }

    # query params
    if ( exists $args{'jcr:content/proxy_ntlm_host'}) {
        $query_params->{'jcr:content/proxyNTLMHost'} = $self->{api_client}->to_query_value($args{'jcr:content/proxy_ntlm_host'});
    }

    # query params
    if ( exists $args{'jcr:content/proxy_host'}) {
        $query_params->{'jcr:content/proxyHost'} = $self->{api_client}->to_query_value($args{'jcr:content/proxy_host'});
    }

    # query params
    if ( exists $args{'jcr:content/proxy_password'}) {
        $query_params->{'jcr:content/proxyPassword'} = $self->{api_client}->to_query_value($args{'jcr:content/proxy_password'});
    }

    # query params
    if ( exists $args{'jcr:content/proxy_port'}) {
        $query_params->{'jcr:content/proxyPort'} = $self->{api_client}->to_query_value($args{'jcr:content/proxy_port'});
    }

    # query params
    if ( exists $args{'jcr:content/proxy_user'}) {
        $query_params->{'jcr:content/proxyUser'} = $self->{api_client}->to_query_value($args{'jcr:content/proxy_user'});
    }

    # query params
    if ( exists $args{'jcr:content/queue_batch_max_size'}) {
        $query_params->{'jcr:content/queueBatchMaxSize'} = $self->{api_client}->to_query_value($args{'jcr:content/queue_batch_max_size'});
    }

    # query params
    if ( exists $args{'jcr:content/queue_batch_mode'}) {
        $query_params->{'jcr:content/queueBatchMode'} = $self->{api_client}->to_query_value($args{'jcr:content/queue_batch_mode'});
    }

    # query params
    if ( exists $args{'jcr:content/queue_batch_wait_time'}) {
        $query_params->{'jcr:content/queueBatchWaitTime'} = $self->{api_client}->to_query_value($args{'jcr:content/queue_batch_wait_time'});
    }

    # query params
    if ( exists $args{'jcr:content/retry_delay'}) {
        $query_params->{'jcr:content/retryDelay'} = $self->{api_client}->to_query_value($args{'jcr:content/retry_delay'});
    }

    # query params
    if ( exists $args{'jcr:content/reverse_replication'}) {
        $query_params->{'jcr:content/reverseReplication'} = $self->{api_client}->to_query_value($args{'jcr:content/reverse_replication'});
    }

    # query params
    if ( exists $args{'jcr:content/serialization_type'}) {
        $query_params->{'jcr:content/serializationType'} = $self->{api_client}->to_query_value($args{'jcr:content/serialization_type'});
    }

    # query params
    if ( exists $args{'jcr:content/sling:resource_type'}) {
        $query_params->{'jcr:content/sling:resourceType'} = $self->{api_client}->to_query_value($args{'jcr:content/sling:resource_type'});
    }

    # query params
    if ( exists $args{'jcr:content/ssl'}) {
        $query_params->{'jcr:content/ssl'} = $self->{api_client}->to_query_value($args{'jcr:content/ssl'});
    }

    # query params
    if ( exists $args{'jcr:content/transport_ntlm_domain'}) {
        $query_params->{'jcr:content/transportNTLMDomain'} = $self->{api_client}->to_query_value($args{'jcr:content/transport_ntlm_domain'});
    }

    # query params
    if ( exists $args{'jcr:content/transport_ntlm_host'}) {
        $query_params->{'jcr:content/transportNTLMHost'} = $self->{api_client}->to_query_value($args{'jcr:content/transport_ntlm_host'});
    }

    # query params
    if ( exists $args{'jcr:content/transport_password'}) {
        $query_params->{'jcr:content/transportPassword'} = $self->{api_client}->to_query_value($args{'jcr:content/transport_password'});
    }

    # query params
    if ( exists $args{'jcr:content/transport_uri'}) {
        $query_params->{'jcr:content/transportUri'} = $self->{api_client}->to_query_value($args{'jcr:content/transport_uri'});
    }

    # query params
    if ( exists $args{'jcr:content/transport_user'}) {
        $query_params->{'jcr:content/transportUser'} = $self->{api_client}->to_query_value($args{'jcr:content/transport_user'});
    }

    # query params
    if ( exists $args{'jcr:content/trigger_distribute'}) {
        $query_params->{'jcr:content/triggerDistribute'} = $self->{api_client}->to_query_value($args{'jcr:content/trigger_distribute'});
    }

    # query params
    if ( exists $args{'jcr:content/trigger_modified'}) {
        $query_params->{'jcr:content/triggerModified'} = $self->{api_client}->to_query_value($args{'jcr:content/trigger_modified'});
    }

    # query params
    if ( exists $args{'jcr:content/trigger_on_off_time'}) {
        $query_params->{'jcr:content/triggerOnOffTime'} = $self->{api_client}->to_query_value($args{'jcr:content/trigger_on_off_time'});
    }

    # query params
    if ( exists $args{'jcr:content/trigger_receive'}) {
        $query_params->{'jcr:content/triggerReceive'} = $self->{api_client}->to_query_value($args{'jcr:content/trigger_receive'});
    }

    # query params
    if ( exists $args{'jcr:content/trigger_specific'}) {
        $query_params->{'jcr:content/triggerSpecific'} = $self->{api_client}->to_query_value($args{'jcr:content/trigger_specific'});
    }

    # query params
    if ( exists $args{'jcr:content/user_id'}) {
        $query_params->{'jcr:content/userId'} = $self->{api_client}->to_query_value($args{'jcr:content/user_id'});
    }

    # query params
    if ( exists $args{'jcr:primary_type'}) {
        $query_params->{'jcr:primaryType'} = $self->{api_client}->to_query_value($args{'jcr:primary_type'});
    }

    # query params
    if ( exists $args{':operation'}) {
        $query_params->{':operation'} = $self->{api_client}->to_query_value($args{':operation'});
    }

    # path params
    if ( exists $args{'runmode'}) {
        my $_base_variable = "{" . "runmode" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'runmode'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_authorizable_keystore
#
# 
# 
# @param string $intermediate_path  (required)
# @param string $authorizable_id  (required)
# @param string $:operation  (optional)
# @param string $current_password  (optional)
# @param string $new_password  (optional)
# @param string $re_password  (optional)
# @param string $key_password  (optional)
# @param string $key_store_pass  (optional)
# @param string $alias  (optional)
# @param string $new_alias  (optional)
# @param string $remove_alias  (optional)
# @param string $cert_chain  (optional)
# @param string $pk  (optional)
# @param string $key_store  (optional)
{
    my $params = {
    'intermediate_path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'authorizable_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    ':operation' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'current_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'new_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    're_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'key_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'key_store_pass' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'new_alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'remove_alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'cert_chain' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'pk' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'key_store' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_authorizable_keystore' } = { 
        summary => '',
        params => $params,
        returns => 'KeystoreInfo',
        };
}
# @return KeystoreInfo
#
sub post_authorizable_keystore {
    my ($self, %args) = @_;

    # verify the required parameter 'intermediate_path' is set
    unless (exists $args{'intermediate_path'}) {
      croak("Missing the required parameter 'intermediate_path' when calling post_authorizable_keystore");
    }

    # verify the required parameter 'authorizable_id' is set
    unless (exists $args{'authorizable_id'}) {
      croak("Missing the required parameter 'authorizable_id' when calling post_authorizable_keystore");
    }

    # parse inputs
    my $_resource_path = '/{intermediatePath}/{authorizableId}.ks.html';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('multipart/form-data');

    # query params
    if ( exists $args{':operation'}) {
        $query_params->{':operation'} = $self->{api_client}->to_query_value($args{':operation'});
    }

    # query params
    if ( exists $args{'current_password'}) {
        $query_params->{'currentPassword'} = $self->{api_client}->to_query_value($args{'current_password'});
    }

    # query params
    if ( exists $args{'new_password'}) {
        $query_params->{'newPassword'} = $self->{api_client}->to_query_value($args{'new_password'});
    }

    # query params
    if ( exists $args{'re_password'}) {
        $query_params->{'rePassword'} = $self->{api_client}->to_query_value($args{'re_password'});
    }

    # query params
    if ( exists $args{'key_password'}) {
        $query_params->{'keyPassword'} = $self->{api_client}->to_query_value($args{'key_password'});
    }

    # query params
    if ( exists $args{'key_store_pass'}) {
        $query_params->{'keyStorePass'} = $self->{api_client}->to_query_value($args{'key_store_pass'});
    }

    # query params
    if ( exists $args{'alias'}) {
        $query_params->{'alias'} = $self->{api_client}->to_query_value($args{'alias'});
    }

    # query params
    if ( exists $args{'new_alias'}) {
        $query_params->{'newAlias'} = $self->{api_client}->to_query_value($args{'new_alias'});
    }

    # query params
    if ( exists $args{'remove_alias'}) {
        $query_params->{'removeAlias'} = $self->{api_client}->to_query_value($args{'remove_alias'});
    }

    # path params
    if ( exists $args{'intermediate_path'}) {
        my $_base_variable = "{" . "intermediatePath" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'intermediate_path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'authorizable_id'}) {
        my $_base_variable = "{" . "authorizableId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'authorizable_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # form params
    if ( exists $args{'cert_chain'} ) {
        $form_params->{'cert-chain'} = [] unless defined $form_params->{'cert-chain'};
        push @{$form_params->{'cert-chain'}}, $args{'cert_chain'};
            }
    
    # form params
    if ( exists $args{'pk'} ) {
        $form_params->{'pk'} = [] unless defined $form_params->{'pk'};
        push @{$form_params->{'pk'}}, $args{'pk'};
            }
    
    # form params
    if ( exists $args{'key_store'} ) {
        $form_params->{'keyStore'} = [] unless defined $form_params->{'keyStore'};
        push @{$form_params->{'keyStore'}}, $args{'key_store'};
            }
    
    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('KeystoreInfo', $response);
    return $_response_object;
}

#
# post_authorizables
#
# 
# 
# @param string $authorizable_id  (required)
# @param string $intermediate_path  (required)
# @param string $create_user  (optional)
# @param string $create_group  (optional)
# @param string $rep:password  (optional)
# @param string $profile/given_name  (optional)
{
    my $params = {
    'authorizable_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'intermediate_path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'create_user' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'create_group' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'rep:password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'profile/given_name' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_authorizables' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub post_authorizables {
    my ($self, %args) = @_;

    # verify the required parameter 'authorizable_id' is set
    unless (exists $args{'authorizable_id'}) {
      croak("Missing the required parameter 'authorizable_id' when calling post_authorizables");
    }

    # verify the required parameter 'intermediate_path' is set
    unless (exists $args{'intermediate_path'}) {
      croak("Missing the required parameter 'intermediate_path' when calling post_authorizables");
    }

    # parse inputs
    my $_resource_path = '/libs/granite/security/post/authorizables';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/html');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'authorizable_id'}) {
        $query_params->{'authorizableId'} = $self->{api_client}->to_query_value($args{'authorizable_id'});
    }

    # query params
    if ( exists $args{'intermediate_path'}) {
        $query_params->{'intermediatePath'} = $self->{api_client}->to_query_value($args{'intermediate_path'});
    }

    # query params
    if ( exists $args{'create_user'}) {
        $query_params->{'createUser'} = $self->{api_client}->to_query_value($args{'create_user'});
    }

    # query params
    if ( exists $args{'create_group'}) {
        $query_params->{'createGroup'} = $self->{api_client}->to_query_value($args{'create_group'});
    }

    # query params
    if ( exists $args{'rep:password'}) {
        $query_params->{'rep:password'} = $self->{api_client}->to_query_value($args{'rep:password'});
    }

    # query params
    if ( exists $args{'profile/given_name'}) {
        $query_params->{'profile/givenName'} = $self->{api_client}->to_query_value($args{'profile/given_name'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# post_config_adobe_granite_saml_authentication_handler
#
# 
# 
# @param string $key_store_password  (optional)
# @param string $key_store_password@type_hint  (optional)
# @param int $service/ranking  (optional)
# @param string $service/ranking@type_hint  (optional)
# @param boolean $idp_http_redirect  (optional)
# @param string $idp_http_redirect@type_hint  (optional)
# @param boolean $create_user  (optional)
# @param string $create_user@type_hint  (optional)
# @param string $default_redirect_url  (optional)
# @param string $default_redirect_url@type_hint  (optional)
# @param string $user_id_attribute  (optional)
# @param string $user_id_attribute@type_hint  (optional)
# @param ARRAY[string] $default_groups  (optional)
# @param string $default_groups@type_hint  (optional)
# @param string $idp_cert_alias  (optional)
# @param string $idp_cert_alias@type_hint  (optional)
# @param boolean $add_group_memberships  (optional)
# @param string $add_group_memberships@type_hint  (optional)
# @param ARRAY[string] $path  (optional)
# @param string $path@type_hint  (optional)
# @param ARRAY[string] $synchronize_attributes  (optional)
# @param string $synchronize_attributes@type_hint  (optional)
# @param int $clock_tolerance  (optional)
# @param string $clock_tolerance@type_hint  (optional)
# @param string $group_membership_attribute  (optional)
# @param string $group_membership_attribute@type_hint  (optional)
# @param string $idp_url  (optional)
# @param string $idp_url@type_hint  (optional)
# @param string $logout_url  (optional)
# @param string $logout_url@type_hint  (optional)
# @param string $service_provider_entity_id  (optional)
# @param string $service_provider_entity_id@type_hint  (optional)
# @param string $assertion_consumer_service_url  (optional)
# @param string $assertion_consumer_service_url@type_hint  (optional)
# @param boolean $handle_logout  (optional)
# @param string $handle_logout@type_hint  (optional)
# @param string $sp_private_key_alias  (optional)
# @param string $sp_private_key_alias@type_hint  (optional)
# @param boolean $use_encryption  (optional)
# @param string $use_encryption@type_hint  (optional)
# @param string $name_id_format  (optional)
# @param string $name_id_format@type_hint  (optional)
# @param string $digest_method  (optional)
# @param string $digest_method@type_hint  (optional)
# @param string $signature_method  (optional)
# @param string $signature_method@type_hint  (optional)
# @param string $user_intermediate_path  (optional)
# @param string $user_intermediate_path@type_hint  (optional)
{
    my $params = {
    'key_store_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'key_store_password@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'service/ranking' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    'service/ranking@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'idp_http_redirect' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'idp_http_redirect@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'create_user' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'create_user@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'default_redirect_url' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'default_redirect_url@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'user_id_attribute' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'user_id_attribute@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'default_groups' => {
        data_type => 'ARRAY[string]',
        description => '',
        required => '0',
    },
    'default_groups@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'idp_cert_alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'idp_cert_alias@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'add_group_memberships' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'add_group_memberships@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'path' => {
        data_type => 'ARRAY[string]',
        description => '',
        required => '0',
    },
    'path@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'synchronize_attributes' => {
        data_type => 'ARRAY[string]',
        description => '',
        required => '0',
    },
    'synchronize_attributes@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'clock_tolerance' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    'clock_tolerance@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'group_membership_attribute' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'group_membership_attribute@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'idp_url' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'idp_url@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'logout_url' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'logout_url@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'service_provider_entity_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'service_provider_entity_id@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'assertion_consumer_service_url' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'assertion_consumer_service_url@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'handle_logout' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'handle_logout@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'sp_private_key_alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'sp_private_key_alias@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'use_encryption' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'use_encryption@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'name_id_format' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'name_id_format@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'digest_method' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'digest_method@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'signature_method' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'signature_method@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'user_intermediate_path' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'user_intermediate_path@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_adobe_granite_saml_authentication_handler' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_adobe_granite_saml_authentication_handler {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'key_store_password'}) {
        $query_params->{'keyStorePassword'} = $self->{api_client}->to_query_value($args{'key_store_password'});
    }

    # query params
    if ( exists $args{'key_store_password@type_hint'}) {
        $query_params->{'keyStorePassword@TypeHint'} = $self->{api_client}->to_query_value($args{'key_store_password@type_hint'});
    }

    # query params
    if ( exists $args{'service/ranking'}) {
        $query_params->{'service.ranking'} = $self->{api_client}->to_query_value($args{'service/ranking'});
    }

    # query params
    if ( exists $args{'service/ranking@type_hint'}) {
        $query_params->{'service.ranking@TypeHint'} = $self->{api_client}->to_query_value($args{'service/ranking@type_hint'});
    }

    # query params
    if ( exists $args{'idp_http_redirect'}) {
        $query_params->{'idpHttpRedirect'} = $self->{api_client}->to_query_value($args{'idp_http_redirect'});
    }

    # query params
    if ( exists $args{'idp_http_redirect@type_hint'}) {
        $query_params->{'idpHttpRedirect@TypeHint'} = $self->{api_client}->to_query_value($args{'idp_http_redirect@type_hint'});
    }

    # query params
    if ( exists $args{'create_user'}) {
        $query_params->{'createUser'} = $self->{api_client}->to_query_value($args{'create_user'});
    }

    # query params
    if ( exists $args{'create_user@type_hint'}) {
        $query_params->{'createUser@TypeHint'} = $self->{api_client}->to_query_value($args{'create_user@type_hint'});
    }

    # query params
    if ( exists $args{'default_redirect_url'}) {
        $query_params->{'defaultRedirectUrl'} = $self->{api_client}->to_query_value($args{'default_redirect_url'});
    }

    # query params
    if ( exists $args{'default_redirect_url@type_hint'}) {
        $query_params->{'defaultRedirectUrl@TypeHint'} = $self->{api_client}->to_query_value($args{'default_redirect_url@type_hint'});
    }

    # query params
    if ( exists $args{'user_id_attribute'}) {
        $query_params->{'userIDAttribute'} = $self->{api_client}->to_query_value($args{'user_id_attribute'});
    }

    # query params
    if ( exists $args{'user_id_attribute@type_hint'}) {
        $query_params->{'userIDAttribute@TypeHint'} = $self->{api_client}->to_query_value($args{'user_id_attribute@type_hint'});
    }

    # query params
    if ( exists $args{'default_groups'}) {
        $query_params->{'defaultGroups'} = $self->{api_client}->to_query_value($args{'default_groups'});
    }

    # query params
    if ( exists $args{'default_groups@type_hint'}) {
        $query_params->{'defaultGroups@TypeHint'} = $self->{api_client}->to_query_value($args{'default_groups@type_hint'});
    }

    # query params
    if ( exists $args{'idp_cert_alias'}) {
        $query_params->{'idpCertAlias'} = $self->{api_client}->to_query_value($args{'idp_cert_alias'});
    }

    # query params
    if ( exists $args{'idp_cert_alias@type_hint'}) {
        $query_params->{'idpCertAlias@TypeHint'} = $self->{api_client}->to_query_value($args{'idp_cert_alias@type_hint'});
    }

    # query params
    if ( exists $args{'add_group_memberships'}) {
        $query_params->{'addGroupMemberships'} = $self->{api_client}->to_query_value($args{'add_group_memberships'});
    }

    # query params
    if ( exists $args{'add_group_memberships@type_hint'}) {
        $query_params->{'addGroupMemberships@TypeHint'} = $self->{api_client}->to_query_value($args{'add_group_memberships@type_hint'});
    }

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # query params
    if ( exists $args{'path@type_hint'}) {
        $query_params->{'path@TypeHint'} = $self->{api_client}->to_query_value($args{'path@type_hint'});
    }

    # query params
    if ( exists $args{'synchronize_attributes'}) {
        $query_params->{'synchronizeAttributes'} = $self->{api_client}->to_query_value($args{'synchronize_attributes'});
    }

    # query params
    if ( exists $args{'synchronize_attributes@type_hint'}) {
        $query_params->{'synchronizeAttributes@TypeHint'} = $self->{api_client}->to_query_value($args{'synchronize_attributes@type_hint'});
    }

    # query params
    if ( exists $args{'clock_tolerance'}) {
        $query_params->{'clockTolerance'} = $self->{api_client}->to_query_value($args{'clock_tolerance'});
    }

    # query params
    if ( exists $args{'clock_tolerance@type_hint'}) {
        $query_params->{'clockTolerance@TypeHint'} = $self->{api_client}->to_query_value($args{'clock_tolerance@type_hint'});
    }

    # query params
    if ( exists $args{'group_membership_attribute'}) {
        $query_params->{'groupMembershipAttribute'} = $self->{api_client}->to_query_value($args{'group_membership_attribute'});
    }

    # query params
    if ( exists $args{'group_membership_attribute@type_hint'}) {
        $query_params->{'groupMembershipAttribute@TypeHint'} = $self->{api_client}->to_query_value($args{'group_membership_attribute@type_hint'});
    }

    # query params
    if ( exists $args{'idp_url'}) {
        $query_params->{'idpUrl'} = $self->{api_client}->to_query_value($args{'idp_url'});
    }

    # query params
    if ( exists $args{'idp_url@type_hint'}) {
        $query_params->{'idpUrl@TypeHint'} = $self->{api_client}->to_query_value($args{'idp_url@type_hint'});
    }

    # query params
    if ( exists $args{'logout_url'}) {
        $query_params->{'logoutUrl'} = $self->{api_client}->to_query_value($args{'logout_url'});
    }

    # query params
    if ( exists $args{'logout_url@type_hint'}) {
        $query_params->{'logoutUrl@TypeHint'} = $self->{api_client}->to_query_value($args{'logout_url@type_hint'});
    }

    # query params
    if ( exists $args{'service_provider_entity_id'}) {
        $query_params->{'serviceProviderEntityId'} = $self->{api_client}->to_query_value($args{'service_provider_entity_id'});
    }

    # query params
    if ( exists $args{'service_provider_entity_id@type_hint'}) {
        $query_params->{'serviceProviderEntityId@TypeHint'} = $self->{api_client}->to_query_value($args{'service_provider_entity_id@type_hint'});
    }

    # query params
    if ( exists $args{'assertion_consumer_service_url'}) {
        $query_params->{'assertionConsumerServiceURL'} = $self->{api_client}->to_query_value($args{'assertion_consumer_service_url'});
    }

    # query params
    if ( exists $args{'assertion_consumer_service_url@type_hint'}) {
        $query_params->{'assertionConsumerServiceURL@TypeHint'} = $self->{api_client}->to_query_value($args{'assertion_consumer_service_url@type_hint'});
    }

    # query params
    if ( exists $args{'handle_logout'}) {
        $query_params->{'handleLogout'} = $self->{api_client}->to_query_value($args{'handle_logout'});
    }

    # query params
    if ( exists $args{'handle_logout@type_hint'}) {
        $query_params->{'handleLogout@TypeHint'} = $self->{api_client}->to_query_value($args{'handle_logout@type_hint'});
    }

    # query params
    if ( exists $args{'sp_private_key_alias'}) {
        $query_params->{'spPrivateKeyAlias'} = $self->{api_client}->to_query_value($args{'sp_private_key_alias'});
    }

    # query params
    if ( exists $args{'sp_private_key_alias@type_hint'}) {
        $query_params->{'spPrivateKeyAlias@TypeHint'} = $self->{api_client}->to_query_value($args{'sp_private_key_alias@type_hint'});
    }

    # query params
    if ( exists $args{'use_encryption'}) {
        $query_params->{'useEncryption'} = $self->{api_client}->to_query_value($args{'use_encryption'});
    }

    # query params
    if ( exists $args{'use_encryption@type_hint'}) {
        $query_params->{'useEncryption@TypeHint'} = $self->{api_client}->to_query_value($args{'use_encryption@type_hint'});
    }

    # query params
    if ( exists $args{'name_id_format'}) {
        $query_params->{'nameIdFormat'} = $self->{api_client}->to_query_value($args{'name_id_format'});
    }

    # query params
    if ( exists $args{'name_id_format@type_hint'}) {
        $query_params->{'nameIdFormat@TypeHint'} = $self->{api_client}->to_query_value($args{'name_id_format@type_hint'});
    }

    # query params
    if ( exists $args{'digest_method'}) {
        $query_params->{'digestMethod'} = $self->{api_client}->to_query_value($args{'digest_method'});
    }

    # query params
    if ( exists $args{'digest_method@type_hint'}) {
        $query_params->{'digestMethod@TypeHint'} = $self->{api_client}->to_query_value($args{'digest_method@type_hint'});
    }

    # query params
    if ( exists $args{'signature_method'}) {
        $query_params->{'signatureMethod'} = $self->{api_client}->to_query_value($args{'signature_method'});
    }

    # query params
    if ( exists $args{'signature_method@type_hint'}) {
        $query_params->{'signatureMethod@TypeHint'} = $self->{api_client}->to_query_value($args{'signature_method@type_hint'});
    }

    # query params
    if ( exists $args{'user_intermediate_path'}) {
        $query_params->{'userIntermediatePath'} = $self->{api_client}->to_query_value($args{'user_intermediate_path'});
    }

    # query params
    if ( exists $args{'user_intermediate_path@type_hint'}) {
        $query_params->{'userIntermediatePath@TypeHint'} = $self->{api_client}->to_query_value($args{'user_intermediate_path@type_hint'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_config_apache_felix_jetty_based_http_service
#
# 
# 
# @param boolean $org/apache/felix/https/nio  (optional)
# @param string $org/apache/felix/https/nio@type_hint  (optional)
# @param string $org/apache/felix/https/keystore  (optional)
# @param string $org/apache/felix/https/keystore@type_hint  (optional)
# @param string $org/apache/felix/https/keystore/password  (optional)
# @param string $org/apache/felix/https/keystore/password@type_hint  (optional)
# @param string $org/apache/felix/https/keystore/key  (optional)
# @param string $org/apache/felix/https/keystore/key@type_hint  (optional)
# @param string $org/apache/felix/https/keystore/key/password  (optional)
# @param string $org/apache/felix/https/keystore/key/password@type_hint  (optional)
# @param string $org/apache/felix/https/truststore  (optional)
# @param string $org/apache/felix/https/truststore@type_hint  (optional)
# @param string $org/apache/felix/https/truststore/password  (optional)
# @param string $org/apache/felix/https/truststore/password@type_hint  (optional)
# @param string $org/apache/felix/https/clientcertificate  (optional)
# @param string $org/apache/felix/https/clientcertificate@type_hint  (optional)
# @param boolean $org/apache/felix/https/enable  (optional)
# @param string $org/apache/felix/https/enable@type_hint  (optional)
# @param string $org/osgi/service/http/port/secure  (optional)
# @param string $org/osgi/service/http/port/secure@type_hint  (optional)
{
    my $params = {
    'org/apache/felix/https/nio' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/nio@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore/password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore/password@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore/key' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore/key@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore/key/password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/keystore/key/password@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/truststore' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/truststore@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/truststore/password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/truststore/password@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/clientcertificate' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/clientcertificate@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/enable' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'org/apache/felix/https/enable@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/osgi/service/http/port/secure' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'org/osgi/service/http/port/secure@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_apache_felix_jetty_based_http_service' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_apache_felix_jetty_based_http_service {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/apps/system/config/org.apache.felix.http';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'org/apache/felix/https/nio'}) {
        $query_params->{'org.apache.felix.https.nio'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/nio'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/nio@type_hint'}) {
        $query_params->{'org.apache.felix.https.nio@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/nio@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore'}) {
        $query_params->{'org.apache.felix.https.keystore'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore@type_hint'}) {
        $query_params->{'org.apache.felix.https.keystore@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore/password'}) {
        $query_params->{'org.apache.felix.https.keystore.password'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore/password'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore/password@type_hint'}) {
        $query_params->{'org.apache.felix.https.keystore.password@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore/password@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore/key'}) {
        $query_params->{'org.apache.felix.https.keystore.key'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore/key'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore/key@type_hint'}) {
        $query_params->{'org.apache.felix.https.keystore.key@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore/key@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore/key/password'}) {
        $query_params->{'org.apache.felix.https.keystore.key.password'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore/key/password'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/keystore/key/password@type_hint'}) {
        $query_params->{'org.apache.felix.https.keystore.key.password@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/keystore/key/password@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/truststore'}) {
        $query_params->{'org.apache.felix.https.truststore'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/truststore'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/truststore@type_hint'}) {
        $query_params->{'org.apache.felix.https.truststore@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/truststore@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/truststore/password'}) {
        $query_params->{'org.apache.felix.https.truststore.password'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/truststore/password'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/truststore/password@type_hint'}) {
        $query_params->{'org.apache.felix.https.truststore.password@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/truststore/password@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/clientcertificate'}) {
        $query_params->{'org.apache.felix.https.clientcertificate'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/clientcertificate'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/clientcertificate@type_hint'}) {
        $query_params->{'org.apache.felix.https.clientcertificate@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/clientcertificate@type_hint'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/enable'}) {
        $query_params->{'org.apache.felix.https.enable'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/enable'});
    }

    # query params
    if ( exists $args{'org/apache/felix/https/enable@type_hint'}) {
        $query_params->{'org.apache.felix.https.enable@TypeHint'} = $self->{api_client}->to_query_value($args{'org/apache/felix/https/enable@type_hint'});
    }

    # query params
    if ( exists $args{'org/osgi/service/http/port/secure'}) {
        $query_params->{'org.osgi.service.http.port.secure'} = $self->{api_client}->to_query_value($args{'org/osgi/service/http/port/secure'});
    }

    # query params
    if ( exists $args{'org/osgi/service/http/port/secure@type_hint'}) {
        $query_params->{'org.osgi.service.http.port.secure@TypeHint'} = $self->{api_client}->to_query_value($args{'org/osgi/service/http/port/secure@type_hint'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_config_apache_http_components_proxy_configuration
#
# 
# 
# @param string $proxy/host  (optional)
# @param string $proxy/host@type_hint  (optional)
# @param int $proxy/port  (optional)
# @param string $proxy/port@type_hint  (optional)
# @param ARRAY[string] $proxy/exceptions  (optional)
# @param string $proxy/exceptions@type_hint  (optional)
# @param boolean $proxy/enabled  (optional)
# @param string $proxy/enabled@type_hint  (optional)
# @param string $proxy/user  (optional)
# @param string $proxy/user@type_hint  (optional)
# @param string $proxy/password  (optional)
# @param string $proxy/password@type_hint  (optional)
{
    my $params = {
    'proxy/host' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/host@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/port' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    'proxy/port@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/exceptions' => {
        data_type => 'ARRAY[string]',
        description => '',
        required => '0',
    },
    'proxy/exceptions@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/enabled' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'proxy/enabled@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/user' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/user@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'proxy/password@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_apache_http_components_proxy_configuration' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_apache_http_components_proxy_configuration {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/apps/system/config/org.apache.http.proxyconfigurator.config';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'proxy/host'}) {
        $query_params->{'proxy.host'} = $self->{api_client}->to_query_value($args{'proxy/host'});
    }

    # query params
    if ( exists $args{'proxy/host@type_hint'}) {
        $query_params->{'proxy.host@TypeHint'} = $self->{api_client}->to_query_value($args{'proxy/host@type_hint'});
    }

    # query params
    if ( exists $args{'proxy/port'}) {
        $query_params->{'proxy.port'} = $self->{api_client}->to_query_value($args{'proxy/port'});
    }

    # query params
    if ( exists $args{'proxy/port@type_hint'}) {
        $query_params->{'proxy.port@TypeHint'} = $self->{api_client}->to_query_value($args{'proxy/port@type_hint'});
    }

    # query params
    if ( exists $args{'proxy/exceptions'}) {
        $query_params->{'proxy.exceptions'} = $self->{api_client}->to_query_value($args{'proxy/exceptions'});
    }

    # query params
    if ( exists $args{'proxy/exceptions@type_hint'}) {
        $query_params->{'proxy.exceptions@TypeHint'} = $self->{api_client}->to_query_value($args{'proxy/exceptions@type_hint'});
    }

    # query params
    if ( exists $args{'proxy/enabled'}) {
        $query_params->{'proxy.enabled'} = $self->{api_client}->to_query_value($args{'proxy/enabled'});
    }

    # query params
    if ( exists $args{'proxy/enabled@type_hint'}) {
        $query_params->{'proxy.enabled@TypeHint'} = $self->{api_client}->to_query_value($args{'proxy/enabled@type_hint'});
    }

    # query params
    if ( exists $args{'proxy/user'}) {
        $query_params->{'proxy.user'} = $self->{api_client}->to_query_value($args{'proxy/user'});
    }

    # query params
    if ( exists $args{'proxy/user@type_hint'}) {
        $query_params->{'proxy.user@TypeHint'} = $self->{api_client}->to_query_value($args{'proxy/user@type_hint'});
    }

    # query params
    if ( exists $args{'proxy/password'}) {
        $query_params->{'proxy.password'} = $self->{api_client}->to_query_value($args{'proxy/password'});
    }

    # query params
    if ( exists $args{'proxy/password@type_hint'}) {
        $query_params->{'proxy.password@TypeHint'} = $self->{api_client}->to_query_value($args{'proxy/password@type_hint'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_config_apache_sling_dav_ex_servlet
#
# 
# 
# @param string $alias  (optional)
# @param string $alias@type_hint  (optional)
# @param boolean $dav/create_absolute_uri  (optional)
# @param string $dav/create_absolute_uri@type_hint  (optional)
{
    my $params = {
    'alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'alias@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'dav/create_absolute_uri' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'dav/create_absolute_uri@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_apache_sling_dav_ex_servlet' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_apache_sling_dav_ex_servlet {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'alias'}) {
        $query_params->{'alias'} = $self->{api_client}->to_query_value($args{'alias'});
    }

    # query params
    if ( exists $args{'alias@type_hint'}) {
        $query_params->{'alias@TypeHint'} = $self->{api_client}->to_query_value($args{'alias@type_hint'});
    }

    # query params
    if ( exists $args{'dav/create_absolute_uri'}) {
        $query_params->{'dav.create-absolute-uri'} = $self->{api_client}->to_query_value($args{'dav/create_absolute_uri'});
    }

    # query params
    if ( exists $args{'dav/create_absolute_uri@type_hint'}) {
        $query_params->{'dav.create-absolute-uri@TypeHint'} = $self->{api_client}->to_query_value($args{'dav/create_absolute_uri@type_hint'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_config_apache_sling_get_servlet
#
# 
# 
# @param string $json/maximumresults  (optional)
# @param string $json/maximumresults@type_hint  (optional)
# @param boolean $enable/html  (optional)
# @param string $enable/html@type_hint  (optional)
# @param boolean $enable/txt  (optional)
# @param string $enable/txt@type_hint  (optional)
# @param boolean $enable/xml  (optional)
# @param string $enable/xml@type_hint  (optional)
{
    my $params = {
    'json/maximumresults' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'json/maximumresults@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'enable/html' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'enable/html@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'enable/txt' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'enable/txt@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'enable/xml' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'enable/xml@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_apache_sling_get_servlet' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_apache_sling_get_servlet {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'json/maximumresults'}) {
        $query_params->{'json.maximumresults'} = $self->{api_client}->to_query_value($args{'json/maximumresults'});
    }

    # query params
    if ( exists $args{'json/maximumresults@type_hint'}) {
        $query_params->{'json.maximumresults@TypeHint'} = $self->{api_client}->to_query_value($args{'json/maximumresults@type_hint'});
    }

    # query params
    if ( exists $args{'enable/html'}) {
        $query_params->{'enable.html'} = $self->{api_client}->to_query_value($args{'enable/html'});
    }

    # query params
    if ( exists $args{'enable/html@type_hint'}) {
        $query_params->{'enable.html@TypeHint'} = $self->{api_client}->to_query_value($args{'enable/html@type_hint'});
    }

    # query params
    if ( exists $args{'enable/txt'}) {
        $query_params->{'enable.txt'} = $self->{api_client}->to_query_value($args{'enable/txt'});
    }

    # query params
    if ( exists $args{'enable/txt@type_hint'}) {
        $query_params->{'enable.txt@TypeHint'} = $self->{api_client}->to_query_value($args{'enable/txt@type_hint'});
    }

    # query params
    if ( exists $args{'enable/xml'}) {
        $query_params->{'enable.xml'} = $self->{api_client}->to_query_value($args{'enable/xml'});
    }

    # query params
    if ( exists $args{'enable/xml@type_hint'}) {
        $query_params->{'enable.xml@TypeHint'} = $self->{api_client}->to_query_value($args{'enable/xml@type_hint'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_config_apache_sling_referrer_filter
#
# 
# 
# @param boolean $allow/empty  (optional)
# @param string $allow/empty@type_hint  (optional)
# @param string $allow/hosts  (optional)
# @param string $allow/hosts@type_hint  (optional)
# @param string $allow/hosts/regexp  (optional)
# @param string $allow/hosts/regexp@type_hint  (optional)
# @param string $filter/methods  (optional)
# @param string $filter/methods@type_hint  (optional)
{
    my $params = {
    'allow/empty' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'allow/empty@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'allow/hosts' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'allow/hosts@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'allow/hosts/regexp' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'allow/hosts/regexp@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'filter/methods' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'filter/methods@type_hint' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_apache_sling_referrer_filter' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_apache_sling_referrer_filter {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/apps/system/config/org.apache.sling.security.impl.ReferrerFilter';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'allow/empty'}) {
        $query_params->{'allow.empty'} = $self->{api_client}->to_query_value($args{'allow/empty'});
    }

    # query params
    if ( exists $args{'allow/empty@type_hint'}) {
        $query_params->{'allow.empty@TypeHint'} = $self->{api_client}->to_query_value($args{'allow/empty@type_hint'});
    }

    # query params
    if ( exists $args{'allow/hosts'}) {
        $query_params->{'allow.hosts'} = $self->{api_client}->to_query_value($args{'allow/hosts'});
    }

    # query params
    if ( exists $args{'allow/hosts@type_hint'}) {
        $query_params->{'allow.hosts@TypeHint'} = $self->{api_client}->to_query_value($args{'allow/hosts@type_hint'});
    }

    # query params
    if ( exists $args{'allow/hosts/regexp'}) {
        $query_params->{'allow.hosts.regexp'} = $self->{api_client}->to_query_value($args{'allow/hosts/regexp'});
    }

    # query params
    if ( exists $args{'allow/hosts/regexp@type_hint'}) {
        $query_params->{'allow.hosts.regexp@TypeHint'} = $self->{api_client}->to_query_value($args{'allow/hosts/regexp@type_hint'});
    }

    # query params
    if ( exists $args{'filter/methods'}) {
        $query_params->{'filter.methods'} = $self->{api_client}->to_query_value($args{'filter/methods'});
    }

    # query params
    if ( exists $args{'filter/methods@type_hint'}) {
        $query_params->{'filter.methods@TypeHint'} = $self->{api_client}->to_query_value($args{'filter/methods@type_hint'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_config_property
#
# 
# 
# @param string $config_node_name  (required)
{
    my $params = {
    'config_node_name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_config_property' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_config_property {
    my ($self, %args) = @_;

    # verify the required parameter 'config_node_name' is set
    unless (exists $args{'config_node_name'}) {
      croak("Missing the required parameter 'config_node_name' when calling post_config_property");
    }

    # parse inputs
    my $_resource_path = '/apps/system/config/{configNodeName}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'config_node_name'}) {
        my $_base_variable = "{" . "configNodeName" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'config_node_name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_node
#
# 
# 
# @param string $path  (required)
# @param string $name  (required)
# @param string $:operation  (optional)
# @param string $delete_authorizable  (optional)
# @param string $file  (optional)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    ':operation' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'delete_authorizable' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'file' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_node' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_node {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling post_node");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling post_node");
    }

    # parse inputs
    my $_resource_path = '/{path}/{name}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('multipart/form-data');

    # query params
    if ( exists $args{':operation'}) {
        $query_params->{':operation'} = $self->{api_client}->to_query_value($args{':operation'});
    }

    # query params
    if ( exists $args{'delete_authorizable'}) {
        $query_params->{'deleteAuthorizable'} = $self->{api_client}->to_query_value($args{'delete_authorizable'});
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # form params
    if ( exists $args{'file'} ) {
        $form_params->{'file'} = [] unless defined $form_params->{'file'};
        push @{$form_params->{'file'}}, $args{'file'};
            }
    
    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_node_rw
#
# 
# 
# @param string $path  (required)
# @param string $name  (required)
# @param string $add_members  (optional)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'add_members' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_node_rw' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_node_rw {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling post_node_rw");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling post_node_rw");
    }

    # parse inputs
    my $_resource_path = '/{path}/{name}.rw.html';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'add_members'}) {
        $query_params->{'addMembers'} = $self->{api_client}->to_query_value($args{'add_members'});
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_path
#
# 
# 
# @param string $path  (required)
# @param string $jcr:primary_type  (required)
# @param string $:name  (required)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'jcr:primary_type' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    ':name' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_path' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_path {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling post_path");
    }

    # verify the required parameter 'jcr:primary_type' is set
    unless (exists $args{'jcr:primary_type'}) {
      croak("Missing the required parameter 'jcr:primary_type' when calling post_path");
    }

    # verify the required parameter ':name' is set
    unless (exists $args{':name'}) {
      croak("Missing the required parameter ':name' when calling post_path");
    }

    # parse inputs
    my $_resource_path = '/{path}/';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'jcr:primary_type'}) {
        $query_params->{'jcr:primaryType'} = $self->{api_client}->to_query_value($args{'jcr:primary_type'});
    }

    # query params
    if ( exists $args{':name'}) {
        $query_params->{':name'} = $self->{api_client}->to_query_value($args{':name'});
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_query
#
# 
# 
# @param string $path  (required)
# @param double $p/limit  (required)
# @param string $_1_property  (required)
# @param string $_1_property/value  (required)
{
    my $params = {
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'p/limit' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    '_1_property' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    '_1_property/value' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_query' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub post_query {
    my ($self, %args) = @_;

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling post_query");
    }

    # verify the required parameter 'p/limit' is set
    unless (exists $args{'p/limit'}) {
      croak("Missing the required parameter 'p/limit' when calling post_query");
    }

    # verify the required parameter '_1_property' is set
    unless (exists $args{'_1_property'}) {
      croak("Missing the required parameter '_1_property' when calling post_query");
    }

    # verify the required parameter '_1_property/value' is set
    unless (exists $args{'_1_property/value'}) {
      croak("Missing the required parameter '_1_property/value' when calling post_query");
    }

    # parse inputs
    my $_resource_path = '/bin/querybuilder.json';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # query params
    if ( exists $args{'p/limit'}) {
        $query_params->{'p.limit'} = $self->{api_client}->to_query_value($args{'p/limit'});
    }

    # query params
    if ( exists $args{'_1_property'}) {
        $query_params->{'1_property'} = $self->{api_client}->to_query_value($args{'_1_property'});
    }

    # query params
    if ( exists $args{'_1_property/value'}) {
        $query_params->{'1_property.value'} = $self->{api_client}->to_query_value($args{'_1_property/value'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# post_tree_activation
#
# 
# 
# @param boolean $ignoredeactivated  (required)
# @param boolean $onlymodified  (required)
# @param string $path  (required)
{
    my $params = {
    'ignoredeactivated' => {
        data_type => 'boolean',
        description => '',
        required => '1',
    },
    'onlymodified' => {
        data_type => 'boolean',
        description => '',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_tree_activation' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub post_tree_activation {
    my ($self, %args) = @_;

    # verify the required parameter 'ignoredeactivated' is set
    unless (exists $args{'ignoredeactivated'}) {
      croak("Missing the required parameter 'ignoredeactivated' when calling post_tree_activation");
    }

    # verify the required parameter 'onlymodified' is set
    unless (exists $args{'onlymodified'}) {
      croak("Missing the required parameter 'onlymodified' when calling post_tree_activation");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling post_tree_activation");
    }

    # parse inputs
    my $_resource_path = '/etc/replication/treeactivation.html';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'ignoredeactivated'}) {
        $query_params->{'ignoredeactivated'} = $self->{api_client}->to_query_value($args{'ignoredeactivated'});
    }

    # query params
    if ( exists $args{'onlymodified'}) {
        $query_params->{'onlymodified'} = $self->{api_client}->to_query_value($args{'onlymodified'});
    }

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# post_truststore
#
# 
# 
# @param string $:operation  (optional)
# @param string $new_password  (optional)
# @param string $re_password  (optional)
# @param string $key_store_type  (optional)
# @param string $remove_alias  (optional)
# @param string $certificate  (optional)
{
    my $params = {
    ':operation' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'new_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    're_password' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'key_store_type' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'remove_alias' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'certificate' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_truststore' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub post_truststore {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/libs/granite/security/post/truststore';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('multipart/form-data');

    # query params
    if ( exists $args{':operation'}) {
        $query_params->{':operation'} = $self->{api_client}->to_query_value($args{':operation'});
    }

    # query params
    if ( exists $args{'new_password'}) {
        $query_params->{'newPassword'} = $self->{api_client}->to_query_value($args{'new_password'});
    }

    # query params
    if ( exists $args{'re_password'}) {
        $query_params->{'rePassword'} = $self->{api_client}->to_query_value($args{'re_password'});
    }

    # query params
    if ( exists $args{'key_store_type'}) {
        $query_params->{'keyStoreType'} = $self->{api_client}->to_query_value($args{'key_store_type'});
    }

    # query params
    if ( exists $args{'remove_alias'}) {
        $query_params->{'removeAlias'} = $self->{api_client}->to_query_value($args{'remove_alias'});
    }

    # form params
    if ( exists $args{'certificate'} ) {
        $form_params->{'certificate'} = [] unless defined $form_params->{'certificate'};
        push @{$form_params->{'certificate'}}, $args{'certificate'};
            }
    
    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# post_truststore_pkcs12
#
# 
# 
# @param string $truststore/p12  (optional)
{
    my $params = {
    'truststore/p12' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'post_truststore_pkcs12' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub post_truststore_pkcs12 {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/etc/truststore';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('multipart/form-data');

    # form params
    if ( exists $args{'truststore/p12'} ) {
        $form_params->{'truststore.p12'} = [] unless defined $form_params->{'truststore.p12'};
        push @{$form_params->{'truststore.p12'}}, $args{'truststore/p12'};
            }
    
    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(aemAuth )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

1;
