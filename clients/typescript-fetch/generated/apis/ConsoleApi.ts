/* tslint:disable */
/* eslint-disable */
/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BundleInfo,
    BundleInfoFromJSON,
    BundleInfoToJSON,
    SamlConfigurationInfo,
    SamlConfigurationInfoFromJSON,
    SamlConfigurationInfoToJSON,
} from '../models';

export interface GetBundleInfoRequest {
    name: string;
}

export interface PostBundleRequest {
    name: string;
    action: string;
}

export interface PostJmxRepositoryRequest {
    action: string;
}

export interface PostSamlConfigurationRequest {
    post?: boolean;
    apply?: boolean;
    _delete?: boolean;
    action?: string;
    $location?: string;
    path?: Array<string>;
    serviceRanking?: number;
    idpUrl?: string;
    idpCertAlias?: string;
    idpHttpRedirect?: boolean;
    serviceProviderEntityId?: string;
    assertionConsumerServiceURL?: string;
    spPrivateKeyAlias?: string;
    keyStorePassword?: string;
    defaultRedirectUrl?: string;
    userIDAttribute?: string;
    useEncryption?: boolean;
    createUser?: boolean;
    addGroupMemberships?: boolean;
    groupMembershipAttribute?: string;
    defaultGroups?: Array<string>;
    nameIdFormat?: string;
    synchronizeAttributes?: Array<string>;
    handleLogout?: boolean;
    logoutUrl?: string;
    clockTolerance?: number;
    digestMethod?: string;
    signatureMethod?: string;
    userIntermediatePath?: string;
    propertylist?: Array<string>;
}

/**
 * 
 */
export class ConsoleApi extends runtime.BaseAPI {

    /**
     */
    async getAemProductInfoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/system/console/status-productinfo.json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     */
    async getAemProductInfo(initOverrides?: RequestInit): Promise<Array<string>> {
        const response = await this.getAemProductInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getBundleInfoRaw(requestParameters: GetBundleInfoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BundleInfo>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getBundleInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/system/console/bundles/{name}.json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BundleInfoFromJSON(jsonValue));
    }

    /**
     */
    async getBundleInfo(requestParameters: GetBundleInfoRequest, initOverrides?: RequestInit): Promise<BundleInfo> {
        const response = await this.getBundleInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getConfigMgrRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/system/console/configMgr`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getConfigMgr(initOverrides?: RequestInit): Promise<string> {
        const response = await this.getConfigMgrRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async postBundleRaw(requestParameters: PostBundleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postBundle.');
        }

        if (requestParameters.action === null || requestParameters.action === undefined) {
            throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling postBundle.');
        }

        const queryParameters: any = {};

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/system/console/bundles/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postBundle(requestParameters: PostBundleRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postBundleRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postJmxRepositoryRaw(requestParameters: PostJmxRepositoryRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.action === null || requestParameters.action === undefined) {
            throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling postJmxRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/system/console/jmx/com.adobe.granite:type=Repository/op/{action}`.replace(`{${"action"}}`, encodeURIComponent(String(requestParameters.action))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postJmxRepository(requestParameters: PostJmxRepositoryRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJmxRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postSamlConfigurationRaw(requestParameters: PostSamlConfigurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SamlConfigurationInfo>> {
        const queryParameters: any = {};

        if (requestParameters.post !== undefined) {
            queryParameters['post'] = requestParameters.post;
        }

        if (requestParameters.apply !== undefined) {
            queryParameters['apply'] = requestParameters.apply;
        }

        if (requestParameters._delete !== undefined) {
            queryParameters['delete'] = requestParameters._delete;
        }

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        if (requestParameters.$location !== undefined) {
            queryParameters['$location'] = requestParameters.$location;
        }

        if (requestParameters.path) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.serviceRanking !== undefined) {
            queryParameters['service.ranking'] = requestParameters.serviceRanking;
        }

        if (requestParameters.idpUrl !== undefined) {
            queryParameters['idpUrl'] = requestParameters.idpUrl;
        }

        if (requestParameters.idpCertAlias !== undefined) {
            queryParameters['idpCertAlias'] = requestParameters.idpCertAlias;
        }

        if (requestParameters.idpHttpRedirect !== undefined) {
            queryParameters['idpHttpRedirect'] = requestParameters.idpHttpRedirect;
        }

        if (requestParameters.serviceProviderEntityId !== undefined) {
            queryParameters['serviceProviderEntityId'] = requestParameters.serviceProviderEntityId;
        }

        if (requestParameters.assertionConsumerServiceURL !== undefined) {
            queryParameters['assertionConsumerServiceURL'] = requestParameters.assertionConsumerServiceURL;
        }

        if (requestParameters.spPrivateKeyAlias !== undefined) {
            queryParameters['spPrivateKeyAlias'] = requestParameters.spPrivateKeyAlias;
        }

        if (requestParameters.keyStorePassword !== undefined) {
            queryParameters['keyStorePassword'] = requestParameters.keyStorePassword;
        }

        if (requestParameters.defaultRedirectUrl !== undefined) {
            queryParameters['defaultRedirectUrl'] = requestParameters.defaultRedirectUrl;
        }

        if (requestParameters.userIDAttribute !== undefined) {
            queryParameters['userIDAttribute'] = requestParameters.userIDAttribute;
        }

        if (requestParameters.useEncryption !== undefined) {
            queryParameters['useEncryption'] = requestParameters.useEncryption;
        }

        if (requestParameters.createUser !== undefined) {
            queryParameters['createUser'] = requestParameters.createUser;
        }

        if (requestParameters.addGroupMemberships !== undefined) {
            queryParameters['addGroupMemberships'] = requestParameters.addGroupMemberships;
        }

        if (requestParameters.groupMembershipAttribute !== undefined) {
            queryParameters['groupMembershipAttribute'] = requestParameters.groupMembershipAttribute;
        }

        if (requestParameters.defaultGroups) {
            queryParameters['defaultGroups'] = requestParameters.defaultGroups;
        }

        if (requestParameters.nameIdFormat !== undefined) {
            queryParameters['nameIdFormat'] = requestParameters.nameIdFormat;
        }

        if (requestParameters.synchronizeAttributes) {
            queryParameters['synchronizeAttributes'] = requestParameters.synchronizeAttributes;
        }

        if (requestParameters.handleLogout !== undefined) {
            queryParameters['handleLogout'] = requestParameters.handleLogout;
        }

        if (requestParameters.logoutUrl !== undefined) {
            queryParameters['logoutUrl'] = requestParameters.logoutUrl;
        }

        if (requestParameters.clockTolerance !== undefined) {
            queryParameters['clockTolerance'] = requestParameters.clockTolerance;
        }

        if (requestParameters.digestMethod !== undefined) {
            queryParameters['digestMethod'] = requestParameters.digestMethod;
        }

        if (requestParameters.signatureMethod !== undefined) {
            queryParameters['signatureMethod'] = requestParameters.signatureMethod;
        }

        if (requestParameters.userIntermediatePath !== undefined) {
            queryParameters['userIntermediatePath'] = requestParameters.userIntermediatePath;
        }

        if (requestParameters.propertylist) {
            queryParameters['propertylist'] = requestParameters.propertylist.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SamlConfigurationInfoFromJSON(jsonValue));
    }

    /**
     */
    async postSamlConfiguration(requestParameters: PostSamlConfigurationRequest, initOverrides?: RequestInit): Promise<SamlConfigurationInfo> {
        const response = await this.postSamlConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
