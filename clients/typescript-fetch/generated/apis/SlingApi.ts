/* tslint:disable */
/* eslint-disable */
/**
 * Adobe Experience Manager (AEM) API
 * Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API
 *
 * The version of the OpenAPI document: 3.5.0-pre.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    KeystoreInfo,
    KeystoreInfoFromJSON,
    KeystoreInfoToJSON,
    TruststoreInfo,
    TruststoreInfoFromJSON,
    TruststoreInfoToJSON,
} from '../models';

export interface DeleteAgentRequest {
    runmode: string;
    name: string;
}

export interface DeleteNodeRequest {
    path: string;
    name: string;
}

export interface GetAgentRequest {
    runmode: string;
    name: string;
}

export interface GetAgentsRequest {
    runmode: string;
}

export interface GetAuthorizableKeystoreRequest {
    intermediatePath: string;
    authorizableId: string;
}

export interface GetKeystoreRequest {
    intermediatePath: string;
    authorizableId: string;
}

export interface GetNodeRequest {
    path: string;
    name: string;
}

export interface GetPackageRequest {
    group: string;
    name: string;
    version: string;
}

export interface GetPackageFilterRequest {
    group: string;
    name: string;
    version: string;
}

export interface GetQueryRequest {
    path: string;
    pLimit: number;
    _1property: string;
    _1propertyValue: string;
}

export interface PostAgentRequest {
    runmode: string;
    name: string;
    jcrcontentCqdistribute?: boolean;
    jcrcontentCqdistributeTypeHint?: string;
    jcrcontentCqname?: string;
    jcrcontentCqtemplate?: string;
    jcrcontentEnabled?: boolean;
    jcrcontentJcrdescription?: string;
    jcrcontentJcrlastModified?: string;
    jcrcontentJcrlastModifiedBy?: string;
    jcrcontentJcrmixinTypes?: string;
    jcrcontentJcrtitle?: string;
    jcrcontentLogLevel?: string;
    jcrcontentNoStatusUpdate?: boolean;
    jcrcontentNoVersioning?: boolean;
    jcrcontentProtocolConnectTimeout?: number;
    jcrcontentProtocolHTTPConnectionClosed?: boolean;
    jcrcontentProtocolHTTPExpired?: string;
    jcrcontentProtocolHTTPHeaders?: Array<string>;
    jcrcontentProtocolHTTPHeadersTypeHint?: string;
    jcrcontentProtocolHTTPMethod?: string;
    jcrcontentProtocolHTTPSRelaxed?: boolean;
    jcrcontentProtocolInterface?: string;
    jcrcontentProtocolSocketTimeout?: number;
    jcrcontentProtocolVersion?: string;
    jcrcontentProxyNTLMDomain?: string;
    jcrcontentProxyNTLMHost?: string;
    jcrcontentProxyHost?: string;
    jcrcontentProxyPassword?: string;
    jcrcontentProxyPort?: number;
    jcrcontentProxyUser?: string;
    jcrcontentQueueBatchMaxSize?: number;
    jcrcontentQueueBatchMode?: string;
    jcrcontentQueueBatchWaitTime?: number;
    jcrcontentRetryDelay?: string;
    jcrcontentReverseReplication?: boolean;
    jcrcontentSerializationType?: string;
    jcrcontentSlingresourceType?: string;
    jcrcontentSsl?: string;
    jcrcontentTransportNTLMDomain?: string;
    jcrcontentTransportNTLMHost?: string;
    jcrcontentTransportPassword?: string;
    jcrcontentTransportUri?: string;
    jcrcontentTransportUser?: string;
    jcrcontentTriggerDistribute?: boolean;
    jcrcontentTriggerModified?: boolean;
    jcrcontentTriggerOnOffTime?: boolean;
    jcrcontentTriggerReceive?: boolean;
    jcrcontentTriggerSpecific?: boolean;
    jcrcontentUserId?: string;
    jcrprimaryType?: string;
    operation?: string;
}

export interface PostAuthorizableKeystoreRequest {
    intermediatePath: string;
    authorizableId: string;
    operation?: string;
    currentPassword?: string;
    newPassword?: string;
    rePassword?: string;
    keyPassword?: string;
    keyStorePass?: string;
    alias?: string;
    newAlias?: string;
    removeAlias?: string;
    certChain?: Blob;
    pk?: Blob;
    keyStore?: Blob;
}

export interface PostAuthorizablesRequest {
    authorizableId: string;
    intermediatePath: string;
    createUser?: string;
    createGroup?: string;
    reppassword?: string;
    profileGivenName?: string;
}

export interface PostConfigAdobeGraniteSamlAuthenticationHandlerRequest {
    keyStorePassword?: string;
    keyStorePasswordTypeHint?: string;
    serviceRanking?: number;
    serviceRankingTypeHint?: string;
    idpHttpRedirect?: boolean;
    idpHttpRedirectTypeHint?: string;
    createUser?: boolean;
    createUserTypeHint?: string;
    defaultRedirectUrl?: string;
    defaultRedirectUrlTypeHint?: string;
    userIDAttribute?: string;
    userIDAttributeTypeHint?: string;
    defaultGroups?: Array<string>;
    defaultGroupsTypeHint?: string;
    idpCertAlias?: string;
    idpCertAliasTypeHint?: string;
    addGroupMemberships?: boolean;
    addGroupMembershipsTypeHint?: string;
    path?: Array<string>;
    pathTypeHint?: string;
    synchronizeAttributes?: Array<string>;
    synchronizeAttributesTypeHint?: string;
    clockTolerance?: number;
    clockToleranceTypeHint?: string;
    groupMembershipAttribute?: string;
    groupMembershipAttributeTypeHint?: string;
    idpUrl?: string;
    idpUrlTypeHint?: string;
    logoutUrl?: string;
    logoutUrlTypeHint?: string;
    serviceProviderEntityId?: string;
    serviceProviderEntityIdTypeHint?: string;
    assertionConsumerServiceURL?: string;
    assertionConsumerServiceURLTypeHint?: string;
    handleLogout?: boolean;
    handleLogoutTypeHint?: string;
    spPrivateKeyAlias?: string;
    spPrivateKeyAliasTypeHint?: string;
    useEncryption?: boolean;
    useEncryptionTypeHint?: string;
    nameIdFormat?: string;
    nameIdFormatTypeHint?: string;
    digestMethod?: string;
    digestMethodTypeHint?: string;
    signatureMethod?: string;
    signatureMethodTypeHint?: string;
    userIntermediatePath?: string;
    userIntermediatePathTypeHint?: string;
}

export interface PostConfigApacheFelixJettyBasedHttpServiceRequest {
    orgApacheFelixHttpsNio?: boolean;
    orgApacheFelixHttpsNioTypeHint?: string;
    orgApacheFelixHttpsKeystore?: string;
    orgApacheFelixHttpsKeystoreTypeHint?: string;
    orgApacheFelixHttpsKeystorePassword?: string;
    orgApacheFelixHttpsKeystorePasswordTypeHint?: string;
    orgApacheFelixHttpsKeystoreKey?: string;
    orgApacheFelixHttpsKeystoreKeyTypeHint?: string;
    orgApacheFelixHttpsKeystoreKeyPassword?: string;
    orgApacheFelixHttpsKeystoreKeyPasswordTypeHint?: string;
    orgApacheFelixHttpsTruststore?: string;
    orgApacheFelixHttpsTruststoreTypeHint?: string;
    orgApacheFelixHttpsTruststorePassword?: string;
    orgApacheFelixHttpsTruststorePasswordTypeHint?: string;
    orgApacheFelixHttpsClientcertificate?: string;
    orgApacheFelixHttpsClientcertificateTypeHint?: string;
    orgApacheFelixHttpsEnable?: boolean;
    orgApacheFelixHttpsEnableTypeHint?: string;
    orgOsgiServiceHttpPortSecure?: string;
    orgOsgiServiceHttpPortSecureTypeHint?: string;
}

export interface PostConfigApacheHttpComponentsProxyConfigurationRequest {
    proxyHost?: string;
    proxyHostTypeHint?: string;
    proxyPort?: number;
    proxyPortTypeHint?: string;
    proxyExceptions?: Array<string>;
    proxyExceptionsTypeHint?: string;
    proxyEnabled?: boolean;
    proxyEnabledTypeHint?: string;
    proxyUser?: string;
    proxyUserTypeHint?: string;
    proxyPassword?: string;
    proxyPasswordTypeHint?: string;
}

export interface PostConfigApacheSlingDavExServletRequest {
    alias?: string;
    aliasTypeHint?: string;
    davCreateAbsoluteUri?: boolean;
    davCreateAbsoluteUriTypeHint?: string;
}

export interface PostConfigApacheSlingGetServletRequest {
    jsonMaximumresults?: string;
    jsonMaximumresultsTypeHint?: string;
    enableHtml?: boolean;
    enableHtmlTypeHint?: string;
    enableTxt?: boolean;
    enableTxtTypeHint?: string;
    enableXml?: boolean;
    enableXmlTypeHint?: string;
}

export interface PostConfigApacheSlingReferrerFilterRequest {
    allowEmpty?: boolean;
    allowEmptyTypeHint?: string;
    allowHosts?: string;
    allowHostsTypeHint?: string;
    allowHostsRegexp?: string;
    allowHostsRegexpTypeHint?: string;
    filterMethods?: string;
    filterMethodsTypeHint?: string;
}

export interface PostConfigPropertyRequest {
    configNodeName: string;
}

export interface PostNodeRequest {
    path: string;
    name: string;
    operation?: string;
    deleteAuthorizable?: string;
    file?: Blob;
}

export interface PostNodeRwRequest {
    path: string;
    name: string;
    addMembers?: string;
}

export interface PostPathRequest {
    path: string;
    jcrprimaryType: string;
    name: string;
}

export interface PostQueryRequest {
    path: string;
    pLimit: number;
    _1property: string;
    _1propertyValue: string;
}

export interface PostTreeActivationRequest {
    ignoredeactivated: boolean;
    onlymodified: boolean;
    path: string;
}

export interface PostTruststoreRequest {
    operation?: string;
    newPassword?: string;
    rePassword?: string;
    keyStoreType?: string;
    removeAlias?: string;
    certificate?: Blob;
}

export interface PostTruststorePKCS12Request {
    truststoreP12?: Blob;
}

/**
 * 
 */
export class SlingApi extends runtime.BaseAPI {

    /**
     */
    async deleteAgentRaw(requestParameters: DeleteAgentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.runmode === null || requestParameters.runmode === undefined) {
            throw new runtime.RequiredError('runmode','Required parameter requestParameters.runmode was null or undefined when calling deleteAgent.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/replication/agents.{runmode}/{name}`.replace(`{${"runmode"}}`, encodeURIComponent(String(requestParameters.runmode))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteAgent(requestParameters: DeleteAgentRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteAgentRaw(requestParameters, initOverrides);
    }

    /**
     */
    async deleteNodeRaw(requestParameters: DeleteNodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling deleteNode.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteNode.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{path}/{name}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteNode(requestParameters: DeleteNodeRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteNodeRaw(requestParameters, initOverrides);
    }

    /**
     */
    async getAgentRaw(requestParameters: GetAgentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.runmode === null || requestParameters.runmode === undefined) {
            throw new runtime.RequiredError('runmode','Required parameter requestParameters.runmode was null or undefined when calling getAgent.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/replication/agents.{runmode}/{name}`.replace(`{${"runmode"}}`, encodeURIComponent(String(requestParameters.runmode))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getAgent(requestParameters: GetAgentRequest, initOverrides?: RequestInit): Promise<void> {
        await this.getAgentRaw(requestParameters, initOverrides);
    }

    /**
     */
    async getAgentsRaw(requestParameters: GetAgentsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.runmode === null || requestParameters.runmode === undefined) {
            throw new runtime.RequiredError('runmode','Required parameter requestParameters.runmode was null or undefined when calling getAgents.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/replication/agents.{runmode}.-1.json`.replace(`{${"runmode"}}`, encodeURIComponent(String(requestParameters.runmode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getAgents(requestParameters: GetAgentsRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.getAgentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getAuthorizableKeystoreRaw(requestParameters: GetAuthorizableKeystoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<KeystoreInfo>> {
        if (requestParameters.intermediatePath === null || requestParameters.intermediatePath === undefined) {
            throw new runtime.RequiredError('intermediatePath','Required parameter requestParameters.intermediatePath was null or undefined when calling getAuthorizableKeystore.');
        }

        if (requestParameters.authorizableId === null || requestParameters.authorizableId === undefined) {
            throw new runtime.RequiredError('authorizableId','Required parameter requestParameters.authorizableId was null or undefined when calling getAuthorizableKeystore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{intermediatePath}/{authorizableId}.ks.json`.replace(`{${"intermediatePath"}}`, encodeURIComponent(String(requestParameters.intermediatePath))).replace(`{${"authorizableId"}}`, encodeURIComponent(String(requestParameters.authorizableId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeystoreInfoFromJSON(jsonValue));
    }

    /**
     */
    async getAuthorizableKeystore(requestParameters: GetAuthorizableKeystoreRequest, initOverrides?: RequestInit): Promise<KeystoreInfo> {
        const response = await this.getAuthorizableKeystoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getKeystoreRaw(requestParameters: GetKeystoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.intermediatePath === null || requestParameters.intermediatePath === undefined) {
            throw new runtime.RequiredError('intermediatePath','Required parameter requestParameters.intermediatePath was null or undefined when calling getKeystore.');
        }

        if (requestParameters.authorizableId === null || requestParameters.authorizableId === undefined) {
            throw new runtime.RequiredError('authorizableId','Required parameter requestParameters.authorizableId was null or undefined when calling getKeystore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{intermediatePath}/{authorizableId}/keystore/store.p12`.replace(`{${"intermediatePath"}}`, encodeURIComponent(String(requestParameters.intermediatePath))).replace(`{${"authorizableId"}}`, encodeURIComponent(String(requestParameters.authorizableId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getKeystore(requestParameters: GetKeystoreRequest, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getKeystoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getNodeRaw(requestParameters: GetNodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getNode.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getNode.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{path}/{name}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getNode(requestParameters: GetNodeRequest, initOverrides?: RequestInit): Promise<void> {
        await this.getNodeRaw(requestParameters, initOverrides);
    }

    /**
     */
    async getPackageRaw(requestParameters: GetPackageRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getPackage.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getPackage.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling getPackage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/packages/{group}/{name}-{version}.zip`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"version"}}`, encodeURIComponent(String(requestParameters.version))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getPackage(requestParameters: GetPackageRequest, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getPackageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getPackageFilterRaw(requestParameters: GetPackageFilterRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.group === null || requestParameters.group === undefined) {
            throw new runtime.RequiredError('group','Required parameter requestParameters.group was null or undefined when calling getPackageFilter.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getPackageFilter.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling getPackageFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`.replace(`{${"group"}}`, encodeURIComponent(String(requestParameters.group))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"version"}}`, encodeURIComponent(String(requestParameters.version))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getPackageFilter(requestParameters: GetPackageFilterRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.getPackageFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getQueryRaw(requestParameters: GetQueryRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getQuery.');
        }

        if (requestParameters.pLimit === null || requestParameters.pLimit === undefined) {
            throw new runtime.RequiredError('pLimit','Required parameter requestParameters.pLimit was null or undefined when calling getQuery.');
        }

        if (requestParameters._1property === null || requestParameters._1property === undefined) {
            throw new runtime.RequiredError('_1property','Required parameter requestParameters._1property was null or undefined when calling getQuery.');
        }

        if (requestParameters._1propertyValue === null || requestParameters._1propertyValue === undefined) {
            throw new runtime.RequiredError('_1propertyValue','Required parameter requestParameters._1propertyValue was null or undefined when calling getQuery.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.pLimit !== undefined) {
            queryParameters['p.limit'] = requestParameters.pLimit;
        }

        if (requestParameters._1property !== undefined) {
            queryParameters['1_property'] = requestParameters._1property;
        }

        if (requestParameters._1propertyValue !== undefined) {
            queryParameters['1_property.value'] = requestParameters._1propertyValue;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/bin/querybuilder.json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getQuery(requestParameters: GetQueryRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.getQueryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTruststoreRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/truststore/truststore.p12`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async getTruststore(initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getTruststoreRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getTruststoreInfoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<TruststoreInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/libs/granite/security/truststore.json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TruststoreInfoFromJSON(jsonValue));
    }

    /**
     */
    async getTruststoreInfo(initOverrides?: RequestInit): Promise<TruststoreInfo> {
        const response = await this.getTruststoreInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async postAgentRaw(requestParameters: PostAgentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.runmode === null || requestParameters.runmode === undefined) {
            throw new runtime.RequiredError('runmode','Required parameter requestParameters.runmode was null or undefined when calling postAgent.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postAgent.');
        }

        const queryParameters: any = {};

        if (requestParameters.jcrcontentCqdistribute !== undefined) {
            queryParameters['jcr:content/cq:distribute'] = requestParameters.jcrcontentCqdistribute;
        }

        if (requestParameters.jcrcontentCqdistributeTypeHint !== undefined) {
            queryParameters['jcr:content/cq:distribute@TypeHint'] = requestParameters.jcrcontentCqdistributeTypeHint;
        }

        if (requestParameters.jcrcontentCqname !== undefined) {
            queryParameters['jcr:content/cq:name'] = requestParameters.jcrcontentCqname;
        }

        if (requestParameters.jcrcontentCqtemplate !== undefined) {
            queryParameters['jcr:content/cq:template'] = requestParameters.jcrcontentCqtemplate;
        }

        if (requestParameters.jcrcontentEnabled !== undefined) {
            queryParameters['jcr:content/enabled'] = requestParameters.jcrcontentEnabled;
        }

        if (requestParameters.jcrcontentJcrdescription !== undefined) {
            queryParameters['jcr:content/jcr:description'] = requestParameters.jcrcontentJcrdescription;
        }

        if (requestParameters.jcrcontentJcrlastModified !== undefined) {
            queryParameters['jcr:content/jcr:lastModified'] = requestParameters.jcrcontentJcrlastModified;
        }

        if (requestParameters.jcrcontentJcrlastModifiedBy !== undefined) {
            queryParameters['jcr:content/jcr:lastModifiedBy'] = requestParameters.jcrcontentJcrlastModifiedBy;
        }

        if (requestParameters.jcrcontentJcrmixinTypes !== undefined) {
            queryParameters['jcr:content/jcr:mixinTypes'] = requestParameters.jcrcontentJcrmixinTypes;
        }

        if (requestParameters.jcrcontentJcrtitle !== undefined) {
            queryParameters['jcr:content/jcr:title'] = requestParameters.jcrcontentJcrtitle;
        }

        if (requestParameters.jcrcontentLogLevel !== undefined) {
            queryParameters['jcr:content/logLevel'] = requestParameters.jcrcontentLogLevel;
        }

        if (requestParameters.jcrcontentNoStatusUpdate !== undefined) {
            queryParameters['jcr:content/noStatusUpdate'] = requestParameters.jcrcontentNoStatusUpdate;
        }

        if (requestParameters.jcrcontentNoVersioning !== undefined) {
            queryParameters['jcr:content/noVersioning'] = requestParameters.jcrcontentNoVersioning;
        }

        if (requestParameters.jcrcontentProtocolConnectTimeout !== undefined) {
            queryParameters['jcr:content/protocolConnectTimeout'] = requestParameters.jcrcontentProtocolConnectTimeout;
        }

        if (requestParameters.jcrcontentProtocolHTTPConnectionClosed !== undefined) {
            queryParameters['jcr:content/protocolHTTPConnectionClosed'] = requestParameters.jcrcontentProtocolHTTPConnectionClosed;
        }

        if (requestParameters.jcrcontentProtocolHTTPExpired !== undefined) {
            queryParameters['jcr:content/protocolHTTPExpired'] = requestParameters.jcrcontentProtocolHTTPExpired;
        }

        if (requestParameters.jcrcontentProtocolHTTPHeaders) {
            queryParameters['jcr:content/protocolHTTPHeaders'] = requestParameters.jcrcontentProtocolHTTPHeaders;
        }

        if (requestParameters.jcrcontentProtocolHTTPHeadersTypeHint !== undefined) {
            queryParameters['jcr:content/protocolHTTPHeaders@TypeHint'] = requestParameters.jcrcontentProtocolHTTPHeadersTypeHint;
        }

        if (requestParameters.jcrcontentProtocolHTTPMethod !== undefined) {
            queryParameters['jcr:content/protocolHTTPMethod'] = requestParameters.jcrcontentProtocolHTTPMethod;
        }

        if (requestParameters.jcrcontentProtocolHTTPSRelaxed !== undefined) {
            queryParameters['jcr:content/protocolHTTPSRelaxed'] = requestParameters.jcrcontentProtocolHTTPSRelaxed;
        }

        if (requestParameters.jcrcontentProtocolInterface !== undefined) {
            queryParameters['jcr:content/protocolInterface'] = requestParameters.jcrcontentProtocolInterface;
        }

        if (requestParameters.jcrcontentProtocolSocketTimeout !== undefined) {
            queryParameters['jcr:content/protocolSocketTimeout'] = requestParameters.jcrcontentProtocolSocketTimeout;
        }

        if (requestParameters.jcrcontentProtocolVersion !== undefined) {
            queryParameters['jcr:content/protocolVersion'] = requestParameters.jcrcontentProtocolVersion;
        }

        if (requestParameters.jcrcontentProxyNTLMDomain !== undefined) {
            queryParameters['jcr:content/proxyNTLMDomain'] = requestParameters.jcrcontentProxyNTLMDomain;
        }

        if (requestParameters.jcrcontentProxyNTLMHost !== undefined) {
            queryParameters['jcr:content/proxyNTLMHost'] = requestParameters.jcrcontentProxyNTLMHost;
        }

        if (requestParameters.jcrcontentProxyHost !== undefined) {
            queryParameters['jcr:content/proxyHost'] = requestParameters.jcrcontentProxyHost;
        }

        if (requestParameters.jcrcontentProxyPassword !== undefined) {
            queryParameters['jcr:content/proxyPassword'] = requestParameters.jcrcontentProxyPassword;
        }

        if (requestParameters.jcrcontentProxyPort !== undefined) {
            queryParameters['jcr:content/proxyPort'] = requestParameters.jcrcontentProxyPort;
        }

        if (requestParameters.jcrcontentProxyUser !== undefined) {
            queryParameters['jcr:content/proxyUser'] = requestParameters.jcrcontentProxyUser;
        }

        if (requestParameters.jcrcontentQueueBatchMaxSize !== undefined) {
            queryParameters['jcr:content/queueBatchMaxSize'] = requestParameters.jcrcontentQueueBatchMaxSize;
        }

        if (requestParameters.jcrcontentQueueBatchMode !== undefined) {
            queryParameters['jcr:content/queueBatchMode'] = requestParameters.jcrcontentQueueBatchMode;
        }

        if (requestParameters.jcrcontentQueueBatchWaitTime !== undefined) {
            queryParameters['jcr:content/queueBatchWaitTime'] = requestParameters.jcrcontentQueueBatchWaitTime;
        }

        if (requestParameters.jcrcontentRetryDelay !== undefined) {
            queryParameters['jcr:content/retryDelay'] = requestParameters.jcrcontentRetryDelay;
        }

        if (requestParameters.jcrcontentReverseReplication !== undefined) {
            queryParameters['jcr:content/reverseReplication'] = requestParameters.jcrcontentReverseReplication;
        }

        if (requestParameters.jcrcontentSerializationType !== undefined) {
            queryParameters['jcr:content/serializationType'] = requestParameters.jcrcontentSerializationType;
        }

        if (requestParameters.jcrcontentSlingresourceType !== undefined) {
            queryParameters['jcr:content/sling:resourceType'] = requestParameters.jcrcontentSlingresourceType;
        }

        if (requestParameters.jcrcontentSsl !== undefined) {
            queryParameters['jcr:content/ssl'] = requestParameters.jcrcontentSsl;
        }

        if (requestParameters.jcrcontentTransportNTLMDomain !== undefined) {
            queryParameters['jcr:content/transportNTLMDomain'] = requestParameters.jcrcontentTransportNTLMDomain;
        }

        if (requestParameters.jcrcontentTransportNTLMHost !== undefined) {
            queryParameters['jcr:content/transportNTLMHost'] = requestParameters.jcrcontentTransportNTLMHost;
        }

        if (requestParameters.jcrcontentTransportPassword !== undefined) {
            queryParameters['jcr:content/transportPassword'] = requestParameters.jcrcontentTransportPassword;
        }

        if (requestParameters.jcrcontentTransportUri !== undefined) {
            queryParameters['jcr:content/transportUri'] = requestParameters.jcrcontentTransportUri;
        }

        if (requestParameters.jcrcontentTransportUser !== undefined) {
            queryParameters['jcr:content/transportUser'] = requestParameters.jcrcontentTransportUser;
        }

        if (requestParameters.jcrcontentTriggerDistribute !== undefined) {
            queryParameters['jcr:content/triggerDistribute'] = requestParameters.jcrcontentTriggerDistribute;
        }

        if (requestParameters.jcrcontentTriggerModified !== undefined) {
            queryParameters['jcr:content/triggerModified'] = requestParameters.jcrcontentTriggerModified;
        }

        if (requestParameters.jcrcontentTriggerOnOffTime !== undefined) {
            queryParameters['jcr:content/triggerOnOffTime'] = requestParameters.jcrcontentTriggerOnOffTime;
        }

        if (requestParameters.jcrcontentTriggerReceive !== undefined) {
            queryParameters['jcr:content/triggerReceive'] = requestParameters.jcrcontentTriggerReceive;
        }

        if (requestParameters.jcrcontentTriggerSpecific !== undefined) {
            queryParameters['jcr:content/triggerSpecific'] = requestParameters.jcrcontentTriggerSpecific;
        }

        if (requestParameters.jcrcontentUserId !== undefined) {
            queryParameters['jcr:content/userId'] = requestParameters.jcrcontentUserId;
        }

        if (requestParameters.jcrprimaryType !== undefined) {
            queryParameters['jcr:primaryType'] = requestParameters.jcrprimaryType;
        }

        if (requestParameters.operation !== undefined) {
            queryParameters[':operation'] = requestParameters.operation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/replication/agents.{runmode}/{name}`.replace(`{${"runmode"}}`, encodeURIComponent(String(requestParameters.runmode))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postAgent(requestParameters: PostAgentRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postAgentRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postAuthorizableKeystoreRaw(requestParameters: PostAuthorizableKeystoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<KeystoreInfo>> {
        if (requestParameters.intermediatePath === null || requestParameters.intermediatePath === undefined) {
            throw new runtime.RequiredError('intermediatePath','Required parameter requestParameters.intermediatePath was null or undefined when calling postAuthorizableKeystore.');
        }

        if (requestParameters.authorizableId === null || requestParameters.authorizableId === undefined) {
            throw new runtime.RequiredError('authorizableId','Required parameter requestParameters.authorizableId was null or undefined when calling postAuthorizableKeystore.');
        }

        const queryParameters: any = {};

        if (requestParameters.operation !== undefined) {
            queryParameters[':operation'] = requestParameters.operation;
        }

        if (requestParameters.currentPassword !== undefined) {
            queryParameters['currentPassword'] = requestParameters.currentPassword;
        }

        if (requestParameters.newPassword !== undefined) {
            queryParameters['newPassword'] = requestParameters.newPassword;
        }

        if (requestParameters.rePassword !== undefined) {
            queryParameters['rePassword'] = requestParameters.rePassword;
        }

        if (requestParameters.keyPassword !== undefined) {
            queryParameters['keyPassword'] = requestParameters.keyPassword;
        }

        if (requestParameters.keyStorePass !== undefined) {
            queryParameters['keyStorePass'] = requestParameters.keyStorePass;
        }

        if (requestParameters.alias !== undefined) {
            queryParameters['alias'] = requestParameters.alias;
        }

        if (requestParameters.newAlias !== undefined) {
            queryParameters['newAlias'] = requestParameters.newAlias;
        }

        if (requestParameters.removeAlias !== undefined) {
            queryParameters['removeAlias'] = requestParameters.removeAlias;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.certChain !== undefined) {
            formParams.append('cert-chain', requestParameters.certChain as any);
        }

        if (requestParameters.pk !== undefined) {
            formParams.append('pk', requestParameters.pk as any);
        }

        if (requestParameters.keyStore !== undefined) {
            formParams.append('keyStore', requestParameters.keyStore as any);
        }

        const response = await this.request({
            path: `/{intermediatePath}/{authorizableId}.ks.html`.replace(`{${"intermediatePath"}}`, encodeURIComponent(String(requestParameters.intermediatePath))).replace(`{${"authorizableId"}}`, encodeURIComponent(String(requestParameters.authorizableId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeystoreInfoFromJSON(jsonValue));
    }

    /**
     */
    async postAuthorizableKeystore(requestParameters: PostAuthorizableKeystoreRequest, initOverrides?: RequestInit): Promise<KeystoreInfo> {
        const response = await this.postAuthorizableKeystoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async postAuthorizablesRaw(requestParameters: PostAuthorizablesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.authorizableId === null || requestParameters.authorizableId === undefined) {
            throw new runtime.RequiredError('authorizableId','Required parameter requestParameters.authorizableId was null or undefined when calling postAuthorizables.');
        }

        if (requestParameters.intermediatePath === null || requestParameters.intermediatePath === undefined) {
            throw new runtime.RequiredError('intermediatePath','Required parameter requestParameters.intermediatePath was null or undefined when calling postAuthorizables.');
        }

        const queryParameters: any = {};

        if (requestParameters.authorizableId !== undefined) {
            queryParameters['authorizableId'] = requestParameters.authorizableId;
        }

        if (requestParameters.intermediatePath !== undefined) {
            queryParameters['intermediatePath'] = requestParameters.intermediatePath;
        }

        if (requestParameters.createUser !== undefined) {
            queryParameters['createUser'] = requestParameters.createUser;
        }

        if (requestParameters.createGroup !== undefined) {
            queryParameters['createGroup'] = requestParameters.createGroup;
        }

        if (requestParameters.reppassword !== undefined) {
            queryParameters['rep:password'] = requestParameters.reppassword;
        }

        if (requestParameters.profileGivenName !== undefined) {
            queryParameters['profile/givenName'] = requestParameters.profileGivenName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/libs/granite/security/post/authorizables`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async postAuthorizables(requestParameters: PostAuthorizablesRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.postAuthorizablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async postConfigAdobeGraniteSamlAuthenticationHandlerRaw(requestParameters: PostConfigAdobeGraniteSamlAuthenticationHandlerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.keyStorePassword !== undefined) {
            queryParameters['keyStorePassword'] = requestParameters.keyStorePassword;
        }

        if (requestParameters.keyStorePasswordTypeHint !== undefined) {
            queryParameters['keyStorePassword@TypeHint'] = requestParameters.keyStorePasswordTypeHint;
        }

        if (requestParameters.serviceRanking !== undefined) {
            queryParameters['service.ranking'] = requestParameters.serviceRanking;
        }

        if (requestParameters.serviceRankingTypeHint !== undefined) {
            queryParameters['service.ranking@TypeHint'] = requestParameters.serviceRankingTypeHint;
        }

        if (requestParameters.idpHttpRedirect !== undefined) {
            queryParameters['idpHttpRedirect'] = requestParameters.idpHttpRedirect;
        }

        if (requestParameters.idpHttpRedirectTypeHint !== undefined) {
            queryParameters['idpHttpRedirect@TypeHint'] = requestParameters.idpHttpRedirectTypeHint;
        }

        if (requestParameters.createUser !== undefined) {
            queryParameters['createUser'] = requestParameters.createUser;
        }

        if (requestParameters.createUserTypeHint !== undefined) {
            queryParameters['createUser@TypeHint'] = requestParameters.createUserTypeHint;
        }

        if (requestParameters.defaultRedirectUrl !== undefined) {
            queryParameters['defaultRedirectUrl'] = requestParameters.defaultRedirectUrl;
        }

        if (requestParameters.defaultRedirectUrlTypeHint !== undefined) {
            queryParameters['defaultRedirectUrl@TypeHint'] = requestParameters.defaultRedirectUrlTypeHint;
        }

        if (requestParameters.userIDAttribute !== undefined) {
            queryParameters['userIDAttribute'] = requestParameters.userIDAttribute;
        }

        if (requestParameters.userIDAttributeTypeHint !== undefined) {
            queryParameters['userIDAttribute@TypeHint'] = requestParameters.userIDAttributeTypeHint;
        }

        if (requestParameters.defaultGroups) {
            queryParameters['defaultGroups'] = requestParameters.defaultGroups;
        }

        if (requestParameters.defaultGroupsTypeHint !== undefined) {
            queryParameters['defaultGroups@TypeHint'] = requestParameters.defaultGroupsTypeHint;
        }

        if (requestParameters.idpCertAlias !== undefined) {
            queryParameters['idpCertAlias'] = requestParameters.idpCertAlias;
        }

        if (requestParameters.idpCertAliasTypeHint !== undefined) {
            queryParameters['idpCertAlias@TypeHint'] = requestParameters.idpCertAliasTypeHint;
        }

        if (requestParameters.addGroupMemberships !== undefined) {
            queryParameters['addGroupMemberships'] = requestParameters.addGroupMemberships;
        }

        if (requestParameters.addGroupMembershipsTypeHint !== undefined) {
            queryParameters['addGroupMemberships@TypeHint'] = requestParameters.addGroupMembershipsTypeHint;
        }

        if (requestParameters.path) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.pathTypeHint !== undefined) {
            queryParameters['path@TypeHint'] = requestParameters.pathTypeHint;
        }

        if (requestParameters.synchronizeAttributes) {
            queryParameters['synchronizeAttributes'] = requestParameters.synchronizeAttributes;
        }

        if (requestParameters.synchronizeAttributesTypeHint !== undefined) {
            queryParameters['synchronizeAttributes@TypeHint'] = requestParameters.synchronizeAttributesTypeHint;
        }

        if (requestParameters.clockTolerance !== undefined) {
            queryParameters['clockTolerance'] = requestParameters.clockTolerance;
        }

        if (requestParameters.clockToleranceTypeHint !== undefined) {
            queryParameters['clockTolerance@TypeHint'] = requestParameters.clockToleranceTypeHint;
        }

        if (requestParameters.groupMembershipAttribute !== undefined) {
            queryParameters['groupMembershipAttribute'] = requestParameters.groupMembershipAttribute;
        }

        if (requestParameters.groupMembershipAttributeTypeHint !== undefined) {
            queryParameters['groupMembershipAttribute@TypeHint'] = requestParameters.groupMembershipAttributeTypeHint;
        }

        if (requestParameters.idpUrl !== undefined) {
            queryParameters['idpUrl'] = requestParameters.idpUrl;
        }

        if (requestParameters.idpUrlTypeHint !== undefined) {
            queryParameters['idpUrl@TypeHint'] = requestParameters.idpUrlTypeHint;
        }

        if (requestParameters.logoutUrl !== undefined) {
            queryParameters['logoutUrl'] = requestParameters.logoutUrl;
        }

        if (requestParameters.logoutUrlTypeHint !== undefined) {
            queryParameters['logoutUrl@TypeHint'] = requestParameters.logoutUrlTypeHint;
        }

        if (requestParameters.serviceProviderEntityId !== undefined) {
            queryParameters['serviceProviderEntityId'] = requestParameters.serviceProviderEntityId;
        }

        if (requestParameters.serviceProviderEntityIdTypeHint !== undefined) {
            queryParameters['serviceProviderEntityId@TypeHint'] = requestParameters.serviceProviderEntityIdTypeHint;
        }

        if (requestParameters.assertionConsumerServiceURL !== undefined) {
            queryParameters['assertionConsumerServiceURL'] = requestParameters.assertionConsumerServiceURL;
        }

        if (requestParameters.assertionConsumerServiceURLTypeHint !== undefined) {
            queryParameters['assertionConsumerServiceURL@TypeHint'] = requestParameters.assertionConsumerServiceURLTypeHint;
        }

        if (requestParameters.handleLogout !== undefined) {
            queryParameters['handleLogout'] = requestParameters.handleLogout;
        }

        if (requestParameters.handleLogoutTypeHint !== undefined) {
            queryParameters['handleLogout@TypeHint'] = requestParameters.handleLogoutTypeHint;
        }

        if (requestParameters.spPrivateKeyAlias !== undefined) {
            queryParameters['spPrivateKeyAlias'] = requestParameters.spPrivateKeyAlias;
        }

        if (requestParameters.spPrivateKeyAliasTypeHint !== undefined) {
            queryParameters['spPrivateKeyAlias@TypeHint'] = requestParameters.spPrivateKeyAliasTypeHint;
        }

        if (requestParameters.useEncryption !== undefined) {
            queryParameters['useEncryption'] = requestParameters.useEncryption;
        }

        if (requestParameters.useEncryptionTypeHint !== undefined) {
            queryParameters['useEncryption@TypeHint'] = requestParameters.useEncryptionTypeHint;
        }

        if (requestParameters.nameIdFormat !== undefined) {
            queryParameters['nameIdFormat'] = requestParameters.nameIdFormat;
        }

        if (requestParameters.nameIdFormatTypeHint !== undefined) {
            queryParameters['nameIdFormat@TypeHint'] = requestParameters.nameIdFormatTypeHint;
        }

        if (requestParameters.digestMethod !== undefined) {
            queryParameters['digestMethod'] = requestParameters.digestMethod;
        }

        if (requestParameters.digestMethodTypeHint !== undefined) {
            queryParameters['digestMethod@TypeHint'] = requestParameters.digestMethodTypeHint;
        }

        if (requestParameters.signatureMethod !== undefined) {
            queryParameters['signatureMethod'] = requestParameters.signatureMethod;
        }

        if (requestParameters.signatureMethodTypeHint !== undefined) {
            queryParameters['signatureMethod@TypeHint'] = requestParameters.signatureMethodTypeHint;
        }

        if (requestParameters.userIntermediatePath !== undefined) {
            queryParameters['userIntermediatePath'] = requestParameters.userIntermediatePath;
        }

        if (requestParameters.userIntermediatePathTypeHint !== undefined) {
            queryParameters['userIntermediatePath@TypeHint'] = requestParameters.userIntermediatePathTypeHint;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigAdobeGraniteSamlAuthenticationHandler(requestParameters: PostConfigAdobeGraniteSamlAuthenticationHandlerRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigAdobeGraniteSamlAuthenticationHandlerRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postConfigApacheFelixJettyBasedHttpServiceRaw(requestParameters: PostConfigApacheFelixJettyBasedHttpServiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.orgApacheFelixHttpsNio !== undefined) {
            queryParameters['org.apache.felix.https.nio'] = requestParameters.orgApacheFelixHttpsNio;
        }

        if (requestParameters.orgApacheFelixHttpsNioTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.nio@TypeHint'] = requestParameters.orgApacheFelixHttpsNioTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsKeystore !== undefined) {
            queryParameters['org.apache.felix.https.keystore'] = requestParameters.orgApacheFelixHttpsKeystore;
        }

        if (requestParameters.orgApacheFelixHttpsKeystoreTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore@TypeHint'] = requestParameters.orgApacheFelixHttpsKeystoreTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsKeystorePassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password'] = requestParameters.orgApacheFelixHttpsKeystorePassword;
        }

        if (requestParameters.orgApacheFelixHttpsKeystorePasswordTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.password@TypeHint'] = requestParameters.orgApacheFelixHttpsKeystorePasswordTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsKeystoreKey !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key'] = requestParameters.orgApacheFelixHttpsKeystoreKey;
        }

        if (requestParameters.orgApacheFelixHttpsKeystoreKeyTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key@TypeHint'] = requestParameters.orgApacheFelixHttpsKeystoreKeyTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsKeystoreKeyPassword !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password'] = requestParameters.orgApacheFelixHttpsKeystoreKeyPassword;
        }

        if (requestParameters.orgApacheFelixHttpsKeystoreKeyPasswordTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.keystore.key.password@TypeHint'] = requestParameters.orgApacheFelixHttpsKeystoreKeyPasswordTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsTruststore !== undefined) {
            queryParameters['org.apache.felix.https.truststore'] = requestParameters.orgApacheFelixHttpsTruststore;
        }

        if (requestParameters.orgApacheFelixHttpsTruststoreTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore@TypeHint'] = requestParameters.orgApacheFelixHttpsTruststoreTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsTruststorePassword !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password'] = requestParameters.orgApacheFelixHttpsTruststorePassword;
        }

        if (requestParameters.orgApacheFelixHttpsTruststorePasswordTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.truststore.password@TypeHint'] = requestParameters.orgApacheFelixHttpsTruststorePasswordTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsClientcertificate !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate'] = requestParameters.orgApacheFelixHttpsClientcertificate;
        }

        if (requestParameters.orgApacheFelixHttpsClientcertificateTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.clientcertificate@TypeHint'] = requestParameters.orgApacheFelixHttpsClientcertificateTypeHint;
        }

        if (requestParameters.orgApacheFelixHttpsEnable !== undefined) {
            queryParameters['org.apache.felix.https.enable'] = requestParameters.orgApacheFelixHttpsEnable;
        }

        if (requestParameters.orgApacheFelixHttpsEnableTypeHint !== undefined) {
            queryParameters['org.apache.felix.https.enable@TypeHint'] = requestParameters.orgApacheFelixHttpsEnableTypeHint;
        }

        if (requestParameters.orgOsgiServiceHttpPortSecure !== undefined) {
            queryParameters['org.osgi.service.http.port.secure'] = requestParameters.orgOsgiServiceHttpPortSecure;
        }

        if (requestParameters.orgOsgiServiceHttpPortSecureTypeHint !== undefined) {
            queryParameters['org.osgi.service.http.port.secure@TypeHint'] = requestParameters.orgOsgiServiceHttpPortSecureTypeHint;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/org.apache.felix.http`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigApacheFelixJettyBasedHttpService(requestParameters: PostConfigApacheFelixJettyBasedHttpServiceRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigApacheFelixJettyBasedHttpServiceRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postConfigApacheHttpComponentsProxyConfigurationRaw(requestParameters: PostConfigApacheHttpComponentsProxyConfigurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.proxyHost !== undefined) {
            queryParameters['proxy.host'] = requestParameters.proxyHost;
        }

        if (requestParameters.proxyHostTypeHint !== undefined) {
            queryParameters['proxy.host@TypeHint'] = requestParameters.proxyHostTypeHint;
        }

        if (requestParameters.proxyPort !== undefined) {
            queryParameters['proxy.port'] = requestParameters.proxyPort;
        }

        if (requestParameters.proxyPortTypeHint !== undefined) {
            queryParameters['proxy.port@TypeHint'] = requestParameters.proxyPortTypeHint;
        }

        if (requestParameters.proxyExceptions) {
            queryParameters['proxy.exceptions'] = requestParameters.proxyExceptions;
        }

        if (requestParameters.proxyExceptionsTypeHint !== undefined) {
            queryParameters['proxy.exceptions@TypeHint'] = requestParameters.proxyExceptionsTypeHint;
        }

        if (requestParameters.proxyEnabled !== undefined) {
            queryParameters['proxy.enabled'] = requestParameters.proxyEnabled;
        }

        if (requestParameters.proxyEnabledTypeHint !== undefined) {
            queryParameters['proxy.enabled@TypeHint'] = requestParameters.proxyEnabledTypeHint;
        }

        if (requestParameters.proxyUser !== undefined) {
            queryParameters['proxy.user'] = requestParameters.proxyUser;
        }

        if (requestParameters.proxyUserTypeHint !== undefined) {
            queryParameters['proxy.user@TypeHint'] = requestParameters.proxyUserTypeHint;
        }

        if (requestParameters.proxyPassword !== undefined) {
            queryParameters['proxy.password'] = requestParameters.proxyPassword;
        }

        if (requestParameters.proxyPasswordTypeHint !== undefined) {
            queryParameters['proxy.password@TypeHint'] = requestParameters.proxyPasswordTypeHint;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/org.apache.http.proxyconfigurator.config`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigApacheHttpComponentsProxyConfiguration(requestParameters: PostConfigApacheHttpComponentsProxyConfigurationRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigApacheHttpComponentsProxyConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postConfigApacheSlingDavExServletRaw(requestParameters: PostConfigApacheSlingDavExServletRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.alias !== undefined) {
            queryParameters['alias'] = requestParameters.alias;
        }

        if (requestParameters.aliasTypeHint !== undefined) {
            queryParameters['alias@TypeHint'] = requestParameters.aliasTypeHint;
        }

        if (requestParameters.davCreateAbsoluteUri !== undefined) {
            queryParameters['dav.create-absolute-uri'] = requestParameters.davCreateAbsoluteUri;
        }

        if (requestParameters.davCreateAbsoluteUriTypeHint !== undefined) {
            queryParameters['dav.create-absolute-uri@TypeHint'] = requestParameters.davCreateAbsoluteUriTypeHint;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigApacheSlingDavExServlet(requestParameters: PostConfigApacheSlingDavExServletRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigApacheSlingDavExServletRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postConfigApacheSlingGetServletRaw(requestParameters: PostConfigApacheSlingGetServletRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.jsonMaximumresults !== undefined) {
            queryParameters['json.maximumresults'] = requestParameters.jsonMaximumresults;
        }

        if (requestParameters.jsonMaximumresultsTypeHint !== undefined) {
            queryParameters['json.maximumresults@TypeHint'] = requestParameters.jsonMaximumresultsTypeHint;
        }

        if (requestParameters.enableHtml !== undefined) {
            queryParameters['enable.html'] = requestParameters.enableHtml;
        }

        if (requestParameters.enableHtmlTypeHint !== undefined) {
            queryParameters['enable.html@TypeHint'] = requestParameters.enableHtmlTypeHint;
        }

        if (requestParameters.enableTxt !== undefined) {
            queryParameters['enable.txt'] = requestParameters.enableTxt;
        }

        if (requestParameters.enableTxtTypeHint !== undefined) {
            queryParameters['enable.txt@TypeHint'] = requestParameters.enableTxtTypeHint;
        }

        if (requestParameters.enableXml !== undefined) {
            queryParameters['enable.xml'] = requestParameters.enableXml;
        }

        if (requestParameters.enableXmlTypeHint !== undefined) {
            queryParameters['enable.xml@TypeHint'] = requestParameters.enableXmlTypeHint;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigApacheSlingGetServlet(requestParameters: PostConfigApacheSlingGetServletRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigApacheSlingGetServletRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postConfigApacheSlingReferrerFilterRaw(requestParameters: PostConfigApacheSlingReferrerFilterRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.allowEmpty !== undefined) {
            queryParameters['allow.empty'] = requestParameters.allowEmpty;
        }

        if (requestParameters.allowEmptyTypeHint !== undefined) {
            queryParameters['allow.empty@TypeHint'] = requestParameters.allowEmptyTypeHint;
        }

        if (requestParameters.allowHosts !== undefined) {
            queryParameters['allow.hosts'] = requestParameters.allowHosts;
        }

        if (requestParameters.allowHostsTypeHint !== undefined) {
            queryParameters['allow.hosts@TypeHint'] = requestParameters.allowHostsTypeHint;
        }

        if (requestParameters.allowHostsRegexp !== undefined) {
            queryParameters['allow.hosts.regexp'] = requestParameters.allowHostsRegexp;
        }

        if (requestParameters.allowHostsRegexpTypeHint !== undefined) {
            queryParameters['allow.hosts.regexp@TypeHint'] = requestParameters.allowHostsRegexpTypeHint;
        }

        if (requestParameters.filterMethods !== undefined) {
            queryParameters['filter.methods'] = requestParameters.filterMethods;
        }

        if (requestParameters.filterMethodsTypeHint !== undefined) {
            queryParameters['filter.methods@TypeHint'] = requestParameters.filterMethodsTypeHint;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigApacheSlingReferrerFilter(requestParameters: PostConfigApacheSlingReferrerFilterRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigApacheSlingReferrerFilterRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postConfigPropertyRaw(requestParameters: PostConfigPropertyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.configNodeName === null || requestParameters.configNodeName === undefined) {
            throw new runtime.RequiredError('configNodeName','Required parameter requestParameters.configNodeName was null or undefined when calling postConfigProperty.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/apps/system/config/{configNodeName}`.replace(`{${"configNodeName"}}`, encodeURIComponent(String(requestParameters.configNodeName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postConfigProperty(requestParameters: PostConfigPropertyRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postConfigPropertyRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postNodeRaw(requestParameters: PostNodeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling postNode.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postNode.');
        }

        const queryParameters: any = {};

        if (requestParameters.operation !== undefined) {
            queryParameters[':operation'] = requestParameters.operation;
        }

        if (requestParameters.deleteAuthorizable !== undefined) {
            queryParameters['deleteAuthorizable'] = requestParameters.deleteAuthorizable;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const response = await this.request({
            path: `/{path}/{name}`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postNode(requestParameters: PostNodeRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postNodeRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postNodeRwRaw(requestParameters: PostNodeRwRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling postNodeRw.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postNodeRw.');
        }

        const queryParameters: any = {};

        if (requestParameters.addMembers !== undefined) {
            queryParameters['addMembers'] = requestParameters.addMembers;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{path}/{name}.rw.html`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postNodeRw(requestParameters: PostNodeRwRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postNodeRwRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postPathRaw(requestParameters: PostPathRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling postPath.');
        }

        if (requestParameters.jcrprimaryType === null || requestParameters.jcrprimaryType === undefined) {
            throw new runtime.RequiredError('jcrprimaryType','Required parameter requestParameters.jcrprimaryType was null or undefined when calling postPath.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.jcrprimaryType !== undefined) {
            queryParameters['jcr:primaryType'] = requestParameters.jcrprimaryType;
        }

        if (requestParameters.name !== undefined) {
            queryParameters[':name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{path}/`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postPath(requestParameters: PostPathRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postPathRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postQueryRaw(requestParameters: PostQueryRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling postQuery.');
        }

        if (requestParameters.pLimit === null || requestParameters.pLimit === undefined) {
            throw new runtime.RequiredError('pLimit','Required parameter requestParameters.pLimit was null or undefined when calling postQuery.');
        }

        if (requestParameters._1property === null || requestParameters._1property === undefined) {
            throw new runtime.RequiredError('_1property','Required parameter requestParameters._1property was null or undefined when calling postQuery.');
        }

        if (requestParameters._1propertyValue === null || requestParameters._1propertyValue === undefined) {
            throw new runtime.RequiredError('_1propertyValue','Required parameter requestParameters._1propertyValue was null or undefined when calling postQuery.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        if (requestParameters.pLimit !== undefined) {
            queryParameters['p.limit'] = requestParameters.pLimit;
        }

        if (requestParameters._1property !== undefined) {
            queryParameters['1_property'] = requestParameters._1property;
        }

        if (requestParameters._1propertyValue !== undefined) {
            queryParameters['1_property.value'] = requestParameters._1propertyValue;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/bin/querybuilder.json`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async postQuery(requestParameters: PostQueryRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.postQueryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async postTreeActivationRaw(requestParameters: PostTreeActivationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.ignoredeactivated === null || requestParameters.ignoredeactivated === undefined) {
            throw new runtime.RequiredError('ignoredeactivated','Required parameter requestParameters.ignoredeactivated was null or undefined when calling postTreeActivation.');
        }

        if (requestParameters.onlymodified === null || requestParameters.onlymodified === undefined) {
            throw new runtime.RequiredError('onlymodified','Required parameter requestParameters.onlymodified was null or undefined when calling postTreeActivation.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling postTreeActivation.');
        }

        const queryParameters: any = {};

        if (requestParameters.ignoredeactivated !== undefined) {
            queryParameters['ignoredeactivated'] = requestParameters.ignoredeactivated;
        }

        if (requestParameters.onlymodified !== undefined) {
            queryParameters['onlymodified'] = requestParameters.onlymodified;
        }

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/etc/replication/treeactivation.html`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async postTreeActivation(requestParameters: PostTreeActivationRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postTreeActivationRaw(requestParameters, initOverrides);
    }

    /**
     */
    async postTruststoreRaw(requestParameters: PostTruststoreRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        if (requestParameters.operation !== undefined) {
            queryParameters[':operation'] = requestParameters.operation;
        }

        if (requestParameters.newPassword !== undefined) {
            queryParameters['newPassword'] = requestParameters.newPassword;
        }

        if (requestParameters.rePassword !== undefined) {
            queryParameters['rePassword'] = requestParameters.rePassword;
        }

        if (requestParameters.keyStoreType !== undefined) {
            queryParameters['keyStoreType'] = requestParameters.keyStoreType;
        }

        if (requestParameters.removeAlias !== undefined) {
            queryParameters['removeAlias'] = requestParameters.removeAlias;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.certificate !== undefined) {
            formParams.append('certificate', requestParameters.certificate as any);
        }

        const response = await this.request({
            path: `/libs/granite/security/post/truststore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async postTruststore(requestParameters: PostTruststoreRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.postTruststoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async postTruststorePKCS12Raw(requestParameters: PostTruststorePKCS12Request, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.truststoreP12 !== undefined) {
            formParams.append('truststore.p12', requestParameters.truststoreP12 as any);
        }

        const response = await this.request({
            path: `/etc/truststore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async postTruststorePKCS12(requestParameters: PostTruststorePKCS12Request, initOverrides?: RequestInit): Promise<string> {
        const response = await this.postTruststorePKCS12Raw(requestParameters, initOverrides);
        return await response.value();
    }

}
