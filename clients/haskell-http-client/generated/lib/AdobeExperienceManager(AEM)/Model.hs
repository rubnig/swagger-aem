{-
   Adobe Experience Manager (AEM) API

   Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API

   OpenAPI Version: 3.0.0
   Adobe Experience Manager (AEM) API API version: 3.5.0-pre.0
   Contact: opensource@shinesolutions.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : AdobeExperienceManager(AEM).Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module AdobeExperienceManager(AEM).Model where

import AdobeExperienceManager(AEM).Core
import AdobeExperienceManager(AEM).MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Action
newtype Action = Action { unAction :: Text } deriving (P.Eq, P.Show)

-- ** AddGroupMemberships
newtype AddGroupMemberships = AddGroupMemberships { unAddGroupMemberships :: Bool } deriving (P.Eq, P.Show)

-- ** AddGroupMembershipsTypeHint
newtype AddGroupMembershipsTypeHint = AddGroupMembershipsTypeHint { unAddGroupMembershipsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AddMembers
newtype AddMembers = AddMembers { unAddMembers :: Text } deriving (P.Eq, P.Show)

-- ** Alias
newtype Alias = Alias { unAlias :: Text } deriving (P.Eq, P.Show)

-- ** AliasTypeHint
newtype AliasTypeHint = AliasTypeHint { unAliasTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AllowEmpty
newtype AllowEmpty = AllowEmpty { unAllowEmpty :: Bool } deriving (P.Eq, P.Show)

-- ** AllowEmptyTypeHint
newtype AllowEmptyTypeHint = AllowEmptyTypeHint { unAllowEmptyTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AllowHosts
newtype AllowHosts = AllowHosts { unAllowHosts :: Text } deriving (P.Eq, P.Show)

-- ** AllowHostsRegexp
newtype AllowHostsRegexp = AllowHostsRegexp { unAllowHostsRegexp :: Text } deriving (P.Eq, P.Show)

-- ** AllowHostsRegexpTypeHint
newtype AllowHostsRegexpTypeHint = AllowHostsRegexpTypeHint { unAllowHostsRegexpTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AllowHostsTypeHint
newtype AllowHostsTypeHint = AllowHostsTypeHint { unAllowHostsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Apply
newtype Apply = Apply { unApply :: Bool } deriving (P.Eq, P.Show)

-- ** AssertionConsumerServiceUrl
newtype AssertionConsumerServiceUrl = AssertionConsumerServiceUrl { unAssertionConsumerServiceUrl :: Text } deriving (P.Eq, P.Show)

-- ** AssertionConsumerServiceUrlTypeHint
newtype AssertionConsumerServiceUrlTypeHint = AssertionConsumerServiceUrlTypeHint { unAssertionConsumerServiceUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** AuthorizableId
newtype AuthorizableId = AuthorizableId { unAuthorizableId :: Text } deriving (P.Eq, P.Show)

-- ** BundlesIgnored
newtype BundlesIgnored = BundlesIgnored { unBundlesIgnored :: [Text] } deriving (P.Eq, P.Show)

-- ** BundlesIgnoredTypeHint
newtype BundlesIgnoredTypeHint = BundlesIgnoredTypeHint { unBundlesIgnoredTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** CertChain
newtype CertChain = CertChain { unCertChain :: FilePath } deriving (P.Eq, P.Show)

-- ** Certificate
newtype Certificate = Certificate { unCertificate :: FilePath } deriving (P.Eq, P.Show)

-- ** CertificateFile
newtype CertificateFile = CertificateFile { unCertificateFile :: FilePath } deriving (P.Eq, P.Show)

-- ** Changelog
newtype Changelog = Changelog { unChangelog :: Text } deriving (P.Eq, P.Show)

-- ** Charset
newtype Charset = Charset { unCharset :: Text } deriving (P.Eq, P.Show)

-- ** ClockTolerance
newtype ClockTolerance = ClockTolerance { unClockTolerance :: Int } deriving (P.Eq, P.Show)

-- ** ClockToleranceTypeHint
newtype ClockToleranceTypeHint = ClockToleranceTypeHint { unClockToleranceTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Cmd
newtype Cmd = Cmd { unCmd :: Text } deriving (P.Eq, P.Show)

-- ** CombineTagsOr
newtype CombineTagsOr = CombineTagsOr { unCombineTagsOr :: Bool } deriving (P.Eq, P.Show)

-- ** ConfigNodeName
newtype ConfigNodeName = ConfigNodeName { unConfigNodeName :: Text } deriving (P.Eq, P.Show)

-- ** CreateGroup
newtype CreateGroup = CreateGroup { unCreateGroup :: Text } deriving (P.Eq, P.Show)

-- ** CreateUser
newtype CreateUser = CreateUser { unCreateUser :: Text } deriving (P.Eq, P.Show)

-- ** CreateUserBool
newtype CreateUserBool = CreateUserBool { unCreateUserBool :: Bool } deriving (P.Eq, P.Show)

-- ** CreateUserTypeHint
newtype CreateUserTypeHint = CreateUserTypeHint { unCreateUserTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** CurrentPassword
newtype CurrentPassword = CurrentPassword { unCurrentPassword :: Text } deriving (P.Eq, P.Show)

-- ** DavCreateAbsoluteUri
newtype DavCreateAbsoluteUri = DavCreateAbsoluteUri { unDavCreateAbsoluteUri :: Bool } deriving (P.Eq, P.Show)

-- ** DavCreateAbsoluteUriTypeHint
newtype DavCreateAbsoluteUriTypeHint = DavCreateAbsoluteUriTypeHint { unDavCreateAbsoluteUriTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** DefaultGroups
newtype DefaultGroups = DefaultGroups { unDefaultGroups :: [Text] } deriving (P.Eq, P.Show)

-- ** DefaultGroupsTypeHint
newtype DefaultGroupsTypeHint = DefaultGroupsTypeHint { unDefaultGroupsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** DefaultRedirectUrl
newtype DefaultRedirectUrl = DefaultRedirectUrl { unDefaultRedirectUrl :: Text } deriving (P.Eq, P.Show)

-- ** DefaultRedirectUrlTypeHint
newtype DefaultRedirectUrlTypeHint = DefaultRedirectUrlTypeHint { unDefaultRedirectUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Delete
newtype Delete = Delete { unDelete :: Bool } deriving (P.Eq, P.Show)

-- ** DeleteAuthorizable
newtype DeleteAuthorizable = DeleteAuthorizable { unDeleteAuthorizable :: Text } deriving (P.Eq, P.Show)

-- ** DigestMethod
newtype DigestMethod = DigestMethod { unDigestMethod :: Text } deriving (P.Eq, P.Show)

-- ** DigestMethodTypeHint
newtype DigestMethodTypeHint = DigestMethodTypeHint { unDigestMethodTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** EnableHtml
newtype EnableHtml = EnableHtml { unEnableHtml :: Bool } deriving (P.Eq, P.Show)

-- ** EnableHtmlTypeHint
newtype EnableHtmlTypeHint = EnableHtmlTypeHint { unEnableHtmlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** EnableTxt
newtype EnableTxt = EnableTxt { unEnableTxt :: Bool } deriving (P.Eq, P.Show)

-- ** EnableTxtTypeHint
newtype EnableTxtTypeHint = EnableTxtTypeHint { unEnableTxtTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** EnableXml
newtype EnableXml = EnableXml { unEnableXml :: Bool } deriving (P.Eq, P.Show)

-- ** EnableXmlTypeHint
newtype EnableXmlTypeHint = EnableXmlTypeHint { unEnableXmlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** FilterMethods
newtype FilterMethods = FilterMethods { unFilterMethods :: Text } deriving (P.Eq, P.Show)

-- ** FilterMethodsTypeHint
newtype FilterMethodsTypeHint = FilterMethodsTypeHint { unFilterMethodsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Force
newtype Force = Force { unForce :: Bool } deriving (P.Eq, P.Show)

-- ** Group
newtype Group = Group { unGroup :: Text } deriving (P.Eq, P.Show)

-- ** GroupMembershipAttribute
newtype GroupMembershipAttribute = GroupMembershipAttribute { unGroupMembershipAttribute :: Text } deriving (P.Eq, P.Show)

-- ** GroupMembershipAttributeTypeHint
newtype GroupMembershipAttributeTypeHint = GroupMembershipAttributeTypeHint { unGroupMembershipAttributeTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** GroupName
newtype GroupName = GroupName { unGroupName :: Text } deriving (P.Eq, P.Show)

-- ** HandleLogout
newtype HandleLogout = HandleLogout { unHandleLogout :: Bool } deriving (P.Eq, P.Show)

-- ** HandleLogoutTypeHint
newtype HandleLogoutTypeHint = HandleLogoutTypeHint { unHandleLogoutTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** HttpsHostname
newtype HttpsHostname = HttpsHostname { unHttpsHostname :: Text } deriving (P.Eq, P.Show)

-- ** HttpsPort
newtype HttpsPort = HttpsPort { unHttpsPort :: Text } deriving (P.Eq, P.Show)

-- ** IdpCertAlias
newtype IdpCertAlias = IdpCertAlias { unIdpCertAlias :: Text } deriving (P.Eq, P.Show)

-- ** IdpCertAliasTypeHint
newtype IdpCertAliasTypeHint = IdpCertAliasTypeHint { unIdpCertAliasTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** IdpHttpRedirect
newtype IdpHttpRedirect = IdpHttpRedirect { unIdpHttpRedirect :: Bool } deriving (P.Eq, P.Show)

-- ** IdpHttpRedirectTypeHint
newtype IdpHttpRedirectTypeHint = IdpHttpRedirectTypeHint { unIdpHttpRedirectTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** IdpUrl
newtype IdpUrl = IdpUrl { unIdpUrl :: Text } deriving (P.Eq, P.Show)

-- ** IdpUrlTypeHint
newtype IdpUrlTypeHint = IdpUrlTypeHint { unIdpUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Ignoredeactivated
newtype Ignoredeactivated = Ignoredeactivated { unIgnoredeactivated :: Bool } deriving (P.Eq, P.Show)

-- ** IntermediatePath
newtype IntermediatePath = IntermediatePath { unIntermediatePath :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentCqdistribute
newtype JcrcontentCqdistribute = JcrcontentCqdistribute { unJcrcontentCqdistribute :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentCqdistributeTypeHint
newtype JcrcontentCqdistributeTypeHint = JcrcontentCqdistributeTypeHint { unJcrcontentCqdistributeTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentCqname
newtype JcrcontentCqname = JcrcontentCqname { unJcrcontentCqname :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentCqtemplate
newtype JcrcontentCqtemplate = JcrcontentCqtemplate { unJcrcontentCqtemplate :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentEnabled
newtype JcrcontentEnabled = JcrcontentEnabled { unJcrcontentEnabled :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentJcrdescription
newtype JcrcontentJcrdescription = JcrcontentJcrdescription { unJcrcontentJcrdescription :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentJcrlastModified
newtype JcrcontentJcrlastModified = JcrcontentJcrlastModified { unJcrcontentJcrlastModified :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentJcrlastModifiedBy
newtype JcrcontentJcrlastModifiedBy = JcrcontentJcrlastModifiedBy { unJcrcontentJcrlastModifiedBy :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentJcrmixinTypes
newtype JcrcontentJcrmixinTypes = JcrcontentJcrmixinTypes { unJcrcontentJcrmixinTypes :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentJcrtitle
newtype JcrcontentJcrtitle = JcrcontentJcrtitle { unJcrcontentJcrtitle :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentLogLevel
newtype JcrcontentLogLevel = JcrcontentLogLevel { unJcrcontentLogLevel :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentNoStatusUpdate
newtype JcrcontentNoStatusUpdate = JcrcontentNoStatusUpdate { unJcrcontentNoStatusUpdate :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentNoVersioning
newtype JcrcontentNoVersioning = JcrcontentNoVersioning { unJcrcontentNoVersioning :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolConnectTimeout
newtype JcrcontentProtocolConnectTimeout = JcrcontentProtocolConnectTimeout { unJcrcontentProtocolConnectTimeout :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolHttpConnectionClosed
newtype JcrcontentProtocolHttpConnectionClosed = JcrcontentProtocolHttpConnectionClosed { unJcrcontentProtocolHttpConnectionClosed :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolHttpExpired
newtype JcrcontentProtocolHttpExpired = JcrcontentProtocolHttpExpired { unJcrcontentProtocolHttpExpired :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolHttpHeaders
newtype JcrcontentProtocolHttpHeaders = JcrcontentProtocolHttpHeaders { unJcrcontentProtocolHttpHeaders :: [Text] } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolHttpHeadersTypeHint
newtype JcrcontentProtocolHttpHeadersTypeHint = JcrcontentProtocolHttpHeadersTypeHint { unJcrcontentProtocolHttpHeadersTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolHttpMethod
newtype JcrcontentProtocolHttpMethod = JcrcontentProtocolHttpMethod { unJcrcontentProtocolHttpMethod :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolHttpsRelaxed
newtype JcrcontentProtocolHttpsRelaxed = JcrcontentProtocolHttpsRelaxed { unJcrcontentProtocolHttpsRelaxed :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolInterface
newtype JcrcontentProtocolInterface = JcrcontentProtocolInterface { unJcrcontentProtocolInterface :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolSocketTimeout
newtype JcrcontentProtocolSocketTimeout = JcrcontentProtocolSocketTimeout { unJcrcontentProtocolSocketTimeout :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentProtocolVersion
newtype JcrcontentProtocolVersion = JcrcontentProtocolVersion { unJcrcontentProtocolVersion :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProxyHost
newtype JcrcontentProxyHost = JcrcontentProxyHost { unJcrcontentProxyHost :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProxyNtlmDomain
newtype JcrcontentProxyNtlmDomain = JcrcontentProxyNtlmDomain { unJcrcontentProxyNtlmDomain :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProxyNtlmHost
newtype JcrcontentProxyNtlmHost = JcrcontentProxyNtlmHost { unJcrcontentProxyNtlmHost :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProxyPassword
newtype JcrcontentProxyPassword = JcrcontentProxyPassword { unJcrcontentProxyPassword :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentProxyPort
newtype JcrcontentProxyPort = JcrcontentProxyPort { unJcrcontentProxyPort :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentProxyUser
newtype JcrcontentProxyUser = JcrcontentProxyUser { unJcrcontentProxyUser :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentQueueBatchMaxSize
newtype JcrcontentQueueBatchMaxSize = JcrcontentQueueBatchMaxSize { unJcrcontentQueueBatchMaxSize :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentQueueBatchMode
newtype JcrcontentQueueBatchMode = JcrcontentQueueBatchMode { unJcrcontentQueueBatchMode :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentQueueBatchWaitTime
newtype JcrcontentQueueBatchWaitTime = JcrcontentQueueBatchWaitTime { unJcrcontentQueueBatchWaitTime :: Double } deriving (P.Eq, P.Show)

-- ** JcrcontentRetryDelay
newtype JcrcontentRetryDelay = JcrcontentRetryDelay { unJcrcontentRetryDelay :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentReverseReplication
newtype JcrcontentReverseReplication = JcrcontentReverseReplication { unJcrcontentReverseReplication :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentSerializationType
newtype JcrcontentSerializationType = JcrcontentSerializationType { unJcrcontentSerializationType :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentSlingresourceType
newtype JcrcontentSlingresourceType = JcrcontentSlingresourceType { unJcrcontentSlingresourceType :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentSsl
newtype JcrcontentSsl = JcrcontentSsl { unJcrcontentSsl :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentTransportNtlmDomain
newtype JcrcontentTransportNtlmDomain = JcrcontentTransportNtlmDomain { unJcrcontentTransportNtlmDomain :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentTransportNtlmHost
newtype JcrcontentTransportNtlmHost = JcrcontentTransportNtlmHost { unJcrcontentTransportNtlmHost :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentTransportPassword
newtype JcrcontentTransportPassword = JcrcontentTransportPassword { unJcrcontentTransportPassword :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentTransportUri
newtype JcrcontentTransportUri = JcrcontentTransportUri { unJcrcontentTransportUri :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentTransportUser
newtype JcrcontentTransportUser = JcrcontentTransportUser { unJcrcontentTransportUser :: Text } deriving (P.Eq, P.Show)

-- ** JcrcontentTriggerDistribute
newtype JcrcontentTriggerDistribute = JcrcontentTriggerDistribute { unJcrcontentTriggerDistribute :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentTriggerModified
newtype JcrcontentTriggerModified = JcrcontentTriggerModified { unJcrcontentTriggerModified :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentTriggerOnOffTime
newtype JcrcontentTriggerOnOffTime = JcrcontentTriggerOnOffTime { unJcrcontentTriggerOnOffTime :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentTriggerReceive
newtype JcrcontentTriggerReceive = JcrcontentTriggerReceive { unJcrcontentTriggerReceive :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentTriggerSpecific
newtype JcrcontentTriggerSpecific = JcrcontentTriggerSpecific { unJcrcontentTriggerSpecific :: Bool } deriving (P.Eq, P.Show)

-- ** JcrcontentUserId
newtype JcrcontentUserId = JcrcontentUserId { unJcrcontentUserId :: Text } deriving (P.Eq, P.Show)

-- ** JcrprimaryType
newtype JcrprimaryType = JcrprimaryType { unJcrprimaryType :: Text } deriving (P.Eq, P.Show)

-- ** JsonMaximumresults
newtype JsonMaximumresults = JsonMaximumresults { unJsonMaximumresults :: Text } deriving (P.Eq, P.Show)

-- ** JsonMaximumresultsTypeHint
newtype JsonMaximumresultsTypeHint = JsonMaximumresultsTypeHint { unJsonMaximumresultsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** KeyPassword
newtype KeyPassword = KeyPassword { unKeyPassword :: Text } deriving (P.Eq, P.Show)

-- ** KeyStore
newtype KeyStore = KeyStore { unKeyStore :: FilePath } deriving (P.Eq, P.Show)

-- ** KeyStorePass
newtype KeyStorePass = KeyStorePass { unKeyStorePass :: Text } deriving (P.Eq, P.Show)

-- ** KeyStorePassword
newtype KeyStorePassword = KeyStorePassword { unKeyStorePassword :: Text } deriving (P.Eq, P.Show)

-- ** KeyStorePasswordTypeHint
newtype KeyStorePasswordTypeHint = KeyStorePasswordTypeHint { unKeyStorePasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** KeyStoreType
newtype KeyStoreType = KeyStoreType { unKeyStoreType :: Text } deriving (P.Eq, P.Show)

-- ** KeystorePassword
newtype KeystorePassword = KeystorePassword { unKeystorePassword :: Text } deriving (P.Eq, P.Show)

-- ** KeystorePasswordConfirm
newtype KeystorePasswordConfirm = KeystorePasswordConfirm { unKeystorePasswordConfirm :: Text } deriving (P.Eq, P.Show)

-- ** Location
newtype Location = Location { unLocation :: Text } deriving (P.Eq, P.Show)

-- ** LogoutUrl
newtype LogoutUrl = LogoutUrl { unLogoutUrl :: Text } deriving (P.Eq, P.Show)

-- ** LogoutUrlTypeHint
newtype LogoutUrlTypeHint = LogoutUrlTypeHint { unLogoutUrlTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** NameIdFormat
newtype NameIdFormat = NameIdFormat { unNameIdFormat :: Text } deriving (P.Eq, P.Show)

-- ** NameIdFormatTypeHint
newtype NameIdFormatTypeHint = NameIdFormatTypeHint { unNameIdFormatTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** NewAlias
newtype NewAlias = NewAlias { unNewAlias :: Text } deriving (P.Eq, P.Show)

-- ** NewPassword
newtype NewPassword = NewPassword { unNewPassword :: Text } deriving (P.Eq, P.Show)

-- ** Old
newtype Old = Old { unOld :: Text } deriving (P.Eq, P.Show)

-- ** Onlymodified
newtype Onlymodified = Onlymodified { unOnlymodified :: Bool } deriving (P.Eq, P.Show)

-- ** Operation
newtype Operation = Operation { unOperation :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsClientcertificate
newtype OrgApacheFelixHttpsClientcertificate = OrgApacheFelixHttpsClientcertificate { unOrgApacheFelixHttpsClientcertificate :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsClientcertificateTypeHint
newtype OrgApacheFelixHttpsClientcertificateTypeHint = OrgApacheFelixHttpsClientcertificateTypeHint { unOrgApacheFelixHttpsClientcertificateTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsEnable
newtype OrgApacheFelixHttpsEnable = OrgApacheFelixHttpsEnable { unOrgApacheFelixHttpsEnable :: Bool } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsEnableTypeHint
newtype OrgApacheFelixHttpsEnableTypeHint = OrgApacheFelixHttpsEnableTypeHint { unOrgApacheFelixHttpsEnableTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystore
newtype OrgApacheFelixHttpsKeystore = OrgApacheFelixHttpsKeystore { unOrgApacheFelixHttpsKeystore :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKey
newtype OrgApacheFelixHttpsKeystoreKey = OrgApacheFelixHttpsKeystoreKey { unOrgApacheFelixHttpsKeystoreKey :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKeyPassword
newtype OrgApacheFelixHttpsKeystoreKeyPassword = OrgApacheFelixHttpsKeystoreKeyPassword { unOrgApacheFelixHttpsKeystoreKeyPassword :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint
newtype OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint = OrgApacheFelixHttpsKeystoreKeyPasswordTypeHint { unOrgApacheFelixHttpsKeystoreKeyPasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreKeyTypeHint
newtype OrgApacheFelixHttpsKeystoreKeyTypeHint = OrgApacheFelixHttpsKeystoreKeyTypeHint { unOrgApacheFelixHttpsKeystoreKeyTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystorePassword
newtype OrgApacheFelixHttpsKeystorePassword = OrgApacheFelixHttpsKeystorePassword { unOrgApacheFelixHttpsKeystorePassword :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystorePasswordTypeHint
newtype OrgApacheFelixHttpsKeystorePasswordTypeHint = OrgApacheFelixHttpsKeystorePasswordTypeHint { unOrgApacheFelixHttpsKeystorePasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsKeystoreTypeHint
newtype OrgApacheFelixHttpsKeystoreTypeHint = OrgApacheFelixHttpsKeystoreTypeHint { unOrgApacheFelixHttpsKeystoreTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsNio
newtype OrgApacheFelixHttpsNio = OrgApacheFelixHttpsNio { unOrgApacheFelixHttpsNio :: Bool } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsNioTypeHint
newtype OrgApacheFelixHttpsNioTypeHint = OrgApacheFelixHttpsNioTypeHint { unOrgApacheFelixHttpsNioTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststore
newtype OrgApacheFelixHttpsTruststore = OrgApacheFelixHttpsTruststore { unOrgApacheFelixHttpsTruststore :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststorePassword
newtype OrgApacheFelixHttpsTruststorePassword = OrgApacheFelixHttpsTruststorePassword { unOrgApacheFelixHttpsTruststorePassword :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststorePasswordTypeHint
newtype OrgApacheFelixHttpsTruststorePasswordTypeHint = OrgApacheFelixHttpsTruststorePasswordTypeHint { unOrgApacheFelixHttpsTruststorePasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgApacheFelixHttpsTruststoreTypeHint
newtype OrgApacheFelixHttpsTruststoreTypeHint = OrgApacheFelixHttpsTruststoreTypeHint { unOrgApacheFelixHttpsTruststoreTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** OrgOsgiServiceHttpPortSecure
newtype OrgOsgiServiceHttpPortSecure = OrgOsgiServiceHttpPortSecure { unOrgOsgiServiceHttpPortSecure :: Text } deriving (P.Eq, P.Show)

-- ** OrgOsgiServiceHttpPortSecureTypeHint
newtype OrgOsgiServiceHttpPortSecureTypeHint = OrgOsgiServiceHttpPortSecureTypeHint { unOrgOsgiServiceHttpPortSecureTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** PLimit
newtype PLimit = PLimit { unPLimit :: Double } deriving (P.Eq, P.Show)

-- ** Package
newtype Package = Package { unPackage :: FilePath } deriving (P.Eq, P.Show)

-- ** PackageName
newtype PackageName = PackageName { unPackageName :: Text } deriving (P.Eq, P.Show)

-- ** PackageVersion
newtype PackageVersion = PackageVersion { unPackageVersion :: Text } deriving (P.Eq, P.Show)

-- ** Param1property
newtype Param1property = Param1property { unParam1property :: Text } deriving (P.Eq, P.Show)

-- ** Param1propertyValue
newtype Param1propertyValue = Param1propertyValue { unParam1propertyValue :: Text } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** PathText
newtype PathText = PathText { unPathText :: [Text] } deriving (P.Eq, P.Show)

-- ** PathTypeHint
newtype PathTypeHint = PathTypeHint { unPathTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Pk
newtype Pk = Pk { unPk :: FilePath } deriving (P.Eq, P.Show)

-- ** Plain
newtype Plain = Plain { unPlain :: Text } deriving (P.Eq, P.Show)

-- ** Post
newtype Post = Post { unPost :: Bool } deriving (P.Eq, P.Show)

-- ** PrivatekeyFile
newtype PrivatekeyFile = PrivatekeyFile { unPrivatekeyFile :: FilePath } deriving (P.Eq, P.Show)

-- ** ProfileGivenName
newtype ProfileGivenName = ProfileGivenName { unProfileGivenName :: Text } deriving (P.Eq, P.Show)

-- ** Propertylist
newtype Propertylist = Propertylist { unPropertylist :: [Text] } deriving (P.Eq, P.Show)

-- ** ProxyEnabled
newtype ProxyEnabled = ProxyEnabled { unProxyEnabled :: Bool } deriving (P.Eq, P.Show)

-- ** ProxyEnabledTypeHint
newtype ProxyEnabledTypeHint = ProxyEnabledTypeHint { unProxyEnabledTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyExceptions
newtype ProxyExceptions = ProxyExceptions { unProxyExceptions :: [Text] } deriving (P.Eq, P.Show)

-- ** ProxyExceptionsTypeHint
newtype ProxyExceptionsTypeHint = ProxyExceptionsTypeHint { unProxyExceptionsTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyHost
newtype ProxyHost = ProxyHost { unProxyHost :: Text } deriving (P.Eq, P.Show)

-- ** ProxyHostTypeHint
newtype ProxyHostTypeHint = ProxyHostTypeHint { unProxyHostTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyPassword
newtype ProxyPassword = ProxyPassword { unProxyPassword :: Text } deriving (P.Eq, P.Show)

-- ** ProxyPasswordTypeHint
newtype ProxyPasswordTypeHint = ProxyPasswordTypeHint { unProxyPasswordTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyPort
newtype ProxyPort = ProxyPort { unProxyPort :: Int } deriving (P.Eq, P.Show)

-- ** ProxyPortTypeHint
newtype ProxyPortTypeHint = ProxyPortTypeHint { unProxyPortTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ProxyUser
newtype ProxyUser = ProxyUser { unProxyUser :: Text } deriving (P.Eq, P.Show)

-- ** ProxyUserTypeHint
newtype ProxyUserTypeHint = ProxyUserTypeHint { unProxyUserTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** PwdresetAuthorizables
newtype PwdresetAuthorizables = PwdresetAuthorizables { unPwdresetAuthorizables :: [Text] } deriving (P.Eq, P.Show)

-- ** PwdresetAuthorizablesTypeHint
newtype PwdresetAuthorizablesTypeHint = PwdresetAuthorizablesTypeHint { unPwdresetAuthorizablesTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** RePassword
newtype RePassword = RePassword { unRePassword :: Text } deriving (P.Eq, P.Show)

-- ** Recursive
newtype Recursive = Recursive { unRecursive :: Bool } deriving (P.Eq, P.Show)

-- ** RemoveAlias
newtype RemoveAlias = RemoveAlias { unRemoveAlias :: Text } deriving (P.Eq, P.Show)

-- ** Reppassword
newtype Reppassword = Reppassword { unReppassword :: Text } deriving (P.Eq, P.Show)

-- ** Runmode
newtype Runmode = Runmode { unRunmode :: Text } deriving (P.Eq, P.Show)

-- ** ServiceProviderEntityId
newtype ServiceProviderEntityId = ServiceProviderEntityId { unServiceProviderEntityId :: Text } deriving (P.Eq, P.Show)

-- ** ServiceProviderEntityIdTypeHint
newtype ServiceProviderEntityIdTypeHint = ServiceProviderEntityIdTypeHint { unServiceProviderEntityIdTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** ServiceRanking
newtype ServiceRanking = ServiceRanking { unServiceRanking :: Int } deriving (P.Eq, P.Show)

-- ** ServiceRankingTypeHint
newtype ServiceRankingTypeHint = ServiceRankingTypeHint { unServiceRankingTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** SignatureMethod
newtype SignatureMethod = SignatureMethod { unSignatureMethod :: Text } deriving (P.Eq, P.Show)

-- ** SignatureMethodTypeHint
newtype SignatureMethodTypeHint = SignatureMethodTypeHint { unSignatureMethodTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** SpPrivateKeyAlias
newtype SpPrivateKeyAlias = SpPrivateKeyAlias { unSpPrivateKeyAlias :: Text } deriving (P.Eq, P.Show)

-- ** SpPrivateKeyAliasTypeHint
newtype SpPrivateKeyAliasTypeHint = SpPrivateKeyAliasTypeHint { unSpPrivateKeyAliasTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** SynchronizeAttributes
newtype SynchronizeAttributes = SynchronizeAttributes { unSynchronizeAttributes :: [Text] } deriving (P.Eq, P.Show)

-- ** SynchronizeAttributesTypeHint
newtype SynchronizeAttributesTypeHint = SynchronizeAttributesTypeHint { unSynchronizeAttributesTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** TruststoreP12
newtype TruststoreP12 = TruststoreP12 { unTruststoreP12 :: FilePath } deriving (P.Eq, P.Show)

-- ** TruststorePassword
newtype TruststorePassword = TruststorePassword { unTruststorePassword :: Text } deriving (P.Eq, P.Show)

-- ** TruststorePasswordConfirm
newtype TruststorePasswordConfirm = TruststorePasswordConfirm { unTruststorePasswordConfirm :: Text } deriving (P.Eq, P.Show)

-- ** UseEncryption
newtype UseEncryption = UseEncryption { unUseEncryption :: Bool } deriving (P.Eq, P.Show)

-- ** UseEncryptionTypeHint
newtype UseEncryptionTypeHint = UseEncryptionTypeHint { unUseEncryptionTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** UserIdAttribute
newtype UserIdAttribute = UserIdAttribute { unUserIdAttribute :: Text } deriving (P.Eq, P.Show)

-- ** UserIdAttributeTypeHint
newtype UserIdAttributeTypeHint = UserIdAttributeTypeHint { unUserIdAttributeTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** UserIntermediatePath
newtype UserIntermediatePath = UserIntermediatePath { unUserIntermediatePath :: Text } deriving (P.Eq, P.Show)

-- ** UserIntermediatePathTypeHint
newtype UserIntermediatePathTypeHint = UserIntermediatePathTypeHint { unUserIntermediatePathTypeHint :: Text } deriving (P.Eq, P.Show)

-- ** Verify
newtype Verify = Verify { unVerify :: Text } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** BundleData
-- | BundleData
data BundleData = BundleData
  { bundleDataId :: !(Maybe Int) -- ^ "id" - Bundle ID
  , bundleDataName :: !(Maybe Text) -- ^ "name" - Bundle name
  , bundleDataFragment :: !(Maybe Bool) -- ^ "fragment" - Is bundle a fragment
  , bundleDataStateRaw :: !(Maybe Int) -- ^ "stateRaw" - Numeric raw bundle state value
  , bundleDataState :: !(Maybe Text) -- ^ "state" - Bundle state value
  , bundleDataVersion :: !(Maybe Text) -- ^ "version" - Bundle version
  , bundleDataSymbolicName :: !(Maybe Text) -- ^ "symbolicName" - Bundle symbolic name
  , bundleDataCategory :: !(Maybe Text) -- ^ "category" - Bundle category
  , bundleDataProps :: !(Maybe [BundleDataProp]) -- ^ "props"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BundleData
instance A.FromJSON BundleData where
  parseJSON = A.withObject "BundleData" $ \o ->
    BundleData
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "fragment")
      <*> (o .:? "stateRaw")
      <*> (o .:? "state")
      <*> (o .:? "version")
      <*> (o .:? "symbolicName")
      <*> (o .:? "category")
      <*> (o .:? "props")

-- | ToJSON BundleData
instance A.ToJSON BundleData where
  toJSON BundleData {..} =
   _omitNulls
      [ "id" .= bundleDataId
      , "name" .= bundleDataName
      , "fragment" .= bundleDataFragment
      , "stateRaw" .= bundleDataStateRaw
      , "state" .= bundleDataState
      , "version" .= bundleDataVersion
      , "symbolicName" .= bundleDataSymbolicName
      , "category" .= bundleDataCategory
      , "props" .= bundleDataProps
      ]


-- | Construct a value of type 'BundleData' (by applying it's required fields, if any)
mkBundleData
  :: BundleData
mkBundleData =
  BundleData
  { bundleDataId = Nothing
  , bundleDataName = Nothing
  , bundleDataFragment = Nothing
  , bundleDataStateRaw = Nothing
  , bundleDataState = Nothing
  , bundleDataVersion = Nothing
  , bundleDataSymbolicName = Nothing
  , bundleDataCategory = Nothing
  , bundleDataProps = Nothing
  }

-- ** BundleDataProp
-- | BundleDataProp
data BundleDataProp = BundleDataProp
  { bundleDataPropKey :: !(Maybe Text) -- ^ "key" - Bundle data key
  , bundleDataPropValue :: !(Maybe Text) -- ^ "value" - Bundle data value
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BundleDataProp
instance A.FromJSON BundleDataProp where
  parseJSON = A.withObject "BundleDataProp" $ \o ->
    BundleDataProp
      <$> (o .:? "key")
      <*> (o .:? "value")

-- | ToJSON BundleDataProp
instance A.ToJSON BundleDataProp where
  toJSON BundleDataProp {..} =
   _omitNulls
      [ "key" .= bundleDataPropKey
      , "value" .= bundleDataPropValue
      ]


-- | Construct a value of type 'BundleDataProp' (by applying it's required fields, if any)
mkBundleDataProp
  :: BundleDataProp
mkBundleDataProp =
  BundleDataProp
  { bundleDataPropKey = Nothing
  , bundleDataPropValue = Nothing
  }

-- ** BundleInfo
-- | BundleInfo
data BundleInfo = BundleInfo
  { bundleInfoStatus :: !(Maybe Text) -- ^ "status" - Status description of all bundles
  , bundleInfoS :: !(Maybe [Int]) -- ^ "s"
  , bundleInfoData :: !(Maybe [BundleData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BundleInfo
instance A.FromJSON BundleInfo where
  parseJSON = A.withObject "BundleInfo" $ \o ->
    BundleInfo
      <$> (o .:? "status")
      <*> (o .:? "s")
      <*> (o .:? "data")

-- | ToJSON BundleInfo
instance A.ToJSON BundleInfo where
  toJSON BundleInfo {..} =
   _omitNulls
      [ "status" .= bundleInfoStatus
      , "s" .= bundleInfoS
      , "data" .= bundleInfoData
      ]


-- | Construct a value of type 'BundleInfo' (by applying it's required fields, if any)
mkBundleInfo
  :: BundleInfo
mkBundleInfo =
  BundleInfo
  { bundleInfoStatus = Nothing
  , bundleInfoS = Nothing
  , bundleInfoData = Nothing
  }

-- ** InstallStatus
-- | InstallStatus
data InstallStatus = InstallStatus
  { installStatusStatus :: !(Maybe InstallStatusStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallStatus
instance A.FromJSON InstallStatus where
  parseJSON = A.withObject "InstallStatus" $ \o ->
    InstallStatus
      <$> (o .:? "status")

-- | ToJSON InstallStatus
instance A.ToJSON InstallStatus where
  toJSON InstallStatus {..} =
   _omitNulls
      [ "status" .= installStatusStatus
      ]


-- | Construct a value of type 'InstallStatus' (by applying it's required fields, if any)
mkInstallStatus
  :: InstallStatus
mkInstallStatus =
  InstallStatus
  { installStatusStatus = Nothing
  }

-- ** InstallStatusStatus
-- | InstallStatusStatus
data InstallStatusStatus = InstallStatusStatus
  { installStatusStatusFinished :: !(Maybe Bool) -- ^ "finished"
  , installStatusStatusItemCount :: !(Maybe Int) -- ^ "itemCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallStatusStatus
instance A.FromJSON InstallStatusStatus where
  parseJSON = A.withObject "InstallStatusStatus" $ \o ->
    InstallStatusStatus
      <$> (o .:? "finished")
      <*> (o .:? "itemCount")

-- | ToJSON InstallStatusStatus
instance A.ToJSON InstallStatusStatus where
  toJSON InstallStatusStatus {..} =
   _omitNulls
      [ "finished" .= installStatusStatusFinished
      , "itemCount" .= installStatusStatusItemCount
      ]


-- | Construct a value of type 'InstallStatusStatus' (by applying it's required fields, if any)
mkInstallStatusStatus
  :: InstallStatusStatus
mkInstallStatusStatus =
  InstallStatusStatus
  { installStatusStatusFinished = Nothing
  , installStatusStatusItemCount = Nothing
  }

-- ** KeystoreChainItems
-- | KeystoreChainItems
data KeystoreChainItems = KeystoreChainItems
  { keystoreChainItemsSubject :: !(Maybe Text) -- ^ "subject" - e.g. \&quot;CN&#x3D;localhost\&quot;
  , keystoreChainItemsIssuer :: !(Maybe Text) -- ^ "issuer" - e.g. \&quot;CN&#x3D;Admin\&quot;
  , keystoreChainItemsNotBefore :: !(Maybe Text) -- ^ "notBefore" - e.g. \&quot;Sun Jul 01 12:00:00 AEST 2018\&quot;
  , keystoreChainItemsNotAfter :: !(Maybe Text) -- ^ "notAfter" - e.g. \&quot;Sun Jun 30 23:59:50 AEST 2019\&quot;
  , keystoreChainItemsSerialNumber :: !(Maybe Int) -- ^ "serialNumber" - 18165099476682912368
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeystoreChainItems
instance A.FromJSON KeystoreChainItems where
  parseJSON = A.withObject "KeystoreChainItems" $ \o ->
    KeystoreChainItems
      <$> (o .:? "subject")
      <*> (o .:? "issuer")
      <*> (o .:? "notBefore")
      <*> (o .:? "notAfter")
      <*> (o .:? "serialNumber")

-- | ToJSON KeystoreChainItems
instance A.ToJSON KeystoreChainItems where
  toJSON KeystoreChainItems {..} =
   _omitNulls
      [ "subject" .= keystoreChainItemsSubject
      , "issuer" .= keystoreChainItemsIssuer
      , "notBefore" .= keystoreChainItemsNotBefore
      , "notAfter" .= keystoreChainItemsNotAfter
      , "serialNumber" .= keystoreChainItemsSerialNumber
      ]


-- | Construct a value of type 'KeystoreChainItems' (by applying it's required fields, if any)
mkKeystoreChainItems
  :: KeystoreChainItems
mkKeystoreChainItems =
  KeystoreChainItems
  { keystoreChainItemsSubject = Nothing
  , keystoreChainItemsIssuer = Nothing
  , keystoreChainItemsNotBefore = Nothing
  , keystoreChainItemsNotAfter = Nothing
  , keystoreChainItemsSerialNumber = Nothing
  }

-- ** KeystoreInfo
-- | KeystoreInfo
data KeystoreInfo = KeystoreInfo
  { keystoreInfoAliases :: !(Maybe [KeystoreItems]) -- ^ "aliases"
  , keystoreInfoExists :: !(Maybe Bool) -- ^ "exists" - False if truststore don&#39;t exist
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeystoreInfo
instance A.FromJSON KeystoreInfo where
  parseJSON = A.withObject "KeystoreInfo" $ \o ->
    KeystoreInfo
      <$> (o .:? "aliases")
      <*> (o .:? "exists")

-- | ToJSON KeystoreInfo
instance A.ToJSON KeystoreInfo where
  toJSON KeystoreInfo {..} =
   _omitNulls
      [ "aliases" .= keystoreInfoAliases
      , "exists" .= keystoreInfoExists
      ]


-- | Construct a value of type 'KeystoreInfo' (by applying it's required fields, if any)
mkKeystoreInfo
  :: KeystoreInfo
mkKeystoreInfo =
  KeystoreInfo
  { keystoreInfoAliases = Nothing
  , keystoreInfoExists = Nothing
  }

-- ** KeystoreItems
-- | KeystoreItems
data KeystoreItems = KeystoreItems
  { keystoreItemsAlias :: !(Maybe Text) -- ^ "alias" - Keystore alias name
  , keystoreItemsEntryType :: !(Maybe Text) -- ^ "entryType" - e.g. \&quot;privateKey\&quot;
  , keystoreItemsAlgorithm :: !(Maybe Text) -- ^ "algorithm" - e.g. \&quot;RSA\&quot;
  , keystoreItemsFormat :: !(Maybe Text) -- ^ "format" - e.g. \&quot;PKCS#8\&quot;
  , keystoreItemsChain :: !(Maybe [KeystoreChainItems]) -- ^ "chain"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeystoreItems
instance A.FromJSON KeystoreItems where
  parseJSON = A.withObject "KeystoreItems" $ \o ->
    KeystoreItems
      <$> (o .:? "alias")
      <*> (o .:? "entryType")
      <*> (o .:? "algorithm")
      <*> (o .:? "format")
      <*> (o .:? "chain")

-- | ToJSON KeystoreItems
instance A.ToJSON KeystoreItems where
  toJSON KeystoreItems {..} =
   _omitNulls
      [ "alias" .= keystoreItemsAlias
      , "entryType" .= keystoreItemsEntryType
      , "algorithm" .= keystoreItemsAlgorithm
      , "format" .= keystoreItemsFormat
      , "chain" .= keystoreItemsChain
      ]


-- | Construct a value of type 'KeystoreItems' (by applying it's required fields, if any)
mkKeystoreItems
  :: KeystoreItems
mkKeystoreItems =
  KeystoreItems
  { keystoreItemsAlias = Nothing
  , keystoreItemsEntryType = Nothing
  , keystoreItemsAlgorithm = Nothing
  , keystoreItemsFormat = Nothing
  , keystoreItemsChain = Nothing
  }

-- ** SamlConfigurationInfo
-- | SamlConfigurationInfo
data SamlConfigurationInfo = SamlConfigurationInfo
  { samlConfigurationInfoPid :: !(Maybe Text) -- ^ "pid" - Persistent Identity (PID)
  , samlConfigurationInfoTitle :: !(Maybe Text) -- ^ "title" - Title
  , samlConfigurationInfoDescription :: !(Maybe Text) -- ^ "description" - Title
  , samlConfigurationInfoBundleLocation :: !(Maybe Text) -- ^ "bundle_location" - needed for configuration binding
  , samlConfigurationInfoServiceLocation :: !(Maybe Text) -- ^ "service_location" - needed for configuraiton binding
  , samlConfigurationInfoProperties :: !(Maybe SamlConfigurationProperties) -- ^ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationInfo
instance A.FromJSON SamlConfigurationInfo where
  parseJSON = A.withObject "SamlConfigurationInfo" $ \o ->
    SamlConfigurationInfo
      <$> (o .:? "pid")
      <*> (o .:? "title")
      <*> (o .:? "description")
      <*> (o .:? "bundle_location")
      <*> (o .:? "service_location")
      <*> (o .:? "properties")

-- | ToJSON SamlConfigurationInfo
instance A.ToJSON SamlConfigurationInfo where
  toJSON SamlConfigurationInfo {..} =
   _omitNulls
      [ "pid" .= samlConfigurationInfoPid
      , "title" .= samlConfigurationInfoTitle
      , "description" .= samlConfigurationInfoDescription
      , "bundle_location" .= samlConfigurationInfoBundleLocation
      , "service_location" .= samlConfigurationInfoServiceLocation
      , "properties" .= samlConfigurationInfoProperties
      ]


-- | Construct a value of type 'SamlConfigurationInfo' (by applying it's required fields, if any)
mkSamlConfigurationInfo
  :: SamlConfigurationInfo
mkSamlConfigurationInfo =
  SamlConfigurationInfo
  { samlConfigurationInfoPid = Nothing
  , samlConfigurationInfoTitle = Nothing
  , samlConfigurationInfoDescription = Nothing
  , samlConfigurationInfoBundleLocation = Nothing
  , samlConfigurationInfoServiceLocation = Nothing
  , samlConfigurationInfoProperties = Nothing
  }

-- ** SamlConfigurationProperties
-- | SamlConfigurationProperties
data SamlConfigurationProperties = SamlConfigurationProperties
  { samlConfigurationPropertiesPath :: !(Maybe SamlConfigurationPropertyItemsArray) -- ^ "path"
  , samlConfigurationPropertiesServiceRanking :: !(Maybe SamlConfigurationPropertyItemsLong) -- ^ "service.ranking"
  , samlConfigurationPropertiesIdpUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "idpUrl"
  , samlConfigurationPropertiesIdpCertAlias :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "idpCertAlias"
  , samlConfigurationPropertiesIdpHttpRedirect :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "idpHttpRedirect"
  , samlConfigurationPropertiesServiceProviderEntityId :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "serviceProviderEntityId"
  , samlConfigurationPropertiesAssertionConsumerServiceUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "assertionConsumerServiceURL"
  , samlConfigurationPropertiesSpPrivateKeyAlias :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "spPrivateKeyAlias"
  , samlConfigurationPropertiesKeyStorePassword :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "keyStorePassword"
  , samlConfigurationPropertiesDefaultRedirectUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "defaultRedirectUrl"
  , samlConfigurationPropertiesUserIdAttribute :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "userIDAttribute"
  , samlConfigurationPropertiesUseEncryption :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "useEncryption"
  , samlConfigurationPropertiesCreateUser :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "createUser"
  , samlConfigurationPropertiesAddGroupMemberships :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "addGroupMemberships"
  , samlConfigurationPropertiesGroupMembershipAttribute :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "groupMembershipAttribute"
  , samlConfigurationPropertiesDefaultGroups :: !(Maybe SamlConfigurationPropertyItemsArray) -- ^ "defaultGroups"
  , samlConfigurationPropertiesNameIdFormat :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "nameIdFormat"
  , samlConfigurationPropertiesSynchronizeAttributes :: !(Maybe SamlConfigurationPropertyItemsArray) -- ^ "synchronizeAttributes"
  , samlConfigurationPropertiesHandleLogout :: !(Maybe SamlConfigurationPropertyItemsBoolean) -- ^ "handleLogout"
  , samlConfigurationPropertiesLogoutUrl :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "logoutUrl"
  , samlConfigurationPropertiesClockTolerance :: !(Maybe SamlConfigurationPropertyItemsLong) -- ^ "clockTolerance"
  , samlConfigurationPropertiesDigestMethod :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "digestMethod"
  , samlConfigurationPropertiesSignatureMethod :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "signatureMethod"
  , samlConfigurationPropertiesUserIntermediatePath :: !(Maybe SamlConfigurationPropertyItemsString) -- ^ "userIntermediatePath"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationProperties
instance A.FromJSON SamlConfigurationProperties where
  parseJSON = A.withObject "SamlConfigurationProperties" $ \o ->
    SamlConfigurationProperties
      <$> (o .:? "path")
      <*> (o .:? "service.ranking")
      <*> (o .:? "idpUrl")
      <*> (o .:? "idpCertAlias")
      <*> (o .:? "idpHttpRedirect")
      <*> (o .:? "serviceProviderEntityId")
      <*> (o .:? "assertionConsumerServiceURL")
      <*> (o .:? "spPrivateKeyAlias")
      <*> (o .:? "keyStorePassword")
      <*> (o .:? "defaultRedirectUrl")
      <*> (o .:? "userIDAttribute")
      <*> (o .:? "useEncryption")
      <*> (o .:? "createUser")
      <*> (o .:? "addGroupMemberships")
      <*> (o .:? "groupMembershipAttribute")
      <*> (o .:? "defaultGroups")
      <*> (o .:? "nameIdFormat")
      <*> (o .:? "synchronizeAttributes")
      <*> (o .:? "handleLogout")
      <*> (o .:? "logoutUrl")
      <*> (o .:? "clockTolerance")
      <*> (o .:? "digestMethod")
      <*> (o .:? "signatureMethod")
      <*> (o .:? "userIntermediatePath")

-- | ToJSON SamlConfigurationProperties
instance A.ToJSON SamlConfigurationProperties where
  toJSON SamlConfigurationProperties {..} =
   _omitNulls
      [ "path" .= samlConfigurationPropertiesPath
      , "service.ranking" .= samlConfigurationPropertiesServiceRanking
      , "idpUrl" .= samlConfigurationPropertiesIdpUrl
      , "idpCertAlias" .= samlConfigurationPropertiesIdpCertAlias
      , "idpHttpRedirect" .= samlConfigurationPropertiesIdpHttpRedirect
      , "serviceProviderEntityId" .= samlConfigurationPropertiesServiceProviderEntityId
      , "assertionConsumerServiceURL" .= samlConfigurationPropertiesAssertionConsumerServiceUrl
      , "spPrivateKeyAlias" .= samlConfigurationPropertiesSpPrivateKeyAlias
      , "keyStorePassword" .= samlConfigurationPropertiesKeyStorePassword
      , "defaultRedirectUrl" .= samlConfigurationPropertiesDefaultRedirectUrl
      , "userIDAttribute" .= samlConfigurationPropertiesUserIdAttribute
      , "useEncryption" .= samlConfigurationPropertiesUseEncryption
      , "createUser" .= samlConfigurationPropertiesCreateUser
      , "addGroupMemberships" .= samlConfigurationPropertiesAddGroupMemberships
      , "groupMembershipAttribute" .= samlConfigurationPropertiesGroupMembershipAttribute
      , "defaultGroups" .= samlConfigurationPropertiesDefaultGroups
      , "nameIdFormat" .= samlConfigurationPropertiesNameIdFormat
      , "synchronizeAttributes" .= samlConfigurationPropertiesSynchronizeAttributes
      , "handleLogout" .= samlConfigurationPropertiesHandleLogout
      , "logoutUrl" .= samlConfigurationPropertiesLogoutUrl
      , "clockTolerance" .= samlConfigurationPropertiesClockTolerance
      , "digestMethod" .= samlConfigurationPropertiesDigestMethod
      , "signatureMethod" .= samlConfigurationPropertiesSignatureMethod
      , "userIntermediatePath" .= samlConfigurationPropertiesUserIntermediatePath
      ]


-- | Construct a value of type 'SamlConfigurationProperties' (by applying it's required fields, if any)
mkSamlConfigurationProperties
  :: SamlConfigurationProperties
mkSamlConfigurationProperties =
  SamlConfigurationProperties
  { samlConfigurationPropertiesPath = Nothing
  , samlConfigurationPropertiesServiceRanking = Nothing
  , samlConfigurationPropertiesIdpUrl = Nothing
  , samlConfigurationPropertiesIdpCertAlias = Nothing
  , samlConfigurationPropertiesIdpHttpRedirect = Nothing
  , samlConfigurationPropertiesServiceProviderEntityId = Nothing
  , samlConfigurationPropertiesAssertionConsumerServiceUrl = Nothing
  , samlConfigurationPropertiesSpPrivateKeyAlias = Nothing
  , samlConfigurationPropertiesKeyStorePassword = Nothing
  , samlConfigurationPropertiesDefaultRedirectUrl = Nothing
  , samlConfigurationPropertiesUserIdAttribute = Nothing
  , samlConfigurationPropertiesUseEncryption = Nothing
  , samlConfigurationPropertiesCreateUser = Nothing
  , samlConfigurationPropertiesAddGroupMemberships = Nothing
  , samlConfigurationPropertiesGroupMembershipAttribute = Nothing
  , samlConfigurationPropertiesDefaultGroups = Nothing
  , samlConfigurationPropertiesNameIdFormat = Nothing
  , samlConfigurationPropertiesSynchronizeAttributes = Nothing
  , samlConfigurationPropertiesHandleLogout = Nothing
  , samlConfigurationPropertiesLogoutUrl = Nothing
  , samlConfigurationPropertiesClockTolerance = Nothing
  , samlConfigurationPropertiesDigestMethod = Nothing
  , samlConfigurationPropertiesSignatureMethod = Nothing
  , samlConfigurationPropertiesUserIntermediatePath = Nothing
  }

-- ** SamlConfigurationPropertyItemsArray
-- | SamlConfigurationPropertyItemsArray
data SamlConfigurationPropertyItemsArray = SamlConfigurationPropertyItemsArray
  { samlConfigurationPropertyItemsArrayName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsArrayOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsArrayIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsArrayType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsArrayValues :: !(Maybe [Text]) -- ^ "values" - Property value
  , samlConfigurationPropertyItemsArrayDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsArray
instance A.FromJSON SamlConfigurationPropertyItemsArray where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsArray" $ \o ->
    SamlConfigurationPropertyItemsArray
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "values")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsArray
instance A.ToJSON SamlConfigurationPropertyItemsArray where
  toJSON SamlConfigurationPropertyItemsArray {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsArrayName
      , "optional" .= samlConfigurationPropertyItemsArrayOptional
      , "is_set" .= samlConfigurationPropertyItemsArrayIsSet
      , "type" .= samlConfigurationPropertyItemsArrayType
      , "values" .= samlConfigurationPropertyItemsArrayValues
      , "description" .= samlConfigurationPropertyItemsArrayDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsArray' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsArray
  :: SamlConfigurationPropertyItemsArray
mkSamlConfigurationPropertyItemsArray =
  SamlConfigurationPropertyItemsArray
  { samlConfigurationPropertyItemsArrayName = Nothing
  , samlConfigurationPropertyItemsArrayOptional = Nothing
  , samlConfigurationPropertyItemsArrayIsSet = Nothing
  , samlConfigurationPropertyItemsArrayType = Nothing
  , samlConfigurationPropertyItemsArrayValues = Nothing
  , samlConfigurationPropertyItemsArrayDescription = Nothing
  }

-- ** SamlConfigurationPropertyItemsBoolean
-- | SamlConfigurationPropertyItemsBoolean
data SamlConfigurationPropertyItemsBoolean = SamlConfigurationPropertyItemsBoolean
  { samlConfigurationPropertyItemsBooleanName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsBooleanOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsBooleanIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsBooleanType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsBooleanValue :: !(Maybe Bool) -- ^ "value" - Property value
  , samlConfigurationPropertyItemsBooleanDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsBoolean
instance A.FromJSON SamlConfigurationPropertyItemsBoolean where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsBoolean" $ \o ->
    SamlConfigurationPropertyItemsBoolean
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsBoolean
instance A.ToJSON SamlConfigurationPropertyItemsBoolean where
  toJSON SamlConfigurationPropertyItemsBoolean {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsBooleanName
      , "optional" .= samlConfigurationPropertyItemsBooleanOptional
      , "is_set" .= samlConfigurationPropertyItemsBooleanIsSet
      , "type" .= samlConfigurationPropertyItemsBooleanType
      , "value" .= samlConfigurationPropertyItemsBooleanValue
      , "description" .= samlConfigurationPropertyItemsBooleanDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsBoolean' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsBoolean
  :: SamlConfigurationPropertyItemsBoolean
mkSamlConfigurationPropertyItemsBoolean =
  SamlConfigurationPropertyItemsBoolean
  { samlConfigurationPropertyItemsBooleanName = Nothing
  , samlConfigurationPropertyItemsBooleanOptional = Nothing
  , samlConfigurationPropertyItemsBooleanIsSet = Nothing
  , samlConfigurationPropertyItemsBooleanType = Nothing
  , samlConfigurationPropertyItemsBooleanValue = Nothing
  , samlConfigurationPropertyItemsBooleanDescription = Nothing
  }

-- ** SamlConfigurationPropertyItemsLong
-- | SamlConfigurationPropertyItemsLong
data SamlConfigurationPropertyItemsLong = SamlConfigurationPropertyItemsLong
  { samlConfigurationPropertyItemsLongName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsLongOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsLongIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsLongType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsLongValue :: !(Maybe Int) -- ^ "value" - Property value
  , samlConfigurationPropertyItemsLongDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsLong
instance A.FromJSON SamlConfigurationPropertyItemsLong where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsLong" $ \o ->
    SamlConfigurationPropertyItemsLong
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsLong
instance A.ToJSON SamlConfigurationPropertyItemsLong where
  toJSON SamlConfigurationPropertyItemsLong {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsLongName
      , "optional" .= samlConfigurationPropertyItemsLongOptional
      , "is_set" .= samlConfigurationPropertyItemsLongIsSet
      , "type" .= samlConfigurationPropertyItemsLongType
      , "value" .= samlConfigurationPropertyItemsLongValue
      , "description" .= samlConfigurationPropertyItemsLongDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsLong' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsLong
  :: SamlConfigurationPropertyItemsLong
mkSamlConfigurationPropertyItemsLong =
  SamlConfigurationPropertyItemsLong
  { samlConfigurationPropertyItemsLongName = Nothing
  , samlConfigurationPropertyItemsLongOptional = Nothing
  , samlConfigurationPropertyItemsLongIsSet = Nothing
  , samlConfigurationPropertyItemsLongType = Nothing
  , samlConfigurationPropertyItemsLongValue = Nothing
  , samlConfigurationPropertyItemsLongDescription = Nothing
  }

-- ** SamlConfigurationPropertyItemsString
-- | SamlConfigurationPropertyItemsString
data SamlConfigurationPropertyItemsString = SamlConfigurationPropertyItemsString
  { samlConfigurationPropertyItemsStringName :: !(Maybe Text) -- ^ "name" - property name
  , samlConfigurationPropertyItemsStringOptional :: !(Maybe Bool) -- ^ "optional" - True if optional
  , samlConfigurationPropertyItemsStringIsSet :: !(Maybe Bool) -- ^ "is_set" - True if property is set
  , samlConfigurationPropertyItemsStringType :: !(Maybe Int) -- ^ "type" - Property type, 1&#x3D;String, 3&#x3D;long, 11&#x3D;boolean, 12&#x3D;Password
  , samlConfigurationPropertyItemsStringValue :: !(Maybe Text) -- ^ "value" - Property value
  , samlConfigurationPropertyItemsStringDescription :: !(Maybe Text) -- ^ "description" - Property description
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlConfigurationPropertyItemsString
instance A.FromJSON SamlConfigurationPropertyItemsString where
  parseJSON = A.withObject "SamlConfigurationPropertyItemsString" $ \o ->
    SamlConfigurationPropertyItemsString
      <$> (o .:? "name")
      <*> (o .:? "optional")
      <*> (o .:? "is_set")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "description")

-- | ToJSON SamlConfigurationPropertyItemsString
instance A.ToJSON SamlConfigurationPropertyItemsString where
  toJSON SamlConfigurationPropertyItemsString {..} =
   _omitNulls
      [ "name" .= samlConfigurationPropertyItemsStringName
      , "optional" .= samlConfigurationPropertyItemsStringOptional
      , "is_set" .= samlConfigurationPropertyItemsStringIsSet
      , "type" .= samlConfigurationPropertyItemsStringType
      , "value" .= samlConfigurationPropertyItemsStringValue
      , "description" .= samlConfigurationPropertyItemsStringDescription
      ]


-- | Construct a value of type 'SamlConfigurationPropertyItemsString' (by applying it's required fields, if any)
mkSamlConfigurationPropertyItemsString
  :: SamlConfigurationPropertyItemsString
mkSamlConfigurationPropertyItemsString =
  SamlConfigurationPropertyItemsString
  { samlConfigurationPropertyItemsStringName = Nothing
  , samlConfigurationPropertyItemsStringOptional = Nothing
  , samlConfigurationPropertyItemsStringIsSet = Nothing
  , samlConfigurationPropertyItemsStringType = Nothing
  , samlConfigurationPropertyItemsStringValue = Nothing
  , samlConfigurationPropertyItemsStringDescription = Nothing
  }

-- ** TruststoreInfo
-- | TruststoreInfo
data TruststoreInfo = TruststoreInfo
  { truststoreInfoAliases :: !(Maybe [TruststoreItems]) -- ^ "aliases"
  , truststoreInfoExists :: !(Maybe Bool) -- ^ "exists" - False if truststore don&#39;t exist
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TruststoreInfo
instance A.FromJSON TruststoreInfo where
  parseJSON = A.withObject "TruststoreInfo" $ \o ->
    TruststoreInfo
      <$> (o .:? "aliases")
      <*> (o .:? "exists")

-- | ToJSON TruststoreInfo
instance A.ToJSON TruststoreInfo where
  toJSON TruststoreInfo {..} =
   _omitNulls
      [ "aliases" .= truststoreInfoAliases
      , "exists" .= truststoreInfoExists
      ]


-- | Construct a value of type 'TruststoreInfo' (by applying it's required fields, if any)
mkTruststoreInfo
  :: TruststoreInfo
mkTruststoreInfo =
  TruststoreInfo
  { truststoreInfoAliases = Nothing
  , truststoreInfoExists = Nothing
  }

-- ** TruststoreItems
-- | TruststoreItems
data TruststoreItems = TruststoreItems
  { truststoreItemsAlias :: !(Maybe Text) -- ^ "alias" - Truststore alias name
  , truststoreItemsEntryType :: !(Maybe Text) -- ^ "entryType"
  , truststoreItemsSubject :: !(Maybe Text) -- ^ "subject" - e.g. \&quot;CN&#x3D;localhost\&quot;
  , truststoreItemsIssuer :: !(Maybe Text) -- ^ "issuer" - e.g. \&quot;CN&#x3D;Admin\&quot;
  , truststoreItemsNotBefore :: !(Maybe Text) -- ^ "notBefore" - e.g. \&quot;Sun Jul 01 12:00:00 AEST 2018\&quot;
  , truststoreItemsNotAfter :: !(Maybe Text) -- ^ "notAfter" - e.g. \&quot;Sun Jun 30 23:59:50 AEST 2019\&quot;
  , truststoreItemsSerialNumber :: !(Maybe Int) -- ^ "serialNumber" - 18165099476682912368
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TruststoreItems
instance A.FromJSON TruststoreItems where
  parseJSON = A.withObject "TruststoreItems" $ \o ->
    TruststoreItems
      <$> (o .:? "alias")
      <*> (o .:? "entryType")
      <*> (o .:? "subject")
      <*> (o .:? "issuer")
      <*> (o .:? "notBefore")
      <*> (o .:? "notAfter")
      <*> (o .:? "serialNumber")

-- | ToJSON TruststoreItems
instance A.ToJSON TruststoreItems where
  toJSON TruststoreItems {..} =
   _omitNulls
      [ "alias" .= truststoreItemsAlias
      , "entryType" .= truststoreItemsEntryType
      , "subject" .= truststoreItemsSubject
      , "issuer" .= truststoreItemsIssuer
      , "notBefore" .= truststoreItemsNotBefore
      , "notAfter" .= truststoreItemsNotAfter
      , "serialNumber" .= truststoreItemsSerialNumber
      ]


-- | Construct a value of type 'TruststoreItems' (by applying it's required fields, if any)
mkTruststoreItems
  :: TruststoreItems
mkTruststoreItems =
  TruststoreItems
  { truststoreItemsAlias = Nothing
  , truststoreItemsEntryType = Nothing
  , truststoreItemsSubject = Nothing
  , truststoreItemsIssuer = Nothing
  , truststoreItemsNotBefore = Nothing
  , truststoreItemsNotAfter = Nothing
  , truststoreItemsSerialNumber = Nothing
  }




-- * Auth Methods

-- ** AuthBasicAemAuth
data AuthBasicAemAuth =
  AuthBasicAemAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicAemAuth where
  applyAuthMethod _ a@(AuthBasicAemAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


